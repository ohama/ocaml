<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Usage tips on Documentation for Hugo Learn Theme</title>
    <link>https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/</link>
    <description>Recent content in Usage tips on Documentation for Hugo Learn Theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    
	<atom:link href="https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Keyword table</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/keywordtable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/keywordtable/</guid>
      <description>The number of status transitions generated by ocamllex are limited to at most 32767. If you use too many transitions, for example, too many keywords, ocamllex generates the following error message:
camllex: transition table overflow, automaton is too big It tells that your lexer definition is too complex. To make the generated automata small, you have to encode using keyword table:
{ let keyword_table = Hashtbl.create 72 let _ = List.</description>
    </item>
    
    <item>
      <title>Nested comments</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/nestedcomments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/nestedcomments/</guid>
      <description>Some language such as Ocaml support nested comment. It can be implemented like this:
{ } rule token = parse | &amp;#34;(*&amp;#34;	{ print_endline &amp;#34;comments start&amp;#34;; comments 0 lexbuf } | [&amp;#39; &amp;#39; &amp;#39;\t&amp;#39; &amp;#39;\n&amp;#39;]	{ token lexbuf } | [&amp;#39;a&amp;#39;-&amp;#39;z&amp;#39;]+ as word { Printf.printf &amp;#34;word: %s\n&amp;#34; word; token lexbuf } | _ as c	{ Printf.printf &amp;#34;char %c\n&amp;#34; c; token lexbuf } | eof	{ raise End_of_file } and comments level = parse | &amp;#34;*)&amp;#34;	{ Printf.</description>
    </item>
    
  </channel>
</rss>