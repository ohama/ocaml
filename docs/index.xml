<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on Documentation for Hugo Learn Theme</title>
    <link>https://ohama.github.io/ocaml/</link>
    <description>Recent content in Tutorials on Documentation for Hugo Learn Theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    
	<atom:link href="https://ohama.github.io/ocaml/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/intro/</guid>
      <description>ocamllex is a tool for generating scanners: programs which recognized lexical patterns in text. ocamllex reads the given input files, for a description of a scanner to generate. The description is in the form of pairs of regular expressions and Ocaml code, called rules. ocamllex generates as output a Ocaml source file which defines lexical analyzer functions. This file is compiled and linked to produce an executable. When the executable is run, it analyzes its input for occurrences of the regular expressions.</description>
    </item>
    
    <item>
      <title>Keyword table</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/keywordtable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/keywordtable/</guid>
      <description>The number of status transitions generated by ocamllex are limited to at most 32767. If you use too many transitions, for example, too many keywords, ocamllex generates the following error message:
camllex: transition table overflow, automaton is too big  It tells that your lexer definition is too complex. To make the generated automata small, you have to encode using keyword table:
{ let keyword_table = Hashtbl.create 72 let _ = List.</description>
    </item>
    
    <item>
      <title>License in flex manual</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/license/licenseinflex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/license/licenseinflex/</guid>
      <description>Copyright &amp;copy; 1990 The Regents of the University of California. All rights reserved.
This code is derived from software contributed to Berkeley by Vern Paxson.
The United States Government has rights in this work pursuant to contract no. DE-AC03-76SF00098 between the United States Department of Energy and the University of California.
Redistribution and use in source and binary forms with or without modification are permitted provided that: (1) source distributions retain this entire copyright notice and comment, and (2) distributions including binaries display the following acknowledgement: &amp;ldquo;This product includes software developed by the University of California, Berkeley and its contributors&amp;rdquo; in the documentation or other materials provided with the distribution and in all advertising materials mentioning features or use of this software.</description>
    </item>
    
    <item>
      <title>Position</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/actions/position/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/actions/position/</guid>
      <description>Since Ocaml 3.08
 The position information on scanning the input text is recorded in the lexbuf which has a field lex_curr_p of the type position:
 type position = { pos_fname : string;	(* file name *) pos_lnum : int;	(* line number *) pos_bol : int;	(* the offset of the beginning of the line *) pos_cnum : int;	(* the offset of the position *) }  The value of pos_bol field is the number of characters between the beginning of the file and the beginning of the line while the value of pos_cnum field is the number of characters between the beginning of the file and the position.</description>
    </item>
    
    <item>
      <title>Translate</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/examples/translate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/examples/translate/</guid>
      <description>This example translates the text &amp;ldquo;current_directory&amp;rdquo; to the current directory.
{ } rule translate = parse | &amp;quot;current_directory&amp;quot;	{ print_string (Sys.getcwd ()) } | _ as c	{ print_char c } | eof	{ exit 0 } { let main () = let lexbuf = Lexing.from_channel stdin in while true do translate lexbuf done let _ = Printexc.print main () }  </description>
    </item>
    
    <item>
      <title>Copyright and permission</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/license/copyright/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/license/copyright/</guid>
      <description>Ocamllex Adaptation Copyright and Permissions Notice Copyright &amp;copy; 2004 SooHyoung Oh.
Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.
Permission is granted to copy and distribute modified versions of this document under the conditions for verbatim copying, provided that this copyright notice is included exactly as in the original, and that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</description>
    </item>
    
    <item>
      <title>Nested comments</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/nestedcomments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/nestedcomments/</guid>
      <description>Some language such as Ocaml support nested comment. It can be implemented like this:
{ } rule token = parse | &amp;quot;(*&amp;quot;	{ print_endline &amp;quot;comments start&amp;quot;; comments 0 lexbuf } | [&#39; &#39; &#39;\t&#39; &#39;\n&#39;]	{ token lexbuf } | [&#39;a&#39;-&#39;z&#39;]+ as word { Printf.printf &amp;quot;word: %s\n&amp;quot; word; token lexbuf } | _ as c	{ Printf.printf &amp;quot;char %c\n&amp;quot; c; token lexbuf } | eof	{ raise End_of_file } and comments level = parse | &amp;quot;*)&amp;quot;	{ Printf.</description>
    </item>
    
    <item>
      <title>Some simple examples</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/simpleexample/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/simpleexample/</guid>
      <description>First some simple examples to get the flavor of how one uses ocamllex. The following ocamllex input specifies a scanner which whenever it encounters the string &amp;ldquo;current_directory&amp;rdquo; will replace it with the current directory:
{ } rule translate = parse | &amp;quot;current_directory&amp;quot;	{ print_string (Sys.getcwd ()); translate lexbuf } | _ as c	{ print_char c; translate lexbuf } | eof	{ exit 0 }  In the first rule, &amp;ldquo;current_directory&amp;rdquo; is the pattern and the expression between braces is the action.</description>
    </item>
    
    <item>
      <title>Word count</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/examples/wordcount/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/examples/wordcount/</guid>
      <description>This example shows the number of lines, words and characters of the given file if the filename is given, or of the standard input if no command arguments are given.
{ } rule count lines words chars = parse | &#39;\n&#39;	{ count (lines+1) words (chars+1) lexbuf } | [^ &#39; &#39; &#39;\t&#39; &#39;\n&#39;]+ as word { count lines (words+1) (chars+ String.length word) lexbuf } | _	{ count lines words (chars+1) lexbuf } | eof	{ (lines, words, chars) } { let main () = let cin = if Array.</description>
    </item>
    
    <item>
      <title>Format of the input file</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/formatofinputfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/formatofinputfile/</guid>
      <description>The ocamllex input file consists of four sections; header, definitions, rules and trailer section:
(* header section *) { &amp;lt;header&amp;gt; } (* definitions section *) let &amp;lt;ident&amp;gt; = &amp;lt;regexp&amp;gt; let ...	(* rules section *) rule &amp;lt;entrypoint_1&amp;gt; [arg1... argn] = parse | &amp;lt;pattern&amp;gt; { &amp;lt;action&amp;gt; } | ... | &amp;lt;pattern&amp;gt; { &amp;lt;action&amp;gt; } and &amp;lt;entrypoint_2&amp;gt; [arg1... argn] = parse ... and ... (* trailer section *) { &amp;lt;trailer&amp;gt; }  Comments are delimited by (* and *), as in Caml.</description>
    </item>
    
    <item>
      <title>Toy language</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/examples/toylanguage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/examples/toylanguage/</guid>
      <description>In this example, the scanner function toy_lang returns a value of token type, but the main function does nothing with it.
{ open Printf let create_hashtable size init = let tbl = Hashtbl.create size in List.iter (fun (key, data) -&amp;gt; Hashtbl.add tbl key data) init; tbl type token = | IF | THEN | ELSE | BEGIN | END | FUNCTION | ID of string | OP of char | INT of int | FLOAT of float | CHAR of char let keyword_table = create_hashtable 8 [ (&amp;quot;if&amp;quot;, IF); (&amp;quot;then&amp;quot;, THEN); (&amp;quot;else&amp;quot;, ELSE); (&amp;quot;begin&amp;quot;, BEGIN); (&amp;quot;end&amp;quot;, END); (&amp;quot;function&amp;quot;, FUNCTION) ] } let digit = [&#39;0&#39;-&#39;9&#39;] let id = [&#39;a&#39;-&#39;z&#39; &#39;A&#39;-&#39;Z&#39;][&#39;a&#39;-&#39;z&#39; &#39;0&#39;-&#39;9&#39;]* rule toy_lang = parse | digit+ as inum { let num = int_of_string inum in printf &amp;quot;integer: %s (%d)\n&amp;quot; inum num; INT num } | digit+ &#39;.</description>
    </item>
    
    <item>
      <title>Patterns</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/patterns/</guid>
      <description>The patterns in the input are written using regular expressions in the style of lex, with a more Caml-like syntax. These are:
 &amp;lsquo;c&amp;rsquo;: match the character &amp;lsquo;c&amp;rsquo;. The character constant is the same syntax as Objective Caml character. _: (underscore) match any character. eof: match an end-of-file . &amp;ldquo;foo&amp;rdquo;: the literal string &amp;ldquo;foo&amp;rdquo;. The syntax is the same syntax as Objective Caml string constants. [&amp;lsquo;x&amp;rsquo; &amp;lsquo;y&amp;rsquo; &amp;lsquo;z&amp;rsquo;]: character set; in this case, the pattern matches either an &amp;lsquo;x&amp;rsquo;, a &amp;lsquo;y&amp;rsquo;, or a &amp;lsquo;z&amp;rsquo; .</description>
    </item>
    
    <item>
      <title>How the input is matched</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/howmatched/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/howmatched/</guid>
      <description>When the generated scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, it takes the one matching the most text (the &amp;ldquo;longest match&amp;rdquo; principle). If it finds two or more matches of the same length, the rule listed first in the ocamllex input file is chosen (the &amp;ldquo;first match&amp;rdquo; principle).
Once the match is determined, the text corresponding to the match (called the token) is made available in the form of a string.</description>
    </item>
    
    <item>
      <title>The generted scanner</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/generatedscanner/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/generatedscanner/</guid>
      <description>The output of ocamllex is the file lex.ml when it is invoked as ocamllex lex.mll. The generated file contains the scanning functions, a number of tables used by it for matching tokens, and a number of auxiliary routines. The scanning functions are declared as followings:
let &amp;lt;entrypoint&amp;gt; [arg1... argn] lexbuf = ... and ...  where the fuction entrypoint has n + 1 arguments. n arguments come from the definition of the rules secton.</description>
    </item>
    
    <item>
      <title>Start conditions</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/startcondition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/startcondition/</guid>
      <description>ocamllex provides a mechanism for conditionally activating rules. When you want do activate the other rule, just call the other entrypoint function. For example, the following has two rules, one for finding tokens and one for skipping comments.
{} rule token = parse | [&#39; &#39; &#39;\t&#39; &#39;\n&#39;]+ (* skip spaces *) { token lexbuf } | &amp;quot;(*&amp;quot; (* activate &amp;quot;comment&amp;quot; rule *) { comment lexbuf } ... and comment = parse | &amp;quot;*)&amp;quot; (* go to the &amp;quot;token&amp;quot; rule *) { token lexbuf } | _ (* skip comments *) { comment lexbuf } .</description>
    </item>
    
    <item>
      <title>Interfacing with ocamlyacc</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/interfacewithocamlyacc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/interfacewithocamlyacc/</guid>
      <description>One of the main uses of ocamllex is as a companion to the ocamlyacc parser-generator. ocamlyacc parsers call one of the scanning functions to find the next input token. The routine is supposed to return the type of the next token with an associated value. To use ocamllex with ocamlyacc, scanner functions should use parser module to refer token types, which are defined in `%tokens&amp;rsquo; attributes appearing in the ocamlyacc input.</description>
    </item>
    
    <item>
      <title>Bison license</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/license/bisonlicense/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/license/bisonlicense/</guid>
      <description>The bison manual requires &amp;ldquo;GNU General Public License&amp;rdquo; and &amp;ldquo;GNU Free Documentation License&amp;rdquo;.
License of bison manual Copyright &amp;copy; 1988, 1989, 1990, 1991, 1992, 1993, 1995, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.
Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided also that the sections entitled &amp;ldquo;GNU General Public License&amp;rdquo; and &amp;ldquo;Conditions for Using Bison&amp;rdquo; are included exactly as in the original, and provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</description>
    </item>
    
    <item>
      <title>Grammar outline</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/grammaroutline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/grammaroutline/</guid>
      <description>A Ocamlyacc grammar file has four main sections, shown here with the appropriate delimiters:
%{ Header - Ocaml declarations (Ocaml code) %} Ocamlyacc declarations %% Grammar rules %% Trailer - Additional Ocaml code (Ocaml code)  By default, comments are enclosed between /* and / (as in C) except in Ocaml code. So use / and / in the declarations and rules sections, ( and *) in header and trailer sections.</description>
    </item>
    
    <item>
      <title>Hello world in GTK</title>
      <link>https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/helloworld/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/helloworld/</guid>
      <description>Now for a program with a widget (a button). It&amp;rsquo;s the classic hello world a la GTK.
(* file: hello.ml *) (* This is a callback function. *) let hello () = print_endline &amp;quot;Hello World&amp;quot;; flush stdout (* Another callback function. * If you return [false] in the &amp;quot;delete_event&amp;quot; signal handler, * GTK will emit the &amp;quot;destroy&amp;quot; signal. Returning [true] means * you don&#39;t want the window to be destroyed. * This is useful for popping up &#39;are you sure you want to quit?</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/introduction/</guid>
      <description>Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>Languages and context-free grammars</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/languagsandcfg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/languagsandcfg/</guid>
      <description>In order for Ocamlyacc to parse a language, it must be described by a context-free grammar. This means that you specify one or more syntactic groupings and give rules for constructing them from their parts. For example, in the C language, one kind of grouping is called an &amp;lsquo;expression&amp;rsquo;. One rule for making an expression might be, &amp;ldquo;An expression can be made of a minus sign and another expression&amp;rdquo;. Another would be, &amp;ldquo;An expression can be an integer&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Lookahead Tokens</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/lookaheadtokens/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/lookaheadtokens/</guid>
      <description>The Ocamlyacc parser does not always reduce immediately as soon as the last n tokens and groupings match a rule. This is because such a simple strategy is inadequate to handle most languages. Instead, when a reduction is possible, the parser sometimes &amp;ldquo;looks ahead&amp;rdquo; at the next token in order to decide what to do.
When a token is read, it is not immediately shifted; first it becomes the look-ahead token, which is not on the stack.</description>
    </item>
    
    <item>
      <title>More on signal handlers</title>
      <link>https://ohama.github.io/ocaml/lablgtk2-tutorial/movingon/moreonsignalhandlers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/lablgtk2-tutorial/movingon/moreonsignalhandlers/</guid>
      <description>Lets take another look at the #connect#signal_name declaration.
#connect#signal_name ~callback:(unit -&amp;gt; unit) -&amp;gt; GtkSignal.id  Notice the GtkSignal.id return value? This is a tag that identifies your callback function. As stated above, you may have as many callbacks per signal and per object as you need, and each will be executed in turn, in the order they were attached.
This tag allows you to remove this callback from the list by using #misc#disconnect method:</description>
    </item>
    
    <item>
      <title>Options</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/options/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/options/</guid>
      <description>ocamllex has the following options:
 &amp;rdquo;-o output-file&amp;rdquo;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; By default, ocamllex produces lexer.ml, when ocamllex is invoked as &amp;ldquo;ocamllex lexer.mll&amp;rdquo;. You can change the name of the output file using -o option.
 &amp;rdquo;-ml&amp;rdquo;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; By default, ocamllex produces code that uses the Caml built-in automata interpreter. Using this option, the automaton is coded as Caml functions. This option is useful for debugging ocamllex, but it&amp;rsquo;s not recommended for production lexers.</description>
    </item>
    
    <item>
      <title>Options</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/invokingocamlyacc/options/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/invokingocamlyacc/options/</guid>
      <description>Here is a list of options that can be used with Ocamlyacc:
 -v: By default, this option generates a file grammar.output. It contains parsing infomation such as a description of the parsing tables and a report on ambiguities in the grammar.
 -bfname: Change the name of the output files to fname.ml, fname.mli and fname.output.
  </description>
    </item>
    
    <item>
      <title>Parser Functions</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parserinterface/parserfunctions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parserinterface/parserfunctions/</guid>
      <description>To cause parsing to occur, you call the parser function with two parameters. The first parameter is the lexical analyzer function of type
Lexing.lexbuf -&amp;gt; token  and the second is a value of Lexing.lexbuf type.
If the start symbol is parse in the file parser.mly and the lexer function is is token of the file lexer.mll, the typical usage is:
let lexbuf = Lexing.from_channel stdin in ... let result = Parser.</description>
    </item>
    
    <item>
      <title>Reverse Polish Notation Calculator</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/reverspolishcalculator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/reverspolishcalculator/</guid>
      <description>The first example is that of a simple double-precision reverse polish notation calculator (a calculator using postfix operators). This example provides a good starting point, since operator precedence is not an issue. The second example will illustrate how operator precedence is handled.
The source code for this calculator is named rpcalc.mly. The .mly extension is a convention used for Ocamlyacc input files.
Declarations for &amp;ldquo;rpcalc&amp;rdquo; Here are the Ocaml and Ocamlyacc declarations for the reverse polish notation calculator.</description>
    </item>
    
    <item>
      <title>introduction</title>
      <link>https://ohama.github.io/ocaml/lablgtk2-tutorial/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/lablgtk2-tutorial/introduction/</guid>
      <description>GTK (GIMP Toolkit) is a library for creating graphical user interfaces. It is licensed using the LGPL license, so you can develop open software, free software, or even commercial non-free software using GTK without having to spend anything for licenses or royalties.
It&amp;rsquo;s called the GIMP toolkit because it was originally written for developing the GNU Image Manipulation Program (GIMP), but GTK has now been used in a large number of software projects, including the GNU Network Object Model Environment (GNOME) project.</description>
    </item>
    
    <item>
      <title>Compiling hello world</title>
      <link>https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/compiling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/compiling/</guid>
      <description>To compile use:
ocamlc -I +lablgtk2 -o helloworld lablgtk.cma gtkInit.cmo helloworld.ml  The options are:
 -I +lablgtk2: adds the subdirectory lablgtk2 of the standard library to the search path. In that directory, there are compiled interface files (.cmi), compiled object code files (.cmo), libraries (.cma) related with lablgtk2.
 -o helloworld: specify the name of the output file produced by the linker.
  The library and object that are usually linked in are:</description>
    </item>
    
    <item>
      <title>Copyright and permission</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/license/copyright/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/license/copyright/</guid>
      <description>Copyright &amp;copy; 2004-2019 SooHyoung Oh.
Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.
Permission is granted to copy and distribute modified versions of this document under the conditions for verbatim copying, provided that this copyright notice is included exactly as in the original, and that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</description>
    </item>
    
    <item>
      <title>From Foraml Rules to Ocamlyacc Input</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/formalrule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/formalrule/</guid>
      <description>A formal grammar is a mathematical construct. To define the language for Ocamlyacc, you must write a file expressing the grammar in Ocamlyacc syntax: a Ocamlyacc grammar file. See Ocamlyacc Grammar Files.
A nonterminal symbol in the formal grammar is represented in Ocamlyacc input as an identifier, like an identifier in Ocaml. It is like regular Caml symbol, except that it cannot end with &amp;lsquo; (single quote). It should start in lower case, such as expr, stmt or declaration.</description>
    </item>
    
    <item>
      <title>Infix Notation Calculator</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/infixcalculator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/infixcalculator/</guid>
      <description>We now modify rpcalc to handle infix operators instead of postfix. Infix notation involves the concept of operator precedence and the need for parentheses nested to arbitrary depth. Here is the Ocamlyacc code for calc.mly, an infix desk-top calculator.
/* file: calc.mly */ /* Infix notatoin calculator -- calc */ %{ open Printf %} /* Ocamlyacc Declarations */ %token NEWLINE %token LPAREN RPAREN %token &amp;lt;float&amp;gt; NUM %token PLUS MINUS MULTIPLY DIVIDE CARET %left PLUS MINUS %left MULTIPLY DIVIDE %left NEG	/* negation -- unary minus */ %right CARET	/* exponentiation */ %start input %type &amp;lt;unit&amp;gt; input /* Grammar follows */ %% input:	/* empty */	{ } | input line	{ } ; line:	NEWLINE	{ } | exp NEWLINE	{ printf &amp;quot;\t%.</description>
    </item>
    
    <item>
      <title>Lexical Functions</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parserinterface/lexicalfunctions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parserinterface/lexicalfunctions/</guid>
      <description>The lexical analyzer function, named after rule declarations, recognizes tokens from the input stream and returns them to the parser. Ocamlyacc does not create this function automatically; you must write it so that parser function can call it. The function is sometimes referred to as a lexical scanner.
This function is usually generated by ocamllex. See Chapter 12 Lexer and parser generators (ocamllex, ocamlyacc).</description>
    </item>
    
    <item>
      <title>Operator Precedence</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/operatorprecedence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/operatorprecedence/</guid>
      <description>Another situation where shift/reduce conflicts appear is in arithmetic expressions. Here shifting is not always the preferred resolution; the Ocamlyacc declarations for operator precedence allow you to specify when to shift and when to reduce.
When Precedence is Needed Consider the following ambiguous grammar fragment (ambiguous because the input 1 - 2 * 3 can be parsed in two different ways):
expr: expr MINUS expr | expr MULTIPLY expr | expr LT expr | LPAREN expr RPAREN .</description>
    </item>
    
    <item>
      <title>Shift Reduct Conflicts</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/shiftreduceconflicts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/shiftreduceconflicts/</guid>
      <description>Suppose we are parsing a language which has if-then and if-then-else statements, with a pair of rules like this:
if_stmt: IF expr THEN stmt | IF expr THEN stmt ELSE stmt ;  Here we assume that IF, THEN and ELSE are terminal symbols for specific keyword tokens.
When the ELSE token is read and becomes the look-ahead token, the contents of the stack (assuming the input is valid) are just right for reduction by the first rule.</description>
    </item>
    
    <item>
      <title>Symbols, Terminal and Nonterminal</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/symbols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/symbols/</guid>
      <description>Symbols in Ocamlyacc grammars represent the grammatical classifications of the language.
A terminal symbol (also known as a token type) represents a class of syntactically equivalent tokens. You use the symbol in grammar rules to mean that a token in that class is allowed. The symbol is represented in the Ocamlyacc parser by a value of variant type, and the lexer function function returns a token type to indicate what kind of token has been read.</description>
    </item>
    
    <item>
      <title>Upgraded hello world</title>
      <link>https://ohama.github.io/ocaml/lablgtk2-tutorial/movingon/upgradedhelloworld/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/lablgtk2-tutorial/movingon/upgradedhelloworld/</guid>
      <description>Let&amp;rsquo;s take a look at a slightly improved helloworld with better examples of callbacks. This will also introduce us to our next topic, packing widgets.
(* file: hello2.ml *) let clicked msg () = print_endline msg; flush stdout let delete_event ev = GMain.Main.quit (); false let main () = (* Create a new window and sets the border width and title of the window. *) let window = GWindow.window ~title:&amp;quot;Hello Buttons!</description>
    </item>
    
    <item>
      <title>Error Functions</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parserinterface/errorfunctions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parserinterface/errorfunctions/</guid>
      <description>The Ocamlyacc parser detects a parse error or syntax error whenever it reads a token which cannot satisfy any syntax rule. An action in the grammar can also explicitly proclaim an error, using the raise Parsing.Parse_error.
The Ocamlyacc parser expects to report the error by calling an error reporting function named parse_error, which is optional. The default parse_error function does nothing and returns. It is called by the parser function whenever a syntax error is found, and it receives one argument.</description>
    </item>
    
    <item>
      <title>Semantic values</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/semanticvalues/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/semanticvalues/</guid>
      <description>A formal grammar selects tokens only by their classifications: for example, if a rule mentions the terminal symbol `integer constant&amp;rsquo;, it means that any integer constant is grammatically valid in that position. The precise value of the constant is irrelevant to how to parse the input: if x+4 is grammatical then x+1 or x+3989 is equally grammatical.
But the precise value is very important for what the input means once it is parsed.</description>
    </item>
    
    <item>
      <title>Simple Error Recovery</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/simpleerrorrecovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/simpleerrorrecovery/</guid>
      <description>Up to this point, this manual has not addressed the issue of error recovery&amp;mdash;how to continue parsing after the parser detects a syntax error. All we have handled is error reporting with parse_error. Recall that by default, the parser function raises exception after calling parse_error. This means that an erroneous input line causes the calculator program to raise exception and exit. Now we show how to rectify this deficiency.
The Ocamlyacc language itself includes the reserved word error, which may be included in the grammar rules.</description>
    </item>
    
    <item>
      <title>Syntax of grammar rules</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/syntaxofrules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/syntaxofrules/</guid>
      <description>A Ocamlyacc grammar rule has the following general form:
result: symbol ... symbol { semantic-action } | ... | symbol ... symbol { semantic-action } ;  where result is the nonterminal symbol that this rule describes, and symbol are various terminal and nonterminal symbols that are put together by this rule (see Symbols).
For example,
exp: exp PLUS exp	{} ;  says that two groupings of type exp, with a PLUS token in between, can be combined into a larger grouping of type exp.</description>
    </item>
    
    <item>
      <title>Theory of Signals and Callbacks</title>
      <link>https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/signalandcallback/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/signalandcallback/</guid>
      <description>Before we look in detail at helloworld, we&amp;rsquo;ll discuss signals and callbacks. GTK is an event driven toolkit, which means it will sleep in GMain.Main.main until an event occurs and control is passed to the appropriate function.
This passing of control is done using the idea of &amp;ldquo;signals&amp;rdquo;. (Note that these signals are not the same as the Unix system signals, and are not implemented using them, although the terminology is almost identical.</description>
    </item>
    
    <item>
      <title>Context-Dependent Precedence</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/contextdependentprecedence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/contextdependentprecedence/</guid>
      <description>Often the precedence of an operator depends on the context. This sounds outlandish at first, but it is really very common. For example, a minus sign typically has a very high precedence as a unary operator, and a somewhat lower precedence (lower than multiplication) as a binary operator.
The Ocamlyacc precedence declarations, %left, %right and %nonassoc, can only be used once for a given token; so a token has only one precedence declared in this way.</description>
    </item>
    
    <item>
      <title>Events</title>
      <link>https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/events/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/events/</guid>
      <description>In addition to the signal mechanism described above, there is a set of events that reflect the Window event mechanism. Callbacks may also be attached to these events. These events are: (see event_signals)
 any button_press button_release scroll motion_notify delete destroy expose key_press key_release enter_notify leave_notify configure focus_in focus_out map unmap property_notify selection_clear selection_request selection_notify proximity_in proximity_out visibility_notify client no_expose window_state  In order to connect a callback function to one of these events you use the #event#connect method, using one of the above event names as the event_signal_name like this:</description>
    </item>
    
    <item>
      <title>Location Tracking Calculator</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/locationtrackingcalculator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/locationtrackingcalculator/</guid>
      <description>This example extends the infix notation calculator with location tracking. This feature will be used to improve the error messages. For the sake of clarity, this example is a simple integer calculator, since most of the work needed to use locations will be done in the lexical analyser.
3.4.1. Declarations for ltcalc
The Ocaml and Ocamlyacc declarations for the location tracking calculator are the same as the declarations for the infix notation calculator except open Lexing.</description>
    </item>
    
    <item>
      <title>Recursive Rules</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/recursiverules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/recursiverules/</guid>
      <description>A rule is called recursive when its result nonterminal appears also on its right hand side. Nearly all Ocamlyacc grammars need to use recursion, because that is the only way to define a sequence of any number of a particular thing. Consider this recursive definition of a comma-separated sequence of one or more expressions:
expseq1: exp	{} | expseq1 COMMA exp	{} ;  Since the recursive use of expseq1 is the leftmost symbol in the right hand side, we call this left recursion.</description>
    </item>
    
    <item>
      <title>Semantic actions</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/semanticactions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/semanticactions/</guid>
      <description>In order to be useful, a program must do more than parse input; it must also produce some output based on the input. In a Ocamlyacc grammar, a grammar rule can have an action made up of Ocaml statements. Each time the parser recognizes a match for that rule, the action is executed. See Actions,
Most of the time, the purpose of an action is to compute the semantic value of the whole construct from the semantic values of its parts.</description>
    </item>
    
    <item>
      <title>Defineing Language Semantics</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/definesemantics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/definesemantics/</guid>
      <description>The grammar rules for a language determine only the syntax. The semantics are determined by the semantic values associated with various tokens and groupings, and by the actions taken when various groupings are recognized.
For example, the calculator calculates properly because the value associated with each expression is the proper number; it adds properly because the action for the grouping x + y is to add the numbers associated with x and y.</description>
    </item>
    
    <item>
      <title>Locations</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/locations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/locations/</guid>
      <description>Many applications, like interpreters or compilers, have to produce verbose and useful error messages. To achieve this, one must be able to keep track of the textual position, or location, of each syntactic construct. Ocamlyacc provides a mechanism for handling these locations.
Each token has a semantic value. In a similar fashion, each token has an associated location, but the type of locations is the same for all tokens and groupings.</description>
    </item>
    
    <item>
      <title>Multi-Function Calculator</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/multifunctioncalculator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/multifunctioncalculator/</guid>
      <description>Now that the basics of Ocamlyacc have been discussed, it is time to move on to a more advanced problem. The above calculators provided only five functions, +, -, *, / and ^. It would be nice to have a calculator that provides other mathematical functions such as sin, cos, etc.
In this example, we will show how to implement built-in functions whose syntax has this form:
function_name (argument)  At the same time, we will add memory to the calculator, by allowing you to create named variables, store values in them, and use them later.</description>
    </item>
    
    <item>
      <title>Parser States</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/parserstates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/parserstates/</guid>
      <description>The function yyparse is implemented using a finite-state machine. The values pushed on the parser stack are not simply token type codes; they represent the entire sequence of terminal and nonterminal symbols at or near the top of the stack. The current state collects all the information about previous input which is relevant to deciding what to do next.
Each time a look-ahead token is read, the current parser state together with the type of look-ahead token are looked up in a table.</description>
    </item>
    
    <item>
      <title>Stepping throught hello world</title>
      <link>https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/steppingthroughhelloworld/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/steppingthroughhelloworld/</guid>
      <description>Now that we know the theory behind this, let&amp;rsquo;s clarify by walking through the example helloworld program.
Here is the callback function that will be called when the button is &amp;ldquo;clicked&amp;rdquo;. We ignore both the widget and the data in this example, but it is not hard to do things with them. The next example will use the data argument to tell us which button was pressed.
let hello () = print_endline &amp;quot;Hello World&amp;quot;; flush stdout  The next callback is a bit special.</description>
    </item>
    
    <item>
      <title>Ocamlyacc output</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/ocamlyaccoutput/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/ocamlyaccoutput/</guid>
      <description>When you run Ocamlyacc, you give it a Ocamlyacc grammar file as input. The output is a Ocaml source file that parses the language described by the grammar. This file is called a Ocamlyacc parser. Keep in mind that the Ocamlyacc utility and the Ocamlyacc parser are two distinct programs: the Ocamlyacc utility is a program whose output is the Ocamlyacc parser that becomes part of your program.
The job of the Ocamlyacc parser is to group tokens into groupings according to the grammar rules&amp;mdash;for example, to build identifiers and operators into expressions.</description>
    </item>
    
    <item>
      <title>Reduce/Reduce Conflicts</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/reducereduceconflicts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/reducereduceconflicts/</guid>
      <description>A reduce/reduce conflict occurs if there are two or more rules that apply to the same sequence of input. This usually indicates a serious error in the grammar.
For example, here is an erroneous attempt to define a sequence of zero or more word groupings.
sequence: /* empty */	{ printf &amp;quot;empty sequence\n&amp;quot; } | maybeword	{} | sequence word	{ printf &amp;quot;added word %s\n&amp;quot; $2 } ; maybeword: /* empty */	{ printf &amp;quot;empty maybeword\n&amp;quot; } | word	{ printf &amp;quot;single word %s\n&amp;quot; $1 } ;  The error is an ambiguity: there is more than one way to parse a single word into a sequence.</description>
    </item>
    
    <item>
      <title>Tracking Locations</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/trackinglocations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/trackinglocations/</guid>
      <description>Though grammar rules and semantic actions are enough to write a fully functional parser, it can be useful to process some additionnal informations, especially symbol locations.
The way locations are handled is defined by providing a data type, and actions to take when rules are matched.
Data Type of Locations The data type for locations has the following type:
type position = { pos_fname : string;	(* file name *) pos_lnum : int;	(* line number *) pos_bol : int;	(* the offset of the beginning of the line *) pos_cnum : int;	(* the offset of the position *) }  The value of pos_bol field is the number of characters between the beginning of the file and the beginning of the line while the value of pos_cnum field is the number of characters between the beginning of the file and the position.</description>
    </item>
    
    <item>
      <title>Error Recovery</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/errorrecovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/errorrecovery/</guid>
      <description>It is not usually acceptable to have a program terminate on a parse error. For example, a compiler should recover sufficiently to parse the rest of the input file and check it for errors; a calculator should accept another expression.
In a simple interactive command parser where each input is one line, it may be sufficient to have the caller catch the exception and ignore the rest of the input line when that happens (and then call parse function again).</description>
    </item>
    
    <item>
      <title>Misterious Reduce/Reduce Conflicts</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/mysteriousreducereductconflicts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/mysteriousreducereductconflicts/</guid>
      <description>Sometimes reduce/reduce conflicts can occur that don&amp;rsquo;t look warranted. Here is an example:
%token ID COMMA COLON %% def: param_spec return_spec COMMA ; param_spec: type | name_list COLON type ; return_spec: type | name COLON type ; type: ID ; name: ID ; name_list: name | name COMMA name_list ;  It would seem that this grammar can be parsed with only a single token of look-ahead: when a param_spec is being read, an ID is a name if a comma or colon follows, or a type if another ID follows.</description>
    </item>
    
    <item>
      <title>Nonterminal Symbols</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/nonterminal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/nonterminal/</guid>
      <description>The Ocamlyacc declarations section of a Ocamlyacc grammar defines the symbols used in formulating the grammar and the data types of semantic values. See Symbols.
All token type must be declared. Nonterminal symbols must be declared if you need to specify which data type to use for the semantic value (see Data Types of Semantic Values).
The first rule in the file also specifies the start symbol, by default. If you want some other symbol to be the start symbol, you must declare it explicitly (see Languages and Context-Free Grammars).</description>
    </item>
    
    <item>
      <title>Ocamlyacc Declarations</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/declarations/</guid>
      <description>The Ocamlyacc declarations section of a Ocamlyacc grammar defines the symbols used in formulating the grammar and the data types of semantic values. See Symbols.
All token type must be declared. Nonterminal symbols must be declared if you need to specify which data type to use for the semantic value (see Data Types of Semantic Values).
The first rule in the file also specifies the start symbol, by default. If you want some other symbol to be the start symbol, you must declare it explicitly (see Languages and Context-Free Grammars).</description>
    </item>
    
    <item>
      <title>Stages in use ocamlyacc</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/stages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/stages/</guid>
      <description>The actual language-design process using Ocamlyacc, from grammar specification to a working compiler or interpreter, has these parts:
Formally specify the grammar in a form recognized by Ocamlyacc (see Ocamlyacc Grammar Files). For each grammatical rule in the language, describe the action that is to be taken when an instance of that rule is recognized. The action is described by a sequence of Ocaml statements.
Write a lexical analyzer to process input and pass tokens to the parser.</description>
    </item>
    
    <item>
      <title>Debugging your parser</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/debugging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/debugging/</guid>
      <description>To debug the parser generated by ocamlyacc:
Generate parsing infomation in the file grammar.output using -v option (like &amp;ldquo;ocamlyacc -v filneme.mly&amp;rdquo;): the information consists of the parsing table and a report on conflicts.
Set p option of the OCAMLRUNPARAM environment variable: for example, execute &amp;ldquo;export OCAMLRUNPARAM=&amp;lsquo;p&amp;rsquo; &amp;rdquo; on bash shell.
The parser prints messages about its actions such as shifting a token, reducing a rule.
You can find rule numbers and state numbers mentioned in the messages at the file grammar.</description>
    </item>
    
    <item>
      <title>Overall layout of grammar</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/overalllayout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/overalllayout/</guid>
      <description>The input file for the Ocamlyacc utility is a Ocamlyacc grammar file. The general form of a Ocamlyacc grammar file is as follows:
%{ Header (Ocaml code) %} Ocamlyacc declarations %% Grammar rules %% Trailer (Additional Ocaml code)
The %%, %{ and %} are punctuation that appears in every Ocamlyacc grammar file to separate the sections.
The header may define types, variables and functions used in the actions.
The Ocamlyacc declarations declare the names of the terminal and nonterminal symbols, and may also describe operator precedence and the data types of semantic values of various symbols.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ohama.github.io/ocaml/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/readme/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>