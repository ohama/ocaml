<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Documentation for Hugo Learn Theme</title>
    <link>https://ohama.github.io/ocaml/</link>
    <description>Recent content in Introduction on Documentation for Hugo Learn Theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    
	<atom:link href="https://ohama.github.io/ocaml/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>11.1 Keyword table</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/11.usagetips/11.1.keywordtable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/11.usagetips/11.1.keywordtable/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>12.1 Translate</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/12.examples/12.1.translate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/12.examples/12.1.translate/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>13.1 License in flex</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/13.license/13.1.license/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/13.license/13.1.license/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/01.intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/01.intro/</guid>
      <description>ocamllex is a tool for generating scanners: programs which recognized lexical patterns in text. ocamllex reads the given input files, for a description of a scanner to generate. The description is in the form of pairs of regular expressions and Ocaml code, called rules. ocamllex generates as output a Ocaml source file which defines lexical analyzer functions. This file is compiled and linked to produce an executable. When the executable is run, it analyzes its input for occurrences of the regular expressions.</description>
    </item>
    
    <item>
      <title>Position</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/06.actions/6.1.position/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/06.actions/6.1.position/</guid>
      <description>Since Ocaml 3.08  The position information on scanning the input text is recorded in the lexbuf which has a field lex_curr_p of the type position:
 type position = { pos_fname : string;	(* file name *) pos_lnum : int;	(* line number *) pos_bol : int;	(* the offset of the beginning of the line *) pos_cnum : int;	(* the offset of the position *) }  The value of pos_bol field is the number of characters between the beginning of the file and the beginning of the line while the value of pos_cnum field is the number of characters between the beginning of the file and the position.</description>
    </item>
    
    <item>
      <title>11.2 Nested comments</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/11.usagetips/11.2.nestedcomments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/11.usagetips/11.2.nestedcomments/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>12.2 Word count</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/12.examples/12.2.wordcount/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/12.examples/12.2.wordcount/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>13.2 Copyright and permission</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/13.license/13.2.ocamllexcopyright/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/13.license/13.2.ocamllexcopyright/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>Some simple examples</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/02.simpleexample/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/02.simpleexample/</guid>
      <description>First some simple examples to get the flavor of how one uses ocamllex. The following ocamllex input specifies a scanner which whenever it encounters the string &amp;ldquo;current_directory&amp;rdquo; will replace it with the current directory:
{ } rule translate = parse | &amp;quot;current_directory&amp;quot;	{ print_string (Sys.getcwd ()); translate lexbuf } | _ as c	{ print_char c; translate lexbuf } | eof	{ exit 0 }  In the first rule, &amp;ldquo;current_directory&amp;rdquo; is the pattern and the expression between braces is the action.</description>
    </item>
    
    <item>
      <title>12.3 Toy language</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/12.examples/12.3.toylanguage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/12.examples/12.3.toylanguage/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>Format of the input file</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/03.formatofinputfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/03.formatofinputfile/</guid>
      <description>The ocamllex input file consists of four sections; header, definitions, rules and trailer section:
(* header section *) { &amp;lt;header&amp;gt; } (* definitions section *) let &amp;lt;ident&amp;gt; = &amp;lt;regexp&amp;gt; let ...	(* rules section *) rule &amp;lt;entrypoint_1&amp;gt; [arg1... argn] = parse | &amp;lt;pattern&amp;gt; { &amp;lt;action&amp;gt; } | ... | &amp;lt;pattern&amp;gt; { &amp;lt;action&amp;gt; } and &amp;lt;entrypoint_2&amp;gt; [arg1... argn] = parse ... and ... (* trailer section *) { &amp;lt;trailer&amp;gt; }  Comments are delimited by (* and *), as in Caml.</description>
    </item>
    
    <item>
      <title>Patterns</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/04.patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/04.patterns/</guid>
      <description>The patterns in the input are written using regular expressions in the style of lex, with a more Caml-like syntax. These are:
 &amp;lsquo;c&amp;rsquo;: match the character &amp;lsquo;c&amp;rsquo;. The character constant is the same syntax as Objective Caml character. &amp;gt;_: (underscore) match any character. eof: match an end-of-file . &amp;ldquo;foo&amp;rdquo;: the literal string &amp;ldquo;foo&amp;rdquo;. The syntax is the same syntax as Objective Caml string constants. [&amp;lsquo;x&amp;rsquo; &amp;lsquo;y&amp;rsquo; &amp;lsquo;z&amp;rsquo;]: character set; in this case, the pattern matches either an &amp;lsquo;x&amp;rsquo;, a &amp;lsquo;y&amp;rsquo;, or a &amp;lsquo;z&amp;rsquo; .</description>
    </item>
    
    <item>
      <title>How the input is matched</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/05.howmatched/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/05.howmatched/</guid>
      <description>When the generated scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, it takes the one matching the most text (the &amp;ldquo;longest match&amp;rdquo; principle). If it finds two or more matches of the same length, the rule listed first in the ocamllex input file is chosen (the &amp;ldquo;first match&amp;rdquo; principle).
Once the match is determined, the text corresponding to the match (called the token) is made available in the form of a string.</description>
    </item>
    
    <item>
      <title>The generted scanner</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/07.generatedscanner/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/07.generatedscanner/</guid>
      <description>The output of ocamllex is the file lex.ml when it is invoked as ocamllex lex.mll. The generated file contains the scanning functions, a number of tables used by it for matching tokens, and a number of auxiliary routines. The scanning functions are declared as followings:
let &amp;lt;entrypoint&amp;gt; [arg1... argn] lexbuf = ... and ...  where the fuction entrypoint has n + 1 arguments. n arguments come from the definition of the rules secton.</description>
    </item>
    
    <item>
      <title>8. Start conditions</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/08.startcondition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/08.startcondition/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>9. Interfacing with ocamlyacc</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/09.interfacewithocamlyacc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/09.interfacewithocamlyacc/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>10. Options</title>
      <link>https://ohama.github.io/ocaml/ocamllex-tutorial/10.options/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex-tutorial/10.options/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ohama.github.io/ocaml/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/readme/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Languages</title>
      <link>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/languages/</guid>
      <description>Languages and Context-Free Grammars In order for Ocamlyacc to parse a language, it must be described by a context-free grammar. This means that you specify one or more syntactic groupings and give rules for constructing them from their parts. For example, in the C language, one kind of grouping is called an expression&#39;. One rule for making an expression might be,An expression can be made of a minus sign and another expression&#39;&#39;.</description>
    </item>
    
  </channel>
</rss>