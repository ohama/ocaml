[
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/intro/",
	"title": "Introduction",
	"tags": [],
	"description": "ocamllex is a tool for generating scanners: programs which recognized lexical patterns in text.",
	"content": "ocamllex is a tool for generating scanners: programs which recognized lexical patterns in text. ocamllex reads the given input files, for a description of a scanner to generate. The description is in the form of pairs of regular expressions and Ocaml code, called rules. ocamllex generates as output a Ocaml source file which defines lexical analyzer functions. This file is compiled and linked to produce an executable. When the executable is run, it analyzes its input for occurrences of the regular expressions. Whenever it finds one, it executes the corresponding Ocaml code.\nIf you execute the following command with the input file named lexer.mll\nocamllex lexer.mll you will get Caml code for a lexical analyzer in file lexer.ml\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/keywordtable/",
	"title": "Keyword table",
	"tags": [],
	"description": "",
	"content": "The number of status transitions generated by ocamllex are limited to at most 32767. If you use too many transitions, for example, too many keywords, ocamllex generates the following error message:\ncamllex: transition table overflow, automaton is too big It tells that your lexer definition is too complex. To make the generated automata small, you have to encode using keyword table:\n{ let keyword_table = Hashtbl.create 72 let _ = List.iter (fun (kwd, tok) -\u0026gt; Hashtbl.add keyword_table kwd tok) [ (\u0026#34;keyword1\u0026#34;, KEYWORD1); (\u0026#34;keyword2\u0026#34;, KEYWORD2); ... ] } rule token = parse | ... | [\u0026#39;A\u0026#39;-\u0026#39;Z\u0026#39; \u0026#39;a\u0026#39;-\u0026#39;z\u0026#39;] [\u0026#39;A\u0026#39;-\u0026#39;Z\u0026#39; \u0026#39;a\u0026#39;-\u0026#39;z\u0026#39; \u0026#39;0\u0026#39;-\u0026#39;9\u0026#39; \u0026#39;_\u0026#39;]* as id { try Hashtbl.find keyword_table id with Not_found -\u0026gt; IDENT id } | ... For a complete example, see Toy Language program.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/license/licenseinflex/",
	"title": "License in flex manual",
	"tags": [],
	"description": "Copyright (C) 1990 The Regents of the University of California. All rights reserved.",
	"content": "Copyright \u0026copy; 1990 The Regents of the University of California. All rights reserved.\nThis code is derived from software contributed to Berkeley by Vern Paxson.\nThe United States Government has rights in this work pursuant to contract no. DE-AC03-76SF00098 between the United States Department of Energy and the University of California.\nRedistribution and use in source and binary forms with or without modification are permitted provided that: (1) source distributions retain this entire copyright notice and comment, and (2) distributions including binaries display the following acknowledgement: \u0026ldquo;This product includes software developed by the University of California, Berkeley and its contributors\u0026rdquo; in the documentation or other materials provided with the distribution and in all advertising materials mentioning features or use of this software. Neither the name of the University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED \u0026ldquo;AS IS\u0026rdquo; AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/actions/position/",
	"title": "Position",
	"tags": [],
	"description": "",
	"content": " Since Ocaml 3.08\n The position information on scanning the input text is recorded in the lexbuf which has a field lex_curr_p of the type position:\ntype position = { pos_fname : string;\t(* file name *) pos_lnum : int;\t(* line number *) pos_bol : int;\t(* the offset of the beginning of the line *) pos_cnum : int;\t(* the offset of the position *) }  The value of pos_bol field is the number of characters between the beginning of the file and the beginning of the line while the value of pos_cnum field is the number of characters between the beginning of the file and the position.\nThe lexing engine manages only the pos_cnum field of lexbuf.lex_curr_p with the number of characters read from the start of lexbuf. So you are reponsible for the other fields to be accurate. Typically, whenever the lexer meets a newline character, the action contains a call to the following function:\nlet incr_linenum lexbuf = let pos = lexbuf.Lexing.lex_curr_p in lexbuf.Lexing.lex_curr_p \u0026amp;lt;- { pos with Lexing.pos_lnum = pos.Lexing.pos_lnum + 1; Lexing.pos_bol = pos.Lexing.pos_cnum; } ;;"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/examples/translate/",
	"title": "Translate",
	"tags": [],
	"description": "",
	"content": "This example translates the text \u0026ldquo;current_directory\u0026rdquo; to the current directory.\n{ } rule translate = parse | \u0026#34;current_directory\u0026#34;\t{ print_string (Sys.getcwd ()) } | _ as c\t{ print_char c } | eof\t{ exit 0 } { let main () = let lexbuf = Lexing.from_channel stdin in while true do translate lexbuf done let _ = Printexc.print main () }"
},
{
	"uri": "https://ohama.github.io/ocaml/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": "The project is hosted on GitHub where you can report issues, fork the project and submit pull requests.\n ocamllex tutorial  This is a tutorial on how to use ocamllex.\n ocamlyacc tutorial  This is a tutorial on how to use ocamlyacc.\n lablgtk2 tutorial  lablgtk2 tutorial\n lablgtk2 treeview tutorial  Under construction\n   \n "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/license/copyright/",
	"title": "Copyright and permission",
	"tags": [],
	"description": "Ocamllex Adaptation Copyright and Permissions Notice",
	"content": " Ocamllex Adaptation Copyright and Permissions Notice Copyright \u0026copy; 2004, 2019 SooHyoung Oh.\nPermission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.\nPermission is granted to copy and distribute modified versions of this document under the conditions for verbatim copying, provided that this copyright notice is included exactly as in the original, and that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.\nPermission is granted to copy and distribute translations of this document into another language, under the above conditions for modified versions.\nIf you are intending to incorporate this document into a published work, please contact the maintainer, and we will make an effort to ensure that you have the most up to date information available.\nThere is no guarantee that this document lives up to its intended purpose. This is simply provided as a free resource. As such, the authors and maintainers of the information provided within can not make any guarantee that the information is even accurate.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/nestedcomments/",
	"title": "Nested comments",
	"tags": [],
	"description": "",
	"content": "Some language such as Ocaml support nested comment. It can be implemented like this:\n{ } rule token = parse | \u0026#34;(*\u0026#34;\t{ print_endline \u0026#34;comments start\u0026#34;; comments 0 lexbuf } | [\u0026#39; \u0026#39; \u0026#39;\\t\u0026#39; \u0026#39;\\n\u0026#39;]\t{ token lexbuf } | [\u0026#39;a\u0026#39;-\u0026#39;z\u0026#39;]+ as word { Printf.printf \u0026#34;word: %s\\n\u0026#34; word; token lexbuf } | _ as c\t{ Printf.printf \u0026#34;char %c\\n\u0026#34; c; token lexbuf } | eof\t{ raise End_of_file } and comments level = parse | \u0026#34;*)\u0026#34;\t{ Printf.printf \u0026#34;comments (%d) end\\n\u0026#34; level; if level = 0 then token lexbuf else comments (level-1) lexbuf } | \u0026#34;(*\u0026#34;\t{ Printf.printf \u0026#34;comments (%d) start\\n\u0026#34; (level+1); comments (level+1) lexbuf } | _\t{ comments level lexbuf } | eof\t{ print_endline \u0026#34;comments are not closed\u0026#34;; raise End_of_file } When the scanner function meets comments start token \u0026ldquo;(\u0026rdquo; in evaluating token rule, it enters comments rule with level of 0. token rule is invoked again when all comments are closed. Comments nesting level is increased whenever there is comment start token \u0026ldquo;(\u0026rdquo; in the input text.\nIf the scanner function meets end of comments token \u0026ldquo;*)\u0026ldquo;, it tests the comments nesting level. When the nesting level is not zero, it decrements the level by one and continues to scan comments. It returns to token rule when all the comments are closed i.e., the nesting level is zero.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/simpleexample/",
	"title": "Some simple examples",
	"tags": [],
	"description": "First some simple examples to get the flavor of how one uses ocamllex. The following ocamllex input specifies a scanner which whenever it encounters the string &#34;current_directory&#34; will replace it with the current directory: ...",
	"content": "First some simple examples to get the flavor of how one uses ocamllex. The following ocamllex input specifies a scanner which whenever it encounters the string \u0026ldquo;current_directory\u0026rdquo; will replace it with the current directory:\n{ } rule translate = parse | \u0026#34;current_directory\u0026#34;\t{ print_string (Sys.getcwd ()); translate lexbuf } | _ as c\t{ print_char c; translate lexbuf } | eof\t{ exit 0 } In the first rule, \u0026ldquo;current_directory\u0026rdquo; is the pattern and the expression between braces is the action. By this rule, when the scanner matches the string \u0026ldquo;current_directory\u0026rdquo;, it executes the corresponding action which prints the current directory name and call the scanner again. Recursive calling itself is necessary to do the other job.\nAny text not matched by a ocamllex scanner generates exception Failure \u0026ldquo;lexing: empty token\u0026rdquo;, so you have to supply the last two rules. The second rule copies any character to its output which is not matched by the first rule, and it calls itself again. By the third rule, the program exits when it meets end of file. So the net effect of this scanner is to copy its input file to its output with each occurrence of \u0026ldquo;current_directory\u0026rdquo; expanded. The \u0026ldquo;{ }\u0026rdquo; in the first line delimits the header section from the rest.\nHere\u0026rsquo;s another simple example:\n{ let num_lines = ref 0 let num_chars = ref 0 } rule count = parse | \u0026#39;\\n\u0026#39; { incr num_lines; incr num_chars; count lexbuf } | _ { incr num_chars; count lexbuf } | eof { () } { let main () = let lexbuf = Lexing.from_channel stdin in count lexbuf; Printf.printf \u0026#34;# of lines = %d, # of chars = %d\\n\u0026#34; !num_lines !num_chars let _ = Printexc.print main () } This scanner counts the number of characters and the number of lines in its input (it produces no output other than the final report on the counts). The first header section declares two globals, \u0026ldquo;num_lines\u0026rdquo; and \u0026ldquo;num_chars\u0026rdquo;, which are accessible both inside scanner function count and in the trailer section which is the last part enclosed by braces. There are three rules, one which matches a newline (\u0026rdquo;\\n\u0026rdquo;) and increments both the line count and the character count, and one which matches any character other than a newline (indicated by the \u0026ldquo;_\u0026rdquo; regular expression). At the end of file, the scanner function count returns unit.\nA somewhat more complicated example:\n(* scanner for a toy language *) { open Printf } let digit = [\u0026#39;0\u0026#39;-\u0026#39;9\u0026#39;] let id = [\u0026#39;a\u0026#39;-\u0026#39;z\u0026#39;] [\u0026#39;a\u0026#39;-\u0026#39;z\u0026#39; \u0026#39;0\u0026#39;-\u0026#39;9\u0026#39;]* rule toy_lang = parse | digit+ as inum { printf \u0026#34;integer: %s (%d)\\n\u0026#34; inum (int_of_string inum); toy_lang lexbuf } | digit+ \u0026#39;.\u0026#39; digit* as fnum { printf \u0026#34;float: %s (%f)\\n\u0026#34; fnum (float_of_string fnum); toy_lang lexbuf } | \u0026#34;if\u0026#34; | \u0026#34;then\u0026#34; | \u0026#34;begin\u0026#34; | \u0026#34;end\u0026#34; | \u0026#34;let\u0026#34; | \u0026#34;in\u0026#34; | \u0026#34;function\u0026#34; as word { printf \u0026#34;keyword: %s\\n\u0026#34; word; toy_lang lexbuf } | id as text { printf \u0026#34;identifier: %s\\n\u0026#34; text; toy_lang lexbuf } | \u0026#39;+\u0026#39; | \u0026#39;-\u0026#39; | \u0026#39;*\u0026#39; | \u0026#39;/\u0026#39; as op { printf \u0026#34;operator: %c\\n\u0026#34; op; toy_lang lexbuf } | \u0026#39;{\u0026#39; [^ \u0026#39;\\n\u0026#39;]* \u0026#39;}\u0026#39;\t{ toy_lang lexbuf }\t(* eat up one-line comments *) | [\u0026#39; \u0026#39; \u0026#39;\\t\u0026#39; \u0026#39;\\n\u0026#39;]\t{ toy_lang lexbuf }\t(* eat up whitespace *) | _ as c { printf \u0026#34;Unrecognized character: %c\\n\u0026#34; c; toy_lang lexbuf } | eof\t{ } { let main () = let cin = if Array.length Sys.argv \u0026gt; 1 then open_in Sys.argv.(1) else stdin in let lexbuf = Lexing.from_channel cin in toy_lang lexbuf let _ = Printexc.print main () } This is the beginnings of a simple scanner for a language. It identifies different types of tokens and reports on what it has seen.\nThe details of this example will be explained in the following sections.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/examples/wordcount/",
	"title": "Word count",
	"tags": [],
	"description": "",
	"content": "This example shows the number of lines, words and characters of the given file if the filename is given, or of the standard input if no command arguments are given.\n{ } rule count lines words chars = parse | \u0026#39;\\n\u0026#39;\t{ count (lines+1) words (chars+1) lexbuf } | [^ \u0026#39; \u0026#39; \u0026#39;\\t\u0026#39; \u0026#39;\\n\u0026#39;]+ as word { count lines (words+1) (chars+ String.length word) lexbuf } | _\t{ count lines words (chars+1) lexbuf } | eof\t{ (lines, words, chars) } { let main () = let cin = if Array.length Sys.argv \u0026gt; 1 then open_in Sys.argv.(1) else stdin in let lexbuf = Lexing.from_channel cin in let (lines, words, chars) = count 0 0 0 lexbuf in Printf.printf \u0026#34;%d lines, %d words, %d chars\\n\u0026#34; lines words chars let _ = Printexc.print main () }"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/formatofinputfile/",
	"title": "Format of the input file",
	"tags": [],
	"description": "The ocamllex input file consists of four sections; header, definitions, rules and trailer section: ...",
	"content": "The ocamllex input file consists of four sections; header, definitions, rules and trailer section:\n(* header section *) { \u0026lt;header\u0026gt; } (* definitions section *) let \u0026lt;ident\u0026gt; = \u0026lt;regexp\u0026gt; let ...\t(* rules section *) rule \u0026lt;entrypoint_1\u0026gt; [arg1... argn] = parse | \u0026lt;pattern\u0026gt; { \u0026lt;action\u0026gt; } | ... | \u0026lt;pattern\u0026gt; { \u0026lt;action\u0026gt; } and \u0026lt;entrypoint_2\u0026gt; [arg1... argn] = parse ... and ... (* trailer section *) { \u0026lt;trailer\u0026gt; } Comments are delimited by (* and *), as in Caml.\nThe header and rules sections are necessary while definitions and trailer sections are optional.\nThe header and trailer sections are enclosed in curly braces and they contain arbitrary Caml code. At the beginning of the output file, the header text is copied as is while the trailer text is copied at the end of the output file. For example, you can code open directives and some auxiliary funtions in the header section.\nThe definitions section contains declarations of simple ident definitions to simplify the scanner specification. Ident definitions have the form:\nlet \u0026lt;ident\u0026gt; = \u0026lt;regexp\u0026gt; let ...\t The \u0026ldquo;ident\u0026rdquo; must be valid identifiers for Caml values (starting with a lowercase letter). For example,\nlet _digit_ = [\u0026#39;0\u0026#39;-\u0026#39;9\u0026#39;] let _id_ = [\u0026#39;a\u0026#39;-\u0026#39;z\u0026#39;][\u0026#39;a\u0026#39;-\u0026#39;z\u0026#39; \u0026#39;0\u0026#39;-\u0026#39;9\u0026#39;]* defines \u0026ldquo;digit\u0026rdquo; to be a regular expression which matches a single digit, and \u0026ldquo;id\u0026rdquo; to be a regular expression which matches a letter followed by zero-or-more letters-or-digits. A subsequent reference to\ndigit+ \u0026#34;.\u0026#34; digit* is identical to\n[\u0026#39;0\u0026#39;-\u0026#39;9\u0026#39;]+ \u0026#34;.\u0026#34; [\u0026#39;0\u0026#39;-\u0026#39;9\u0026#39;]* and matches one-or-more digits followed by a \u0026lsquo;.\u0026rsquo; followed by zero-or-more digits.\nThe rules section of the ocamllex input contains a series of entrypoints of the form:\nrule entrypoint [arg1... argn] = parse | \u0026lt;pattern\u0026gt; { \u0026lt;action\u0026gt; } | ... | \u0026lt;pattern\u0026gt; { \u0026lt;action\u0026gt; } and ... The first \u0026ldquo;|\u0026rdquo; (bar) after parse is optional.\nEach entrypoint consists of a series of pattern-action:\n| \u0026lt;pattern\u0026gt; { \u0026lt;action\u0026gt; } where the action must be enclosed in curly braces.\nSee below for a further description of patterns and actions.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/examples/toylanguage/",
	"title": "Toy language",
	"tags": [],
	"description": "",
	"content": "In this example, the scanner function toy_lang returns a value of token type, but the main function does nothing with it.\n{ open Printf let create_hashtable size init = let tbl = Hashtbl.create size in List.iter (fun (key, data) -\u0026gt; Hashtbl.add tbl key data) init; tbl type token = | IF | THEN | ELSE | BEGIN | END | FUNCTION | ID of string | OP of char | INT of int | FLOAT of float | CHAR of char let keyword_table = create_hashtable 8 [ (\u0026#34;if\u0026#34;, IF); (\u0026#34;then\u0026#34;, THEN); (\u0026#34;else\u0026#34;, ELSE); (\u0026#34;begin\u0026#34;, BEGIN); (\u0026#34;end\u0026#34;, END); (\u0026#34;function\u0026#34;, FUNCTION) ] } let digit = [\u0026#39;0\u0026#39;-\u0026#39;9\u0026#39;] let id = [\u0026#39;a\u0026#39;-\u0026#39;z\u0026#39; \u0026#39;A\u0026#39;-\u0026#39;Z\u0026#39;][\u0026#39;a\u0026#39;-\u0026#39;z\u0026#39; \u0026#39;0\u0026#39;-\u0026#39;9\u0026#39;]* rule toy_lang = parse | digit+ as inum { let num = int_of_string inum in printf \u0026#34;integer: %s (%d)\\n\u0026#34; inum num; INT num } | digit+ \u0026#39;.\u0026#39; digit* as fnum { let num = float_of_string fnum in printf \u0026#34;float: %s (%f)\\n\u0026#34; fnum num; FLOAT num } | id as word { try let token = Hashtbl.find keyword_table word in printf \u0026#34;keyword: %s\\n\u0026#34; word; token with Not_found -\u0026gt; printf \u0026#34;identifier: %s\\n\u0026#34; word; ID word } | \u0026#39;+\u0026#39; | \u0026#39;-\u0026#39; | \u0026#39;*\u0026#39; | \u0026#39;/\u0026#39; as op { printf \u0026#34;operator: %c\\n\u0026#34; op; OP op } | \u0026#39;{\u0026#39; [^ \u0026#39;\\n\u0026#39;]* \u0026#39;}\u0026#39;\t(* eat up one-line comments *) | [\u0026#39; \u0026#39; \u0026#39;\\t\u0026#39; \u0026#39;\\n\u0026#39;]\t(* eat up whitespace *) { toy_lang lexbuf } | _ as c { printf \u0026#34;Unrecognized character: %c\\n\u0026#34; c; CHAR c } | eof { raise End_of_file } { let rec parse lexbuf = let token = toy_lang lexbuf in (* do nothing in this example *) parse lexbuf let main () = let cin = if Array.length Sys.argv \u0026gt; 1 then open_in Sys.argv.(1) else stdin in let lexbuf = Lexing.from_channel cin in try parse lexbuf with End_of_file -\u0026gt; () let _ = Printexc.print main () }"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/patterns/",
	"title": "Patterns",
	"tags": [],
	"description": "The patterns in the input are written using regular expressions in the style of lex, with a more Caml-like syntax.",
	"content": "The patterns in the input are written using regular expressions in the style of lex, with a more Caml-like syntax. These are:\n 'c': match the character \u0026lsquo;c\u0026rsquo;. The character constant is the same syntax as Objective Caml character. _: (underscore) match any character. eof: match an end-of-file . \u0026quot;foo\u0026quot;: the literal string \u0026ldquo;foo\u0026rdquo;. The syntax is the same syntax as Objective Caml string constants. ['x' 'y' 'z']: character set; in this case, the pattern matches either an \u0026lsquo;x\u0026rsquo;, a \u0026lsquo;y\u0026rsquo;, or a \u0026lsquo;z\u0026rsquo; . ['a' 'b' 'j'-'o' 'Z']: character set with a range in it; ranges of characters \u0026lsquo;c1\u0026rsquo; - \u0026lsquo;c2\u0026rsquo; (all characters between c1 and c2, inclusive); in this case, the pattern matches an \u0026lsquo;a\u0026rsquo;, a \u0026lsquo;b\u0026rsquo;, any letter from \u0026lsquo;j\u0026rsquo; through \u0026lsquo;o\u0026rsquo;, or a \u0026lsquo;Z\u0026rsquo;. [^ 'A'-'Z']: a negated character set, i.e., any character but those in the class. In this case, any character EXCEPT an uppercase letter. [^ 'A'-'Z' '\\n']: any character EXCEPT an uppercase letter or a newline r*: zero or more r\u0026rsquo;s, where r is any regular expression r+: one or more r\u0026rsquo;s, where r is any regular expression r?: zero or one r\u0026rsquo;s, where r is any regular expression (that is, \u0026ldquo;an optional r\u0026rdquo;) ident: the expansion of the \u0026ldquo;ident\u0026rdquo; defined by an earlier let ident = regexp definition. (r): match an r; parentheses are used to override precedence (see below) rs: the regular expression r followed by the regular expression s; called \u0026ldquo;concatenation\u0026rdquo; r|s: either an r or an s r#s: match the difference of the two specified character sets. r as ident: bind the string matched by r to identifier ident  The regular expressions listed above are grouped according to precedence, from highest precedence at the top to lowest at the bottom; \u0026lsquo;*\u0026rsquo; and \u0026lsquo;+\u0026rsquo; have highest precedence, followed by \u0026lsquo;?\u0026rsquo;, \u0026lsquo;concatenation\u0026rsquo;, \u0026lsquo;|\u0026rsquo;, and then \u0026lsquo;as\u0026rsquo;. For example,\n\u0026#34;foo\u0026#34; | \u0026#34;bar\u0026#34;* is the same as\n(\u0026#34;foo\u0026#34;)|(\u0026#34;bar\u0026#34;*) since the \u0026lsquo;*\u0026rsquo; operator has higher precedence than than alternation (\u0026lsquo;|\u0026rsquo;). This pattern therefore matches either the string \u0026ldquo;foo\u0026rdquo; or zero-or-more of the string \u0026ldquo;bar\u0026rdquo;.\nTo match zero-or-more \u0026ldquo;foo\u0026rdquo;\u0026rsquo;s-or-\u0026ldquo;bar\u0026rdquo;\u0026rsquo;s:\n(\u0026#34;foo\u0026#34;|\u0026#34;bar\u0026#34;)* A negated character set such as the example \u0026ldquo;[^ \u0026lsquo;A\u0026rsquo;-\u0026lsquo;Z\u0026rsquo;]\u0026rdquo; above will match a newline unless \u0026ldquo;\\n\u0026rdquo; (or an equivalent escape sequence) is one of the characters explicitly present in the negated character set (e.g., \u0026ldquo;[^ \u0026lsquo;A\u0026rsquo;-\u0026lsquo;Z\u0026rsquo; \u0026lsquo;\\n\u0026rsquo;]\u0026ldquo;). This is unlike how many other regular expression tools treat negated character set, but unfortunately the inconsistency is historically entrenched. Matching newlines means that a pattern like [^\u0026ldquo;]* can match the entire input unless there\u0026rsquo;s another quote in the input.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/howmatched/",
	"title": "How the input is matched",
	"tags": [],
	"description": "When the generated scanner is run, it analyzes its input looking for strings which match any of its patterns.  If it finds more than one match, it takes the one matching the most text (the &#34;longest match&#34; principle).  If it finds two or more matches of the same length, the rule listed first in the ocamllex input file is chosen (the &#34;first match&#34; principle).",
	"content": "When the generated scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, it takes the one matching the most text (the \u0026ldquo;longest match\u0026rdquo; principle). If it finds two or more matches of the same length, the rule listed first in the ocamllex input file is chosen (the \u0026ldquo;first match\u0026rdquo; principle).\nOnce the match is determined, the text corresponding to the match (called the token) is made available in the form of a string. The action corresponding to the matched pattern is then executed (a more detailed description of actions follows), and then the remaining input is scanned for another match.\nIf no match is found, the scanner raises the Failure \u0026ldquo;lexing: empty token\u0026rdquo; exception.\nNow, let\u0026rsquo;s see the examples which shows how the patterns are applied.\nrule token = parse | \u0026#34;ding\u0026#34;\t{ print_endline \u0026#34;Ding\u0026#34; }\t(* \u0026#34;ding\u0026#34; pattern *) | [\u0026#39;a\u0026#39;-\u0026#39;z\u0026#39;]+ as word\t(* \u0026#34;word\u0026#34; pattern *) { print_endline (\u0026#34;Word: \u0026#34; ^ word) } ... When \u0026ldquo;ding\u0026rdquo; is given as an input, the ding and word pattern can be matched. ding pattern is selected because it comes before word pattern. So if you code like this:\nrule token = parse | [\u0026#39;a\u0026#39;-\u0026#39;z\u0026#39;]+ as word\t(* \u0026#34;word\u0026#34; pattern *) { print_endline (\u0026#34;Word: \u0026#34; ^ word) } | \u0026#34;ding\u0026#34;\t{ print_endline \u0026#34;Ding\u0026#34; }\t(* \u0026#34;ding\u0026#34; pattern *) | ... ding pattern will be useless.\nIn the following example, there are three patterns: ding, dong and dingdong.\nrule token = parse | \u0026#34;ding\u0026#34;\t{ print_endline \u0026#34;Ding\u0026#34; }\t(* \u0026#34;ding\u0026#34; pattern *) | \u0026#34;dong\u0026#34;\t{ print_endline \u0026#34;Dong\u0026#34; }\t(* \u0026#34;dong\u0026#34; pattern *) | \u0026#34;dingdong\u0026#34;\t{ print_endline \u0026#34;Ding-Dong\u0026#34; }\t(* \u0026#34;dingdong\u0026#34; pattern *) ... When \u0026ldquo;dingdong\u0026rdquo; is given as an input, there are two choices: ding + dong pattern or dingdong pattern. But by the \u0026ldquo;longest match\u0026rdquo; principle, dingdong pattern will be selected.\nThough the \u0026ldquo;shortest match\u0026rdquo; principle is not used so frequently, ocamllex supports it. If you want to select the shortest prefix of the input, use shortest keyword instead of the parse keyword. The \u0026ldquo;first match\u0026rdquo; principle holds still with the \u0026ldquo;shortest match\u0026rdquo; principle.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/actions/",
	"title": "Actions",
	"tags": [],
	"description": "Each pattern in a rule has a corresponding action, which can be any arbitrary Ocaml expression.",
	"content": "Each pattern in a rule has a corresponding action, which can be any arbitrary Ocaml expression. For example, here is the specification for a program which deletes all occurrences of \u0026ldquo;zap me\u0026rdquo; from its input:\n{} rule token = parse | \u0026#34;zap me\u0026#34;\t{ token lexbuf }\t(* ignore this token: no processing and continue *) | _ as c\t{ print_char c; token lexbuf } Here is a program which compresses multiple blanks and tabs down to a single blank, and throws away whitespace found at the end of a line:\n{} rule token = parse | [\u0026#39; \u0026#39; \u0026#39;\\t\u0026#39;]+\t{ print_char \u0026#39; \u0026#39;; token lexbuf } | [\u0026#39; \u0026#39; \u0026#39;\\t\u0026#39;]+ \u0026#39;\\n\u0026#39;\t{ token lexbuf } (* ignore this token *) Actions can include arbitrary Ocaml code which returns a value. Each time the lexical analyzer function is called it continues processing tokens from where it last left off until it either reaches the end of the file.\nActions are evaluated after the lexbuf is bound to the current lexer buffer and the identifer following the keyword as to the matched string. The usage of lexbuf is provided by the Lexing standard library module;\n Lexing.lexeme lexbuf: Return the matched string. Lexing.lexeme_char lexbuf n: Return the _n_th character in the matched string. The index number of the first character starts from 0.\n Lexing.lexeme_start lexbuf\n Lexing.lexeme_end lexbuf: Return the absolute position in the input text of the beginning/end of the matched string. The position of the first character is 0.\n Lexing.lexeme_start_p lexbuf\n Lexing.lexeme_end_p lexbuf: (Since Ocaml 3.08) Return the position of type _position (See Position).\n entrypoint [exp1\u0026hellip; expn] lexbuf: Call the other lexer on the given entry point. Notice that lexbuf is the last argument.\n  "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/generatedscanner/",
	"title": "The generted scanner",
	"tags": [],
	"description": "The output of ocamllex is the file lex.ml when it is invoked as `ocamllex lex.mll`.  The generated file contains the scanning functions, a number of tables used by it for matching tokens, and a number of auxiliary routines.",
	"content": "The output of ocamllex is the file lex.ml when it is invoked as ocamllex lex.mll. The generated file contains the scanning functions, a number of tables used by it for matching tokens, and a number of auxiliary routines. The scanning functions are declared as followings:\nlet \u0026lt;entrypoint\u0026gt; [arg1... argn] lexbuf = ... and ... where the fuction entrypoint has n + 1 arguments. n arguments come from the definition of the rules secton. And the resulting scanning function has one more argument named lexbuf of Lexing.lexbuf type as the last one.\nWhenever entrypoint is called, it scans tokens from the lexbuf argument. When it finds a match in patterns, it executes the corresponding action and returns. If you want to continue the lexical analyze after evaluating of the action, you must call the scanning function recursively.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/startcondition/",
	"title": "Start conditions",
	"tags": [],
	"description": "ocamllex provides a mechanism for conditionally activating rules. When you want do activate the other rule, just call the other entrypoint function.",
	"content": "ocamllex provides a mechanism for conditionally activating rules. When you want do activate the other rule, just call the other entrypoint function. For example, the following has two rules, one for finding tokens and one for skipping comments.\n{} rule token = parse | [\u0026#39; \u0026#39; \u0026#39;\\t\u0026#39; \u0026#39;\\n\u0026#39;]+ (* skip spaces *) { token lexbuf } | \u0026#34;(*\u0026#34; (* activate \u0026#34;comment\u0026#34; rule *) { comment lexbuf } ... and comment = parse | \u0026#34;*)\u0026#34; (* go to the \u0026#34;token\u0026#34; rule *) { token lexbuf } | _ (* skip comments *) { comment lexbuf } ... When the generated scanner meets comment start token \u0026ldquo;(\u0026rdquo; at the token rule, it activates the other rule comment. When it meets the end of comment token \u0026ldquo;)\u0026rdquo; at the comment rule. it returns to the scanning token rule.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/interfacewithocamlyacc/",
	"title": "Interfacing with ocamlyacc",
	"tags": [],
	"description": "One of the main uses of ocamllex is as a companion to the ocamlyacc parser-generator. ocamlyacc parsers call one of the scanning functions to find the next input token.",
	"content": "One of the main uses of ocamllex is as a companion to the ocamlyacc parser-generator. ocamlyacc parsers call one of the scanning functions to find the next input token. The routine is supposed to return the type of the next token with an associated value. To use ocamllex with ocamlyacc, scanner functions should use parser module to refer token types, which are defined in `%tokens\u0026rsquo; attributes appearing in the ocamlyacc input. For example, if input filename of ocamlyacc is parse.mly and one of the tokens is \u0026ldquo;NUMBER\u0026rdquo;, part of the scanner might look like:\n{ open Parse } rule token = parse ... | [\u0026#39;0\u0026#39;-\u0026#39;9\u0026#39;]+ as num { NUMBER (int_of_string num) } ..."
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/license/bisonlicense/",
	"title": "Bison license",
	"tags": [],
	"description": "Bison License",
	"content": " The bison manual requires \u0026ldquo;GNU General Public License\u0026rdquo; and \u0026ldquo;GNU Free Documentation License\u0026rdquo;.\nLicense of bison manual Copyright \u0026copy; 1988, 1989, 1990, 1991, 1992, 1993, 1995, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\nPermission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.\nPermission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided also that the sections entitled \u0026ldquo;GNU General Public License\u0026rdquo; and \u0026ldquo;Conditions for Using Bison\u0026rdquo; are included exactly as in the original, and provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.\nPermission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions, except that the sections entitled \u0026ldquo;GNU General Public License\u0026rdquo;, \u0026ldquo;Conditions for Using Bison\u0026rdquo; and this permission notice may be included in translations approved by the Free Software Foundation instead of in the original English.\nConditions for Using Bison As of Bison version 1.24, we have changed the distribution terms for yyparse to permit using Bison\u0026rsquo;s output in nonfree programs. Formerly, Bison parsers could be used only in programs that were free software.\nThe other GNU programming tools, such as the GNU C compiler, have never had such a requirement. They could always be used for nonfree software. The reason Bison was different was not due to a special policy decision; it resulted from applying the usual General Public License to all of the Bison source code.\nThe output of the Bison utility\u0026ndash;the Bison parser file\u0026ndash;contains a verbatim copy of a sizable piece of Bison, which is the code for the yyparse function. (The actions from your grammar are inserted into this function at one point, but the rest of the function is not changed.) When we applied the GPL terms to the code for yyparse, the effect was to restrict the use of Bison output to free software.\nWe didn\u0026rsquo;t change the terms because of sympathy for people who want to make software proprietary. Software should be free. But we concluded that limiting Bison\u0026rsquo;s use to free software was doing little to encourage people to make other software free. So we decided to make the practical conditions for using Bison match the practical conditions for using the other GNU tools.\nCopying This Manual GNU Free Documentation License: License for copying bison manual.\nGNU Free Documentation License Copyright \u0026copy; 2000 Free Software Foundation, Inc. 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA\nEveryone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.\nPREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document \u0026ldquo;free\u0026rdquo; in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.\nThis License is a kind of \u0026ldquo;copyleft\u0026rdquo;, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software.\nWe have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.\nAPPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The \u0026ldquo;Document\u0026rdquo;, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as \u0026ldquo;you\u0026rdquo;. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.\nA \u0026ldquo;Modified Version\u0026rdquo; of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.\nA \u0026ldquo;Secondary Section\u0026rdquo; is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document\u0026rsquo;s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.\nThe \u0026ldquo;Invariant Sections\u0026rdquo; are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none.\nThe \u0026ldquo;Cover Texts\u0026rdquo; are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.\nA \u0026ldquo;Transparent\u0026rdquo; copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not \u0026ldquo;Transparent\u0026rdquo; is called \u0026ldquo;Opaque\u0026rdquo;.\nExamples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only.\nThe \u0026ldquo;Title Page\u0026rdquo; means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, \u0026ldquo;Title Page\u0026rdquo; means the text near the most prominent appearance of the work\u0026rsquo;s title, preceding the beginning of the body of the text.\nA section \u0026ldquo;Entitled XYZ\u0026rdquo; means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as \u0026ldquo;Acknowledgements\u0026rdquo;, \u0026ldquo;Dedications\u0026rdquo;, \u0026ldquo;Endorsements\u0026rdquo;, or \u0026ldquo;History\u0026rdquo;.) To \u0026ldquo;Preserve the Title\u0026rdquo; of such a section when you modify the Document means that it remains a section \u0026ldquo;Entitled XYZ\u0026rdquo; according to this definition.\nThe Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.\nVERBATIM COPYING You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3.\nYou may also lend copies, under the same conditions stated above, and you may publicly display copies.\nCOPYING IN QUANTITY If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document\u0026rsquo;s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.\nIf the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.\nIf you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.\nIt is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.\nMODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:\nGNU FDL Modification Conditions\n Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.\n List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.\n State on the Title page the name of the publisher of the Modified Version, as the publisher.\n Preserve all the copyright notices of the Document.\n Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.\n Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.\n Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document\u0026rsquo;s license notice.\n Include an unaltered copy of this License.\n Preserve the section Entitled \u0026ldquo;History\u0026rdquo;, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled \u0026ldquo;History\u0026rdquo; in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.\n Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the \u0026ldquo;History\u0026rdquo; section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.\n For any section Entitled \u0026ldquo;Acknowledgements\u0026rdquo; or \u0026ldquo;Dedications\u0026rdquo;, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.\n Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.\n Delete any section Entitled \u0026ldquo;Endorsements\u0026rdquo;. Such a section may not be included in the Modified Version.\n Do not retitle any existing section to be Entitled \u0026ldquo;Endorsements\u0026rdquo; or to conflict in title with any Invariant Section.\n Preserve any Warranty Disclaimers.\n  If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version\u0026rsquo;s license notice. These titles must be distinct from any other section titles.\nYou may add a section Entitled \u0026ldquo;Endorsements\u0026rdquo;, provided it contains nothing but endorsements of your Modified Version by various parties\u0026ndash;for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.\nYou may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.\nThe author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.\nCOMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.\nThe combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.\nIn the combination, you must combine any sections Entitled \u0026ldquo;History\u0026rdquo; in the various original documents, forming one section Entitled \u0026ldquo;History\u0026rdquo;; likewise combine any sections Entitled \u0026ldquo;Acknowledgements\u0026rdquo;, and any sections Entitled \u0026ldquo;Dedications\u0026rdquo;. You must delete all sections Entitled \u0026ldquo;Endorsements\u0026rdquo;.\nCOLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.\nYou may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.\nAGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an \u0026ldquo;aggregate\u0026rdquo; if the copyright resulting from the compilation is not used to limit the legal rights of the compilation\u0026rsquo;s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.\nIf the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document\u0026rsquo;s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.\nTRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.\nIf a section in the Document is Entitled \u0026ldquo;Acknowledgements\u0026rdquo;, \u0026ldquo;Dedications\u0026rdquo;, or \u0026ldquo;History\u0026rdquo;, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.\nTERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided for under this License. Any other attempt to copy, modify, sublicense or distribute the Document is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.\nFUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/.\nEach version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License \u0026ldquo;or any later version\u0026rdquo; applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation.\nADDENDUM: How to use this License for your documents(#addendum) To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:\nSample Invariant Sections list\nCopyright \u0026copy; YEAR YOUR NAME. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled \u0026ldquo;GNU Free Documentation License\u0026rdquo;.\nIf you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the \u0026ldquo;with\u0026hellip;Texts.\u0026rdquo; line with this:\nSample Invariant Sections list\nwith the Invariant Sections being LIST THEIR TITLES, with the Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.\nIf you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.\nIf your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.\nGNU General Public License Version 2, June 1991\nCopyright \u0026copy; 1989, 1991 Free Software Foundation, Inc. 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA\nEveryone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.\nPreamble The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software - to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation\u0026rsquo;s software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.) You can apply it to your programs, too.\nWhen we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things.\nTo protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it.\nFor example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.\nWe protect your rights with two steps:\n copyright the software, and\n offer you this license which gives you legal permission to copy, distribute and/or modify the software.\n  Also, for each author\u0026rsquo;s protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors\u0026rsquo; reputations.\nFinally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone\u0026rsquo;s free use or not licensed at all.\nThe precise terms and conditions for copying, distribution and modification follow.\nTERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION Section 0 This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The \u0026ldquo;Program\u0026rdquo;, below, refers to any such program or work, and a \u0026ldquo;work based on the Program \u0026rdquo; means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term \u0026ldquo;modification \u0026ldquo;.) Each licensee is addressed as \u0026ldquo;you\u0026rdquo;.\nActivities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does.\nSection 1 You may copy and distribute verbatim copies of the Program\u0026rsquo;s source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program.\nYou may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.\nSection 2 You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:\n You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change.\n You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License.\n If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License.\n   Exception: If the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.)\n These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.\nThus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program.\nIn addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.\nSection 3 You may copy and distribute the Program (or a work based on it, under Section 2 in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:\n Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,\n Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,\n Accompany it with the information you received as to the offer to distribute corresponding source code. (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.)\n  The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.\nIf distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code.\nSection 4 You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.\nSection 5 You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it.\nSection 6 Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients\u0026rsquo; exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License.\nSection 7 If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program.\nIf any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances.\nIt is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.\nThis section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.\nSection 8 If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.\nSection 9 The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\nEach version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and \u0026ldquo;any later version\u0026rdquo;, you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.\nSection 10 If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.\nNO WARRANTY Section 11 BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u0026ldquo;AS IS\u0026rdquo; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\nSection 12 IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\nEND OF TERMS AND CONDITIONS\nHow to Apply These Terms to Your New Programs If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.\nTo do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the \u0026ldquo;copyright\u0026rdquo; line and a pointer to where the full notice is found.\n\u0026lt;one line to give the program's name and a brief idea of what it does.\u0026gt; Copyright (C) \u0026lt;year\u0026gt; \u0026lt;name of author\u0026gt;  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\nAlso add information on how to contact you by electronic and paper mail.\nIf the program is interactive, make it output a short notice like this when it starts in an interactive mode:\n Gnomovision version 69, Copyright (C) year name of author Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details.  The hypothetical commands \u0026lsquo;show w\u0026rsquo; and \u0026lsquo;show c\u0026rsquo; should show the appropriate parts of the General Public License. Of course, the commands you use may be called something other than \u0026lsquo;show w\u0026rsquo; and \u0026lsquo;show c\u0026rsquo;; they could even be mouse-clicks or menu items\u0026ndash;whatever suits your program.\nYou should also get your employer (if you work as a programmer) or your school, if any, to sign a \u0026ldquo;copyright disclaimer\u0026rdquo; for the program, if necessary. Here is a sample; alter the names:\nYoyodyne, Inc., hereby disclaims all copyright interest in the program 'Gnomovision' (which makes passes at compilers) written by James Hacker. \u0026lt;signature of Ty Coon\u0026gt;, 1 April 1989 Ty Coon, President of Vice  This General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Library General Public License instead of this License.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/adjustments/creatingadjustment/",
	"title": "Creating an adjustment",
	"tags": [],
	"description": "For many constructor or method arguments, default values are provided.",
	"content": "Many of the widgets which use adjustment objects do so automatically, but some cases will be shown in later examples where you may need to create one yourself. You create an adjustment using GData.adjustment:\nval GData.adjustment : ?value:float -\u0026gt; ?lower:float -\u0026gt; ?upper:float -\u0026gt; ?step_incr:float -\u0026gt; ?page_incr:float -\u0026gt; ?page_size:float -\u0026gt; unit -\u0026gt; adjustment lower : default value is 0. upper : default value is 100. step_incr : default value is 1. page_incr : default value is 10. page_size : default value is 10. The value argument is the initial value you want to give to the adjustment, usually corresponding to the topmost or leftmost position of an adjustable widget. The lower argument specifies the lowest value which the adjustment can hold. The step_increment argument specifies the \u0026ldquo;smaller\u0026rdquo; of the two increments by which the user can change the value, while the page_increment is the \u0026ldquo;larger\u0026rdquo; one. The page_size argument usually corresponds somehow to the visible area of a panning widget. The upper argument is used to represent the bottom most or right most coordinate in a panning widget\u0026rsquo;s child. Therefore it is not always the largest number that value can take, since the page_size of such widgets is usually non-zero.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/creatingwidgets/defaultarguments/",
	"title": "Default arguments",
	"tags": [],
	"description": "For many constructor or method arguments, default values are provided.",
	"content": "For many constructor or method arguments, default values are provided. Generally, this default value is defined by GTK, and you must refer to GTK\u0026rsquo;s documentation.\nFor ML defined defaults, usually default values are either false, 0, None or `NONE, according to the expected type.\nImportant exceptions are ~show, which default to true in all widgets except those in GWindow, and ~fill, which defaults to true or `BOTH.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/scribble/eventhandling/",
	"title": "Event handling",
	"tags": [],
	"description": "The GTK signals we have already discussed are for high-level actions, such as a menu item being selected. However, sometimes it is useful to learn about lower-level occurrences, such as the mouse being moved, or a key being pressed.",
	"content": "The GTK signals we have already discussed are for high-level actions, such as a menu item being selected. However, sometimes it is useful to learn about lower-level occurrences, such as the mouse being moved, or a key being pressed. There are also GTK signals corresponding to these low-level events. The handlers for these signals have an extra parameter which is a structure containing information about the event. For instance, motion event handlers are passed a GdkEvent.Motion structure which looks (in part) like: see GdkEvent.Motion\ntype t = [ `MOTION_NOTIFY ] Gdk.event val cast : GdkEvent.any -\u0026gt; t val time : [\u0026lt; GdkEvent.timed ] Gdk.event -\u0026gt; int32 val x : t -\u0026gt; float val y : t -\u0026gt; float val axes : t -\u0026gt; (float * float) option val state : t -\u0026gt; int val is_hint : t -\u0026gt; bool val device : t -\u0026gt; Gdk.device val x_root : t -\u0026gt; float val y_root : t -\u0026gt; float x and y give the coordinates of the event. state specifies the modifier state when the event occurred (that is, it specifies which modifier keys and mouse buttons were pressed). It can contain some of the following:\n`SHIFT `LOCK `CONTROL `MOD1 `MOD2 `MOD3 `MOD4 `MOD5 `BUTTON1 `BUTTON2 `BUTTON3 `BUTTON4 `BUTTON5 You can test the state whether it includes the given modifier or not, using one of the followings:\nval Gdk.Convert.test_modifier : Gdk.Tags.modifier -\u0026gt; int -\u0026gt; bool val Gdk.Convert.modifier : int -\u0026gt; Gdk.Tags.modifier list As for other signals, to determine what happens when an event occurs we call connect method. But we also need let GTK know which events we want to be notified about. To do this, we call the method:\nmethod event#add : Gdk.Tags.event_mask list -\u0026gt; unit The argument specifies the events we are interested in. It is the list of constants that specify different types of events. For future reference the Gdk.Tags.event_mask are:\ntype event_mask = [ `ALL_EVENTS | `BUTTON1_MOTION | `BUTTON2_MOTION | `BUTTON3_MOTION | `BUTTON_MOTION | `BUTTON_PRESS | `BUTTON_RELEASE | `ENTER_NOTIFY | `EXPOSURE | `FOCUS_CHANGE | `KEY_PRESS | `KEY_RELEASE | `LEAVE_NOTIFY | `POINTER_MOTION | `POINTER_MOTION_HINT | `PROPERTY_CHANGE | `PROXIMITY_IN | `PROXIMITY_OUT | `SCROLL | `STRUCTURE | `SUBSTRUCTURE | `VISIBILITY_NOTIFY ]  There are a few subtle points that have to be observed when calling event#add method. First, it must be called before the X window for a GTK widget is created. In practical terms, this means you should call it immediately after creating the widget. Second, the widget must have an associated X window. For efficiency, many widget types do not have their own window, but draw in their parent\u0026rsquo;s window. These widgets are:\nGtkAlignment GtkArrow GtkBin GtkBox GtkImage GtkItem GtkLabel GtkPixmap GtkScrolledWindow GtkSeparator GtkTable GtkAspectFrame GtkFrame GtkVBox GtkHBox GtkVSeparator GtkHSeparator To capture events for these widgets, you need to use an EventBox widget. See the section on the EventBox widget for details.\nFor our drawing program, we want to know when the mouse button is pressed and when the mouse is moved, so we specify `POINTER_MOTION and `BUTTON_PRESS. We also want to know when we need to redraw our window, so we specify `EXPOSURE. Although we want to be notified via a Configure event when our window size changes, we don\u0026rsquo;t have to specify the corresponding `STRUCTURE flag, because it is automatically specified for all windows.\nIt turns out, however, that there is a problem with just specifying `POINTER_MOTION. This will cause the server to add a new motion event to the event queue every time the user moves the mouse. Imagine that it takes us 0.1 seconds to handle a motion event, but the X server queues a new motion event every 0.05 seconds. We will soon get way behind the users drawing. If the user draws for 5 seconds, it will take us another 5 seconds to catch up after they release the mouse button! What we would like is to only get one motion event for each event we process. The way to do this is to specify `POINTER_MOTION_HINT.\nWhen we specify `POINTER_MOTION_HINT, the server sends us a motion event the first time the pointer moves after entering our window, or after a button press or release event. Subsequent motion events will be suppressed until we explicitly ask for the position of the pointer using the function:\nval Gdk.Window.get_pointer_location : Gdk.window -\u0026gt; int * int There is another method, misc#pointer method which has a simpler interface:\nmethod misc#pointer : int * int The code to set the events for our window then looks like:\ndrawing_area#event#connect#expose ~callback:expose; drawing_area#event#connect#configure ~callback:configure; drawing_area#event#connect#motion_notify ~callback:motion_notify; drawing_area#event#connect#button_press ~callback:button_pressed; drawing_area#event#add [`EXPOSURE; `LEAVE_NOTIFY; `BUTTON_PRESS; `POINTER_MOTION; `POINTER_MOTION_HINT]; We\u0026rsquo;ll save the \u0026ldquo;expose\u0026rdquo; and \u0026ldquo;configure\u0026rdquo; callbacks for later. The \u0026ldquo;motion_notify\u0026rdquo; and \u0026ldquo;button_pressed\u0026rdquo; callbacks are pretty simple:\nlet button_pressed area backing ev = if GdkEvent.Button.button ev = 1 then ( let x = int_of_float (GdkEvent.Button.x ev) in let y = int_of_float (GdkEvent.Button.y ev) in draw_brush area backing x y ); true let motion_notify area backing ev = let (x, y) = if GdkEvent.Motion.is_hint ev then area#misc#pointer else (int_of_float (GdkEvent.Motion.x ev), int_of_float (GdkEvent.Motion.y ev)) in let state = GdkEvent.Motion.state ev in if Gdk.Convert.test_modifier `BUTTON1 state then draw_brush area backing x y; true"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/eventbox/",
	"title": "EventBox",
	"tags": [],
	"description": "At first glance, the EventBox widget might appear to be totally useless.",
	"content": "Some GTK widgets don\u0026rsquo;t have associated X windows, so they just draw on their parents. Because of this, they cannot receive events and if they are incorrectly sized, they don\u0026rsquo;t clip so you can get messy overwriting, etc. If you require more from these widgets, the EventBox is for you.\nAt first glance, the EventBox widget might appear to be totally useless. It draws nothing on the screen and responds to no events. However, it does serve a function - it provides an X window for its child widget. This is important as many GTK widgets do not have an associated X window. Not having an X window saves memory and improves performance, but also has some drawbacks. A widget without an X window cannot receive events, and does not perform any clipping on its contents. Although the name EventBox emphasizes the event-handling function, the widget can also be used for clipping. (and more, see the example below).\nTo create a new EventBox widget, use GBin.event_box:\nval GBin.event_box : ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; event_box A child widget can then be added to this EventBox:\nmethod add : GObj.widget -\u0026gt; unit The following example demonstrates both uses of an EventBox - a label is created that is clipped to a small box, and set up so that a mouse-click on the label causes the program to exit. Resizing the window reveals varying amounts of the label.\n(* file: event_box.ml *) let main () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Event Box\u0026#34; ~border_width:10 () in (* Set a handler for destroy event that immediately exits GTK. *) window#connect#destroy ~callback:GMain.Main.quit; (* Create an EventBox and add it to our toplevel window *) let event_box = GBin.event_box ~packing:window#add () in (* Create a long label *) let label = GMisc.label ~text:\u0026#34;Click here to quit, quit, quit, quit, quit\u0026#34; ~packing:event_box#add () in (* Clip it short. *) label#misc#set_size_request ~width:110 ~height:20; (* And bind an action to it *) event_box#event#add [`BUTTON_PRESS]; event_box#event#connect#button_press ~callback:(fun ev -\u0026gt; exit 0; true); (* Yet one more thing you need an X window for ... *) event_box#misc#realize (); Gdk.Window.set_cursor event_box#misc#window (Gdk.Cursor.create `HAND1); window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/gtkrcfiles/functionforrcfiles/",
	"title": "Functions for rc files",
	"tags": [],
	"description": "When your application starts, it reads the default RC files.",
	"content": "When your application starts, it reads the default RC files. which are [SYSCONFDIR]/gtk-2.0/gtkrc and .gtkrc-2.0 in the users home directory. ([SYSCONFDIR] defaults to /usr/local/etc.) You can add default file:\nval GMain.Rc.add_default_file : string -\u0026gt; unit If you wish to have a special set of widgets that can take on a different style from others, or any other logical division of widgets, use a call to:\nmethod misc#set_name : string -\u0026gt; unit Passing your newly created widget as the first argument, and the name you wish to give it as the second. This will allow you to change the attributes of this widget by name through the rc file.\nIf we use a call something like this:\nlet button = GButton.button ~label:\u0026#34;Special Button\u0026#34; in button#misc#set_name \u0026#34;special button\u0026#34; Then this button is given the name \u0026ldquo;special button\u0026rdquo; and may be addressed by name in the rc file as \u0026ldquo;special button.GtkButton\u0026rdquo;. [\u0026lt;\u0026mdash; Verify ME!]\nThe example rc file below, sets the properties of the main window, and lets all children of that main window inherit the style described by the \u0026ldquo;main button\u0026rdquo; style. The code used in the application is:\nlet window = GWindow.window () in window#misc#set_name \u0026#34;main window\u0026#34; And then the style is defined in the rc file using:\nwidget \u0026#34;main window.*GtkButton*\u0026#34; style \u0026#34;main_button\u0026#34; Which sets all the Button widgets in the \u0026ldquo;main window\u0026rdquo; to the \u0026ldquo;main_buttons\u0026rdquo; style as defined in the rc file.\nAs you can see, this is a fairly powerful and flexible system. Use your imagination as to how best to take advantage of this.\n I have also found, by experimentation, that you have to call this function (GMain.Rc.add_default_file) very early in the program for it to have any effect at all. I have now placed by call right at the very start of the program, before all other code, as that is seemingly the only way to get Gtk to actually read my local resource file. - Rich.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/grammaroutline/",
	"title": "Grammar outline",
	"tags": [],
	"description": "A Ocamlyacc grammar file has four main sections, shown here with the appropriate delimiters:",
	"content": " A Ocamlyacc grammar file has four main sections, shown here with the appropriate delimiters:\n%{ Header - Ocaml declarations (Ocaml code) %} Ocamlyacc declarations %% Grammar rules %% Trailer - Additional Ocaml code (Ocaml code)  By default, comments are enclosed between /* and / (as in C) except in Ocaml code. So use / and / in the declarations and rules sections, ( and *) in header and trailer sections.\nThe Header Section The header section contains declarations of functions and variables that are used in the actions in the grammar rules. These are copied to the beginning of the parser file so that they precede the definition of the parser function. You can open the other module in this area. If you don\u0026rsquo;t need any Ocaml declarations, you may omit the %{ and %} delimiters that bracket this section.\nThe Ocamlyacc Declarations Section The ocamlyacc declarations section contains declarations that define terminal and nonterminal symbols, specify precedence, and so on. At least, there must be one %start and the corresponding %type directives. See Ocamlyacc declarations.\nThe Grammar Rules Section The grammar rules section contains one or more Ocamlyacc grammar rules, and nothing else. See Syntax of Grammar Rules.\nThere must always be at least one grammar rule, and the first %% (which precedes the grammar rules) may never be omitted even if it is the first thing in the file.\nThe Trailer Section The trailer section is copied verbatim to the end of the parser file, just as the header section is copied to the beginning. This is the most convenient place to put anything that you want to have in the parser file but which need not come before the definition of the parse function. See Parser Interface.\nIf the last section is empty, you may omit the %% that separates it from the grammar rules.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/helloworld/",
	"title": "Hello world in GTK",
	"tags": [],
	"description": "a program with a button widget.",
	"content": "Now for a program with a widget (a button). It\u0026rsquo;s the classic hello world a la GTK.\n(* file: hello.ml *) (* This is a callback function. *) let hello () = print_endline \u0026#34;Hello World\u0026#34;; flush stdout (* Another callback function. * If you return [false] in the \u0026#34;delete_event\u0026#34; signal handler, * GTK will emit the \u0026#34;destroy\u0026#34; signal. Returning [true] means * you don\u0026#39;t want the window to be destroyed. * This is useful for popping up \u0026#39;are you sure you want to quit?\u0026#39; * type dialogs. *) let delete_event ev = print_endline \u0026#34;Delete event occurred\u0026#34;; flush stdout; (* Change [true] to [false] and the main window will be destroyed with * a \u0026#34;delete event\u0026#34; *) true let destroy () = GMain.Main.quit () let main () = (* Create a new window and sets the border width of the window. *) let window = GWindow.window ~border_width:10 () in (* When the window is given the \u0026#34;delete_event\u0026#34; signal (this is given * by the window manager, usually by the \u0026#34;close\u0026#34; option, or on the * titlebar), we ask it to call the delete_event () function * as defined above. *) window#event#connect#delete ~callback:delete_event; (* Here we connect the \u0026#34;destroy\u0026#34; event to a signal handler. * This event occurs when we call window#destroy method * or if we return [false] in the \u0026#34;delete_event\u0026#34; callback. *) window#connect#destroy ~callback:destroy; (* Creates a new button with the label \u0026#34;Hello World\u0026#34;. * and packs the button into the window (a gtk container). *) let button = GButton.button ~label:\u0026#34;Hello World\u0026#34; ~packing:window#add () in (* When the button receives the \u0026#34;clicked\u0026#34; signal, it will call the * function hello(). The hello() function is defined above. *) button#connect#clicked ~callback:hello; (* This will cause the window to be destroyed by calling * window#destroy () when \u0026#34;clicked\u0026#34;. Again, the destroy * signal could come from here, or the window manager. *) button#connect#clicked ~callback:window#destroy; (* The final step is to display the window. *) window#show (); (* All GTK applications must have a GMain.Main.main (). Control ends here * and waits for an event to occur (like a key press or * mouse event). *) GMain.Main.main () let _ = main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "Introduction",
	"content": " GTK (GIMP Toolkit) is a library for creating graphical user interfaces. It is licensed using the LGPL license, so you can develop open software, free software, or even commercial non-free software using GTK without having to spend anything for licenses or royalties.\nIt\u0026rsquo;s called the GIMP toolkit because it was originally written for developing the GNU Image Manipulation Program (GIMP), but GTK has now been used in a large number of software projects, including the GNU Network Object Model Environment (GNOME) project. GTK is built on top of GDK (GIMP Drawing Kit) which is basically a wrapper around the low-level functions for accessing the underlying windowing functions (Xlib in the case of the X windows system), and gdk-pixbuf, a library for client-side image manipulation.\nThe primary authors of GTK are:\n Peter Mattis petm@xcf.berkeley.edu\n Spencer Kimball spencer@xcf.berkeley.edu\n Josh MacDonald jmacd@xcf.berkeley.edu\n  GTK is currently maintained by:\n Owen Taylor otaylor@redhat.com\n Tim Janik timj@gtk.org\n  GTK is essentially an object oriented application programmers interface (API). Although written completely in C, it is implemented using the idea of classes and callback functions (pointers to functions).\nThere is also a third component called GLib which contains a few replacements for some standard calls, as well as some additional functions for handling linked lists, etc. The replacement functions are used to increase GTK\u0026rsquo;s portability, as some of the functions implemented here are not available or are nonstandard on other Unixes such as g_strerror(). Some also contain enhancements to the libc versions, such as g_malloc() that has enhanced debugging utilities.\nIn version 2.0, GLib has picked up the type system which forms the foundation for GTK\u0026rsquo;s class hierarchy, the signal system which is used throughout GTK, a thread API which abstracts the different native thread APIs of the various platforms and a facility for loading modules.\nAs the last component, GTK uses the Pango library for internationalized text output.\nThe original tutorial describes the C interface to GTK. There are GTK bindings for many other languages including Ocaml, C++, Guile, Perl, Python, TOM, Ada95, Objective C, Free Pascal, Eiffel, Java and C#. If you intend to use another language\u0026rsquo;s bindings to GTK, look at that binding\u0026rsquo;s documentation first. In some cases that documentation may describe some important conventions (which you should know first) and then refer you back to the original tutorial. There are also some cross-platform APIs (such as wxWindows and V) which use GTK as one of their target platforms; again, consult their documentation first.\nIf you\u0026rsquo;re developing your GTK application in C++, a few extra notes are in order. There\u0026rsquo;s a C++ binding to GTK called GTK\u0026ndash;, which provides a more C++-like interface to GTK; you should probably look into this instead. If you don\u0026rsquo;t like that approach for whatever reason, there are two alternatives for using GTK. First, you can use only the C subset of C++ when interfacing with GTK and then use the C interface as described in the original tutorial. Second, you can use GTK and C++ together by declaring all callbacks as static functions in C++ classes, and again calling GTK using its C interface. If you choose this last approach, you can include as the callback\u0026rsquo;s data value a pointer to the object to be manipulated (the so-called \u0026ldquo;this\u0026rdquo; value). Selecting between these options is simply a matter of preference, since in all three approaches you get C++ and GTK. None of these approaches requires the use of a specialized preprocessor, so no matter what you choose you can use standard C++ with GTK.\nThe original tutorial is an attempt to document as much as possible of GTK, but it is by no means complete. The tutorial assumes a good understanding of C, and how to create C programs. It would be a great benefit for the reader to have previous X programming experience, but it shouldn\u0026rsquo;t be necessary. If you are learning GTK as your first widget set, please comment on how you found this tutorial, and what you had trouble with. There are also Ocaml, C++, Objective C, ADA, Guile and other language bindings available, but I don\u0026rsquo;t follow these.\nThe original document is a \u0026ldquo;work in progress\u0026rdquo;. Please look for updates on http://www.gtk.org/.\nI would very much like to hear of any problems you have learning GTK from the original document, and would appreciate input as to how it may be improved. Please see the section on Contributing for further information.\nGTK+ 2.0 in Ocaml Ocaml is a fantastic programming language which has the various modern features. Some of them are:\n Functional / Imperative features: It is a functional language, since the basic units of programs are functions. And it provides full imperative capabilities, including updatable arrays, imperative variables and records with mutable fields.\n Strongly-typed: It is a strongly-typed language; it means that the objects that you use belong to a set that has a name, called its type. In Caml, types are managed by the computer, the user has nothing to do about types (types are synthesized). And caml features \u0026ldquo;polymorphic typing\u0026rdquo;: some types may be left unspecified, standing for \u0026ldquo;any type\u0026rdquo;.\n Compiler / Interpreter: Caml provides an interpreter as well as compiler. An interactive top-level executes \u0026ldquo;read-eval-print\u0026rdquo; loop, that is convenient for both learning, or rapid testing and debugging of programs.\n Object oriented: Objective Caml features objects that give a fully fledged object oriented programming style in Caml programs.\n  LablGTK is an Objective Caml interface to gtk+. It comes in two flavors: LablGTK1 for gtk+-1.2 and LablGTK2 for gtk+-2.0 to gtk+-2.4.\nIt is still under development, but already fully functional. All widgets (but one) are available, with almost all their methods. The GLArea widget is also supported in combination with LablGL. LibGlade and GdkPixbuf support is also included for both versions. LablGTK2 adds support for gnomecanvas, librsvg and libpanel Many examples are provided.\nYou can use LablGTK in win32 systems as well as in the unix like system.\nNote Some chapters of the original document have been omitted in ocaml version:\n GLib Tips For Writing GTK Applications The chapters or sections with \u0026ldquo;(?)\u0026rdquo; at the end of the name is not translated part to ocaml language. It is waiting contributors.  The following chapters have only titles while the corresponding one in the C version tutorial has large contents:\n Writing Your Own Widgets GTK Signals  So, you have to read the original document to refer these chapters.\nThere are good example sources in lablgtk distribution and I borrowed some code from that.\n Some part of this document came from LablGTK README files.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "`Ocamlyacc` is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar.",
	"content": "Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.\nOcamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments. Anyone familiar with Yacc should be able to use Ocamlyacc with little trouble. You need to be fluent in Ocaml programming in order to use Ocamlyacc or to understand this manual.\nWe begin with tutorial chapters that explain the basic concepts of using Ocamlyacc and show three explained examples, each building on the last. If you don\u0026rsquo;t know Ocamlyacc or Yacc, start by reading these chapters. Reference chapters follow which describe specific aspects of Ocamlyacc in detail.\nSome explanation is not suitable for the earlier version than 3.08 of Ocaml (Ocamlyacc), in that case, there will be comments like \u0026ldquo;(Since Ocaml 3.08)\u0026rdquo;.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/labels/",
	"title": "Labels",
	"tags": [],
	"description": "Labels are used a lot in GTK, and are relatively simple.",
	"content": "Labels are used a lot in GTK, and are relatively simple. Labels emit no signals as they do not have an associated X window. If you need to catch signals, or do clipping, place it inside a EventBox widget or a Button widget.\nTo create a new label, use GMisc.label:\nval GMisc.label : ?text:string -\u0026gt; ?markup:string -\u0026gt; ?use_underline:bool -\u0026gt; ?mnemonic_widget:#GObj.widget -\u0026gt; ?justify:Gtk.Tags.justification -\u0026gt; ?line_wrap:bool -\u0026gt; ?pattern:string -\u0026gt; ?selectable:bool -\u0026gt; ?xalign:float -\u0026gt; ?yalign:float -\u0026gt; ?xpad:int -\u0026gt; ?ypad:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; label markup : overrides text if both are present use_underline : default value is false justify : default value is `LEFT line_wrap : default values is false selectable : default value is false To change the label\u0026rsquo;s text after creation, use the function GMisc.label#set_text:\nmethod set_text : string -\u0026gt; unit The space needed for the new string will be automatically adjusted if needed. You can produce multi-line labels by putting line breaks in the label string.\nTo retrieve the current string, use GMisc.label#text:\nmethod text : string The label text can be justified using GMisc.label#set_justify:\nmethod set_justify : Gtk.Tags.justification -\u0026gt; unit Values for Gtk.Tags.justification are:\n`LEFT `RIGHT `CENTER (the default) `FILL The label widget is also capable of line wrapping the text automatically. This can be activated using GMisc.label#set_line_wrap:\nmethod set_line_wrap : bool -\u0026gt; unit If you want your label underlined, then you can set a pattern on the label GMisc.label#set_pattern:\nmethod set_pattern : string -\u0026gt; unit The pattern argument indicates how the underlining should look. It consists of a string of underscore and space characters. An underscore indicates that the corresponding character in the label should be underlined. For example, the string \u0026ldquo;__ __\u0026rdquo; would underline the first two characters and eight and ninth characters.\nBelow is a short example to illustrate these functions. This example makes use of the Frame widget to better demonstrate the label styles. You can ignore this for now as the Frame widget is explained later on.\nIn GTK+ 2.0, label texts can contain markup for font and other text attribute changes, and labels may be selectable (for copy-and-paste). These advanced features won\u0026rsquo;t be explained here.\n(* file: label.ml *) let main () = let window = GWindow.window ~title:\u0026#34;Labels\u0026#34; ~border_width:5 () in window #connect#destroy ~callback:GMain.Main.quit; let hbox = GPack.hbox ~spacing:5 ~packing:window#add () in let vbox = GPack.vbox ~spacing:5 ~packing:hbox#add () in let frame = GBin.frame ~label:\u0026#34;Normal Label\u0026#34; ~packing:vbox#pack () in GMisc.label ~text:\u0026#34;This is a normal label\u0026#34; ~packing:frame#add (); let frame = GBin.frame ~label:\u0026#34;Multi_line Label\u0026#34; ~packing:vbox#pack () in GMisc.label ~text:\u0026#34;This is a multi-line label.\\nSecond line\\nThird line\u0026#34; ~packing:frame#add (); let frame = GBin.frame ~label:\u0026#34;Left Justified Label\u0026#34; ~packing:vbox#pack () in GMisc.label ~text:\u0026#34;This is a left justified\\nmulti_line label\\nThird line\u0026#34; ~justify:`LEFT ~packing:frame#add (); let frame = GBin.frame ~label:\u0026#34;Right Justified Label\u0026#34; ~packing:vbox#pack () in GMisc.label ~text:\u0026#34;This is a Right-Justified\\nMulti-line label.\\nThird line, (j/k)\u0026#34; ~justify:`RIGHT ~packing:frame#add (); let vbox = GPack.vbox ~spacing:5 ~packing:hbox#add () in let frame = GBin.frame ~label:\u0026#34;Line wrapped Label\u0026#34; ~packing:vbox#pack () in GMisc.label ~text:\u0026#34;This is an example of a line-wrapped label. It should not be taking up the entire width allocated to it, but automatically wraps the words to fit. The time has come, for all good men, to come to the aid of their party. The sixth sheik\u0026#39;s six sheep\u0026#39;s sick. It supports multiple paragraphs correctly, and correctly adds many extra spaces. \u0026#34; ~packing:frame#add ~line_wrap:true (); let frame = GBin.frame ~label:\u0026#34;Filled, wrapped label\u0026#34; ~packing:vbox#pack () in GMisc.label ~text:\u0026#34;This is an example of a line-wrapped, filled label. It should be taking up the entire width allocated to it. Here is a sentence to prove my point. Here is another sentence. Here comes the sun, do de do de do. This is a new paragraph. This is another newer, longer, better paragraph. It is coming to an end, unfortunately.\u0026#34; ~line_wrap:true ~justify:`FILL ~packing:frame#add (); let frame = GBin.frame ~label:\u0026#34;Underlined Label\u0026#34; ~packing:vbox#pack () in GMisc.label ~text:\u0026#34;This label is underlined!\\nThis one is underlined in quite a funky fashion\u0026#34; ~pattern:\u0026#34;_________________________ _ _________ _ ______ __ _______ ___\u0026#34; ~justify:`LEFT ~packing:frame#add (); window #show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/languagsandcfg/",
	"title": "Languages and context-free grammars",
	"tags": [],
	"description": "In order for Ocamlyacc to parse a language, it must be described by a context-free grammar.",
	"content": "In order for Ocamlyacc to parse a language, it must be described by a context-free grammar. This means that you specify one or more syntactic groupings and give rules for constructing them from their parts. For example, in the C language, one kind of grouping is called an \u0026lsquo;expression\u0026rsquo;. One rule for making an expression might be, \u0026ldquo;An expression can be made of a minus sign and another expression\u0026rdquo;. Another would be, \u0026ldquo;An expression can be an integer\u0026rdquo;. As you can see, rules are often recursive, but there must be at least one rule which leads out of the recursion.\nThe most common formal system for presenting such rules for humans to read is Backus-Naur Form or BNF, which was developed in order to specify the language Algol 60. Any grammar expressed in BNF is a context-free grammar. The input to Ocamlyacc is essentially machine-readable BNF.\nNot all context-free languages can be handled by Ocamlyacc, only those that are LALR(1). In brief, this means that it must be possible to tell how to parse any portion of an input string with just a single token of look-ahead. Strictly speaking, that is a description of an LR(1) grammar, and LALR(1) involves additional restrictions that are hard to explain simply; but it is rare in actual practice to find an LR(1) grammar that fails to be LALR(1). See Mysterious Reduce/Reduce Conflicts, for more information on this.\nIn the formal grammatical rules for a language, each kind of syntactic unit or grouping is named by a symbol. Those which are built by grouping smaller constructs according to grammatical rules are called nonterminal symbols; those which can\u0026rsquo;t be subdivided are called terminal symbols or token types. We call a piece of input corresponding to a single terminal symbol a \u0026ldquo;token\u0026rdquo;, and a piece corresponding to a single nonterminal symbol a grouping.\nWe can use the C language as an example of what symbols, terminal and nonterminal, mean. The tokens of C are identifiers, constants (numeric and string), and the various keywords, arithmetic operators and punctuation marks. So the terminal symbols of a grammar for C include \u0026lsquo;identifier\u0026rsquo;, \u0026lsquo;number\u0026rsquo;, \u0026lsquo;string\u0026rsquo;, plus one symbol for each keyword, operator or punctuation mark: \u0026lsquo;if\u0026rsquo;, \u0026lsquo;return\u0026rsquo;, \u0026lsquo;const\u0026rsquo;, \u0026lsquo;static\u0026rsquo;, \u0026lsquo;int\u0026rsquo;, \u0026lsquo;char\u0026rsquo;, \u0026lsquo;plus-sign\u0026rsquo;, \u0026lsquo;open-brace\u0026rsquo;, \u0026lsquo;close-brace\u0026rsquo;, \u0026lsquo;comma\u0026rsquo; and many more. (These tokens can be subdivided into characters, but that is a matter of lexicography, not grammar.)\nHere is a simple C function subdivided into tokens:\n\u0026rdquo;\u0026lsquo;C int /* keyword \u0026lsquo;int\u0026rsquo; / square (int x) / identifier, open-paren, identifier, identifier, close-paren / { / open-brace */ return x * x; /* keyword \u0026lsquo;return\u0026rsquo;, identifier, asterisk, identifier, semicolon / } / close-brace */ \u0026ldquo;\u0026rsquo;\nThe syntactic groupings of C include the expression, the statement, the declaration, and the function definition. These are represented in the grammar of C by nonterminal symbols \u0026lsquo;expression\u0026rsquo;, \u0026lsquo;statement\u0026rsquo;, \u0026lsquo;declaration\u0026rsquo; and \u0026lsquo;function definition\u0026rsquo;. The full grammar uses dozens of additional language constructs, each with its own nonterminal symbol, in order to express the meanings of these four. The example above is a function definition; it contains one declaration, and one statement. In the statement, each \u0026ldquo;x\u0026rdquo; is an expression and so is \u0026ldquo;x * x\u0026rdquo;.\nEach nonterminal symbol must have grammatical rules showing how it is made out of simpler constructs. For example, one kind of C statement is the \u0026ldquo;return\u0026rdquo; statement; this would be described with a grammar rule which reads informally as follows:\nA 'statement' can be made of a 'return' keyword, an 'expression' and a 'semicolon'.  There would be many other rules for \u0026lsquo;statement\u0026rsquo;, one for each kind of statement in C.\nOne nonterminal symbol must be distinguished as the special one which defines a complete utterance in the language. It is called the start symbol. In a compiler, this means a complete input program. In the C language, the nonterminal symbol \u0026lsquo;sequence of definitions and declarations\u0026rsquo; plays this role.\nFor example, \u0026ldquo;1 + 2\u0026rdquo; is a valid C expression\u0026mdash;a valid part of a C program\u0026mdash;but it is not valid as an entire C program. In the context-free grammar of C, this follows from the fact that \u0026lsquo;expression\u0026rsquo; is not the start symbol.\nThe Ocamlyacc parser reads a sequence of tokens as its input, and groups the tokens using the grammar rules. If the input is valid, the end result is that the entire token sequence reduces to a single grouping whose symbol is the grammar\u0026rsquo;s start symbol. If we use a grammar for C, the entire input must be a \u0026lsquo;sequence of definitions and declarations\u0026rsquo;. If not, the parser reports a syntax error.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/lookaheadtokens/",
	"title": "Lookahead Tokens",
	"tags": [],
	"description": "The Ocamlyacc parser does not always reduce immediately as soon as the last n tokens and groupings match a rule.",
	"content": "The Ocamlyacc parser does not always reduce immediately as soon as the last n tokens and groupings match a rule. This is because such a simple strategy is inadequate to handle most languages. Instead, when a reduction is possible, the parser sometimes \u0026ldquo;looks ahead\u0026rdquo; at the next token in order to decide what to do.\nWhen a token is read, it is not immediately shifted; first it becomes the look-ahead token, which is not on the stack. Now the parser can perform one or more reductions of tokens and groupings on the stack, while the look-ahead token remains off to the side. When no more reductions should take place, the look-ahead token is shifted onto the stack. This does not mean that all possible reductions have been done; depending on the token type of the look-ahead token, some rules may choose to delay their application.\nHere is a simple case where look-ahead is needed. These three rules define expressions which contain binary addition operators and postfix unary factorial operators (FACTORIAL for \u0026lsquo;!\u0026rsquo;), and allow parentheses for grouping.\nexpr: term PLUS expr | term ; term: LPAREN expr RPAREN | term FACTORIAL | NUMBER ;  Suppose that the tokens 1 + 2 have been read and shifted; what should be done? If the following token is RPAREN, then the first three tokens must be reduced to form an expr. This is the only valid course, because shifting the RPAREN would produce a sequence of symbols term RPAREN, and no rule allows this.\nIf the following token is FACTORIAL, that is \u0026lsquo;!\u0026rsquo;, then it must be shifted immediately so that 2 ! can be reduced to make a term. If instead the parser were to reduce before shifting, 1 + 2 would become an expr. It would then be impossible to shift the ! because doing so would produce on the stack the sequence of symbols expr FACTORIAL. No rule allows that sequence.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/menuwidgets/manualmenucreation/",
	"title": "Manual menu createion",
	"tags": [],
	"description": "At first glance, the EventBox widget might appear to be totally useless.",
	"content": "In the true tradition of teaching, we\u0026rsquo;ll show you the hard way first. :)\nThere are three widgets that go into making a menubar and submenus:\n a menu item, which is what the user wants to select, e.g., \u0026ldquo;Save\u0026rdquo;\n a menu, which acts as a container for the menu items, and\n a menubar, which is a container for each of the individual menus.\n  This is slightly complicated by the fact that menu item widgets are used for two different things. They are both the widgets that are packed into the menu, and the widget that is packed into the menubar, which, when selected, activates the menu.\nLet\u0026rsquo;s look at the functions that are used to create menus and menubars. This first function GMenu.menu_bar is used to create a new menubar.\nGMenu.menu_bar : ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; menu_shell This rather self explanatory function creates a new menubar. You use gtk_container_add() to pack this into a window, or the box_pack functions to pack it into a box - the same as buttons: GMenu.menu.\nGMenu.menu : ?accel_path:string -\u0026gt; ?border_width:int -\u0026gt; ?packing:(menu -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; menu This function returns a new menu; it is never actually shown, it is just a container for the menu items. I hope this will become more clear when you look at the example below.\nThe next call GMenu.menu_item is used to create menu item that is packed into the menu (and menubar).\nGMenu.menu_item : ?use_mnemonic:bool -\u0026gt; ?label:string -\u0026gt; ?right_justified:bool -\u0026gt; ?packing:(menu_item -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; menu_item This call is used to create a menu item that is to be displayed. Remember to differentiate between a \u0026ldquo;menu\u0026rdquo; as created with GMenu.menu () and a \u0026ldquo;menu item\u0026rdquo; as created by the GMenu.menu_item () functions. The menu item will be an actual button with an associated action, whereas a menu will be a container holding menu items.\nThe ~label option of GMenu.menu_item creates a new menu item with a label already packed into it.\nOnce you\u0026rsquo;ve created a menu item you have to put it into a menu. This is done using the function GMenu.menu#append. In order to capture when the item is selected by the user, we need to connect to the activate signal in the usual way. So, if we wanted to create a standard File menu, with the options Open, Save, and Quit, the code would look something like:\nlet create_menu () = let file_menu = GMenu.menu () in let item = GMenu.menu_item ~label:\u0026#34;Open\u0026#34; ~packing:file_menu#append () in item#connect#activate ~callback:(uprint \u0026#34;Open\u0026#34;); let item = GMenu.menu_item ~label:\u0026#34;Save\u0026#34; ~packing:file_menu#append () in item#connect#activate ~callback:(uprint \u0026#34;Save\u0026#34;); let item = GMenu.menu_item ~label:\u0026#34;Quit\u0026#34; ~packing:file_menu#append () in item#connect#activate ~callback:GMain.Main.quit; file_menu At this point we have our menu. Now we need to create a menubar and a menu item for the File entry, to which we add our menu. The code looks like this:\nlet file_menu = create_menu () in let menu_bar = GMenu.menu_bar ~packing:window#add () in let file_item = GMenu.menu_item ~label:\u0026#34;File\u0026#34; () in Now we need to associate the menu with file_item. This is done with the function\nGMenu.menu_item#set_submenu : menu -\u0026gt; unit So, our example would continue with\nfile_item#set_submenu file_menu; All that is left to do is to add the menu to the menubar, which is accomplished using the function\nGMenu.menu_shell#append : GMenu.menu_item -\u0026gt; unit which in our case looks like this:\nmenu_bar#append file_item; The complete code looks like this:\nlet uprint msg () = print_endline msg; flush stdout let create_menu () = let file_menu = GMenu.menu () in let item = GMenu.menu_item ~label:\u0026#34;Open\u0026#34; ~packing:file_menu#append () in item#connect#activate ~callback:(uprint \u0026#34;Open\u0026#34;); let item = GMenu.menu_item ~label:\u0026#34;Save\u0026#34; ~packing:file_menu#append () in item#connect#activate ~callback:(uprint \u0026#34;Save\u0026#34;); let item = GMenu.menu_item ~label:\u0026#34;Quit\u0026#34; ~packing:file_menu#append () in item#connect#activate ~callback:GMain.Main.quit; file_menu let main () = let window = GWindow.window () in window#connect#destroy ~callback:GMain.Main.quit; let file_menu = create_menu () in let menu_bar = GMenu.menu_bar ~packing:window#add () in let file_item = GMenu.menu_item ~label:\u0026#34;File\u0026#34; () in file_item#set_submenu file_menu; menu_bar#append file_item; window#show (); GMain.Main.main () let _ = main () The more compact code looks like this:\nlet uprint msg () = print_endline msg; flush stdout let create_menu ~packing () = let file_menu = GMenu.menu ~packing () in let item = GMenu.menu_item ~label:\u0026#34;Open\u0026#34; ~packing:file_menu#append () in item#connect#activate ~callback:(uprint \u0026#34;Open\u0026#34;); let item = GMenu.menu_item ~label:\u0026#34;Save\u0026#34; ~packing:file_menu#append () in item#connect#activate ~callback:(uprint \u0026#34;Save\u0026#34;); let item = GMenu.menu_item ~label:\u0026#34;Quit\u0026#34; ~packing:file_menu#append () in item#connect#activate ~callback:GMain.Main.quit let main () = let window = GWindow.window () in window#connect#destroy ~callback:GMain.Main.quit; let menu_bar = GMenu.menu_bar ~packing:window#add () in let file_item = GMenu.menu_item ~label:\u0026#34;File\u0026#34; ~packing:menu_bar#append () in create_menu ~packing:file_item#set_submenu (); window#show (); GMain.Main.main () let _ = main () If we wanted the menu right justified on the menubar, such as help menus often are, we can use the ~right_justify option (again on file_item in the current example) on menu_item createion.\nlet item = GMenu.menu_item ~right_justify:true () in ... Here is a summary of the top down steps needed to create a menu bar with menus attached:\n Create a new menubar using GMenu.menu_bar (). This step only needs to be done once when creating a series of menus on one menu bar.\n Create a menu item using GMenu.menu_item (). This will be the root of the menu, the text appearing here will be on the menubar itself.\n Use GMenu.menu_bar#append method to put the root menu item onto the menubar.\n Create a new menu using GMenu.menu ()\n Use GMenu.menu_item#set_submenu method to attach the menu to the root menu item (the one created in the above step).\n Use multiple calls to GMenu.menu_item () for each item you wish to have on your menu. And use GMenu.menu#append method to put each of these new items on to the menu.\n  Creating a popup menu is nearly the same. The difference is that the menu is not posted \u0026ldquo;automatically\u0026rdquo; by a menubar, but explicitly by calling the function GMenu.menu#popup method from a button-press event, for example. Take these steps:\n Create an event handling function. It needs to have the prototype  let button_pressed ev = ... But for poping up menu, you may give one more argument for the event handling function like this:\nlet button_pressed menu ev = ... menu#popup ~button ~time:(GdkEvent.Button.time ev); ... and it will use the event to find out where to pop up the menu.\n In the event handler, if the event is a mouse button press, treat event as a button event (which it is) and use it as shown in the sample code to pass information to GMenu.menu#popup method.\n Bind that event handler to a widget with\n  widget#event#connect#button_press ~callback:(button_pressed menu); where widget is the widget you are binding to, handler is the handling function, and menu is a menu created with GMenu.menu (). This can be a menu which is also posted by a menu bar, as shown in the sample code.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/movingon/moreonsignalhandlers/",
	"title": "More on signal handlers",
	"tags": [],
	"description": "Lets take another look at the #connect#signal_name declaration.",
	"content": "Lets take another look at the #connect#signal_name declaration.\n#connect#signal_name ~callback:(unit -\u0026gt; unit) -\u0026gt; GtkSignal.id Notice the GtkSignal.id return value? This is a tag that identifies your callback function. As stated above, you may have as many callbacks per signal and per object as you need, and each will be executed in turn, in the order they were attached.\nThis tag allows you to remove this callback from the list by using #misc#disconnect method:\n#misc#disconnect: GtkSignal.id -\u0026gt; unit So, by passing the tag returned by one of the connect functions to the #misc#disconnect method, you can disconnect a signal handler.\nYou can also temporarily disable signal handlers with the #misc#handler_block and #misc#handler_unblock family of functions.\n#misc#handler_block : GtkSignal.id -\u0026gt; unit #misc#handler_unblock : GtkSignal.id -\u0026gt; unit"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/buttonwidget/normalbuttons/",
	"title": "Normal buttons",
	"tags": [],
	"description": "For many constructor or method arguments, default values are provided.",
	"content": "We\u0026rsquo;ve almost seen all there is to see of the button widget. It\u0026rsquo;s pretty simple. There is however more than one way to create a button. You can use the GButton.button function with ~label or ~mnemonic option to create a button with a label, use ~stock option to create a button containing the image and text from a stock item or use it without these options to create a blank button. It\u0026rsquo;s then up to you to pack a label or pixmap into this new button. To do this, create a new box which is packed into button using #add method, and then pack your objects into this box using the usual #pack method.\nHere\u0026rsquo;s an example of using GButton.button to create a button with a image and a label in it. I\u0026rsquo;ve broken up the code to create a box from the rest so you can use it in your programs. There are further examples of using images later in the tutorial.\n(* file: button.ml *) open GMain (* Create a new hbox with an image and a label packed into it * and pack the box *) let xpm_label_box ~file ~text ~packing () = if not (Sys.file_exists file) then failwith (file ^ \u0026#34; does not exist\u0026#34;); (* Create box for image and label and pack *) let box = GPack.hbox ~border_width:2 ~packing () in (* Now on to the image stuff and pack into box *) let pixmap = GDraw.pixmap_from_xpm ~file () in GMisc.pixmap pixmap ~packing:(box#pack ~padding:3) (); (* Create a label for the button and pack into box *) GMisc.label ~text ~packing:(box#pack ~padding:3) () let main () = (* Create a new window; set title and border_width *) let window = GWindow.window ~title:\u0026#34;Pixmap\u0026#39;d Buttons!\u0026#34; ~border_width:10 () in (* It\u0026#39;s a good idea to do this for all windows. *) window#connect#destroy ~callback:Main.quit; window#event#connect#delete ~callback:(fun _ -\u0026gt; Main.quit (); true); (* Create a new button and pack *) let button = GButton.button ~packing:window#add () in (* Connect the \u0026#34;clicked\u0026#34; signal of the button to callback *) button#connect#clicked ~callback: (fun () -\u0026gt; print_endline \u0026#34;Hello again - cool button was pressed\u0026#34;); (* Create box with xpm and label and pack into button *) xpm_label_box ~file:\u0026#34;info.xpm\u0026#34; ~text:\u0026#34;cool button\u0026#34; ~packing:button#add (); (* Show the window and wait for the fun to begin! *) window#show (); Main.main () let _ = main () The xpm_label_box() function could be used to pack images and labels into any widget that can be a container.\nThe Button widget has the following signals; see GButton.button_signals:\n pressed - emitted when pointer button is pressed within Button widget released - emitted when pointer button is released within Button widget clicked - emitted when pointer button is pressed and then released within Button widget enter - emitted when pointer enters Button widget leave - emitted when pointer leaves Button widget  "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/options/",
	"title": "Options",
	"tags": [],
	"description": "ocamllex has the following options: ...",
	"content": "ocamllex has the following options:\n \u0026rdquo;-o output-file\u0026rdquo;  \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; By default, ocamllex produces lexer.ml, when ocamllex is invoked as \u0026ldquo;ocamllex lexer.mll\u0026rdquo;. You can change the name of the output file using -o option.\n \u0026rdquo;-ml\u0026rdquo;  \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; By default, ocamllex produces code that uses the Caml built-in automata interpreter. Using this option, the automaton is coded as Caml functions. This option is useful for debugging ocamllex, but it\u0026rsquo;s not recommended for production lexers.\n \u0026rdquo;-q\u0026rdquo;  \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; By default, ocamllex outputs informational messages to standard output. If you use -q option, they are suppressed.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/invokingocamlyacc/options/",
	"title": "Options",
	"tags": [],
	"description": "Ocamlyacc options",
	"content": "Here is a list of options that can be used with Ocamlyacc:\n -v: By default, this option generates a file grammar.output. It contains parsing infomation such as a description of the parsing tables and a report on ambiguities in the grammar.\n -bfname: Change the name of the output files to fname.ml, fname.mli and fname.output.\n  "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parserinterface/parserfunctions/",
	"title": "Parser Functions",
	"tags": [],
	"description": "To cause parsing to occur, you call the parser function with two parameters.",
	"content": "To cause parsing to occur, you call the parser function with two parameters. The first parameter is the lexical analyzer function of type\nLexing.lexbuf -\u0026gt; token  and the second is a value of Lexing.lexbuf type.\nIf the start symbol is parse in the file parser.mly and the lexer function is is token of the file lexer.mll, the typical usage is:\nlet lexbuf = Lexing.from_channel stdin in ... let result = Parser.parse Lexer.token lexbuf in ...  This parser function reads tokens, executes actions, and ultimately returns when it encounters end-of-input or an unrecoverable syntax error.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/reverspolishcalculator/",
	"title": "Reverse Polish Notation Calculator",
	"tags": [],
	"description": "Reverse Polish Notation Calculator: rpcalc",
	"content": " The first example is that of a simple double-precision reverse polish notation calculator (a calculator using postfix operators). This example provides a good starting point, since operator precedence is not an issue. The second example will illustrate how operator precedence is handled.\nThe source code for this calculator is named rpcalc.mly. The .mly extension is a convention used for Ocamlyacc input files.\nDeclarations for \u0026ldquo;rpcalc\u0026rdquo; Here are the Ocaml and Ocamlyacc declarations for the reverse polish notation calculator. By default, comments are enclosed between /* and */ (as in C) except in Ocaml code.\n/* file: rpcalc.mly */ /* Reverse polish notation calculator. */ %{ open Printf %} %token \u0026lt;float\u0026gt; NUM %token PLUS MINUS MULTIPLY DIVIDE CARET UMINUS %token NEWLINE %start input %type \u0026lt;unit\u0026gt; input %% /* Grammar rules and actions follow */  The header section (see The Header Section) has a code of openning \u0026ldquo;Printf\u0026rdquo; module.\nThe second section, Ocamlyacc declarations, provides information to Ocamlyacc about the token types (see The Ocamlyacc Declarations Section). Each terminal must be declared here. The first terminal symbol is the token type for numeric constants which has a value of float The possible arithmetic operators are PLUS, MINUS, MULTIPLY, DIVIDE, CARET for exponetiation and UMINUS for unary minus. These operator terminals don\u0026rsquo;t have any value with it. The last terminal is NEWLINE, a token type for the newline character.\nYou must give the names of the start symbols and their types, too. In this examples, there is one start symbol named input which has type of unit. For each start symbol, the parser function with the same name is generated.\nGrammar Rules for rpcalc Here are the grammar rules for the reverse polish notation calculator.\ninput: /* empty */\t{ } | input line\t{ } ; line: NEWLINE\t{ } | exp NEWLINE\t{ printf \u0026quot;\\t%.10g\\n\u0026quot; $1; flush stdout } ; exp: NUM\t{ $1 } | exp exp PLUS\t{ $1 +. $2 } | exp exp MINUS\t{ $1 -. $2 } | exp exp MULTIPLY\t{ $1 *. $2 } | exp exp DIVIDE\t{ $1 /. $2 } /* Exponentiation */ | exp exp CARET\t{ $1 ** $2 } /* Unary minus */ | exp UMINUS\t{ -. $1 } ; %%  The groupings of the rpcalc \u0026ldquo;language\u0026rdquo; defined here are the expression (given the name exp), the line of input (line), and the complete input transcript (input). Each of these nonterminal symbols has several alternate rules, joined by the | punctuator which is read as \u0026ldquo;or\u0026rdquo;. The following sections explain what these rules mean.\nThe semantics of the language is determined by the actions taken when a grouping is recognized. The actions are the Ocaml code that appears inside braces. See Actions.\nYou must specify these actions in Ocaml, but Ocamlyacc provides the means for passing semantic values between the rules. In each action, the semantic value for the grouping that the rule is going to construct should be given. The semantic values of the components of the rule are referred to as $1, $2, and so on.\nExplanation of input Consider the definition of input:\ninput: /* empty */ | input line ;  This definition reads as follows: \u0026ldquo;A complete input is either an empty string, or a complete input followed by an input line\u0026rdquo;. Notice that \u0026ldquo;complete input\u0026rdquo; is defined in terms of itself. This definition is said to be left recursive since input appears always as the leftmost symbol in the sequence. See Recursive Rules.\nThe first alternative is empty because there are no symbols between the colon and the first |; this means that input can match an empty string of input (no tokens). We write the rules this way because it is legitimate to type Ctrl-d right after you start the calculator. It\u0026rsquo;s conventional to put an empty alternative first and write the comment /* empty */ in it.\nThe second alternate rule (input line) handles all nontrivial input. It means, \u0026ldquo;After reading any number of lines, read one more line if possible.\u0026rdquo; The left recursion makes this rule into a loop. Since the first alternative matches empty input, the loop can be executed zero or more times.\nThe parser function input continues to process input until a grammatical error is seen or the lexical analyzer says there are no more input tokens; we will arrange for the latter to happen at end of file.\nExplanation of line Now consider the definition of line:\nline: NEWLINE { } | exp NEWLINE { printf \u0026quot;\\t%.10g\\n\u0026quot; $1; flush stdout } ;  The first alternative is a token which is a newline character; this means that rpcalc accepts a blank line (and ignores it, since there is no action). The second alternative is an expression followed by a newline. This is the alternative that makes rpcalc useful. The semantic value of the exp grouping is the value of $1 because the exp in question is the first symbol in the alternative. The action prints this value, which is the result of the computation the user asked for.\nAs you can see, the semantic value associated with the line is unit.\nExplanation of expr The exp grouping has several rules, one for each kind of expression. The first rule handles the simplest expressions: those that are just numbers. The second handles an addition-expression, which looks like two expressions followed by a plus-sign. The third handles subtraction, and so on.\nexp:\tNUM\t{ $1 } | exp exp PLUS\t{ $1 +. $2 } | exp exp MINUS\t{ $1 -. $2 } ... ;  We have used | to join all the rules for exp, but we could equally well have written them separately:\nexp:\tNUM\t{ $1 }; exp:\texp exp PLUS\t{ $1 +. $2 }; exp:\texp exp MINUS\t{ $1 -. $2 }; ...  All of the rules have actions that compute the value of the expression in terms of the value of its parts. For example, in the rule for addition, $1 refers to the first component exp and $2 refers to the second one. The third component, PLUS, has no meaningful associated semantic value, but if it had one you could refer to it as $3. When the parser function recognizes a sum expression using this rule, the sum of the two subexpressions\u0026rsquo; values is produced as the value of the entire expression. See Actions.\nThe formatting shown here is the recommended convention, but Ocamlyacc does not require it. You can add or change whitespace as much as you wish. For example, this:\nexp:\tNUM { $1 } | exp exp PLUS { $1 +. $2 } | ...  means the same thing as this:\nexp: NUM\t{ $1 } | exp exp PLUS\t{ $1 + $2 } | ...  The latter, however, is much more readable.\nThe rpcalc Lexical Analyzer The lexical analyzer\u0026rsquo;s job is low-level parsing: converting characters or sequences of characters into tokens. The Ocamlyacc parser gets its tokens by calling the lexical analyzer. See The Lexical Analyzer Function.\nOnly a simple lexical analyzer is needed for the RPN calculator. This lexical analyzer reads in numbers as float and returns them as NUM tokens. It recognizes \u0026lsquo;+\u0026rsquo;, \u0026lsquo;-\u0026rsquo;, \u0026lsquo;*\u0026lsquo;, \u0026lsquo;/\u0026rsquo;, \u0026lsquo;^\u0026rsquo;, \u0026lsquo;n\u0026rsquo; as operators and returns the corresponding token: ADD, MINUS, MULTIPLY, DIVIDE, CARET and UMINUS. When it meets \u0026lsquo;\\n\u0026rsquo;, the returning token is NEWLINE. Spaces and unknown characers are skipped.\nThe return value of the lexical analyzer function is a value of the concrete token type. The same text used in Ocamlyacc rules to stand for this token type is also a Ocaml expression for the value for the type. Token type is defined by Ocamlyacc as a constructor of the concrete token type. In this example, therefore, NUM, PLUS, \u0026hellip; become values for the lexer function to use.\nThe semantic value of the token (if it has one) is returned with it. In this example, only NUM has a semantic value.\nHere is the code for the lexical analyzer:\n(* file: lexer.mll *) (* Lexical analyzer returns one of the tokens: the token NUM of a floating point number, operators (PLUS, MINUS, MULTIPLY, DIVIDE, CARET, UMINUS), or NEWLINE. It skips all blanks and tabs, unknown characters and raises End_of_file on EOF. *) { open Rtcalc (* Assumes the parser file is \u0026quot;rtcalc.mly\u0026quot;. *) } let digit = ['0'-'9'] rule token = parse | [' ' '\\t']\t{ token lexbuf } | '\\n'\t{ NEWLINE } | digit+ | \u0026quot;.\u0026quot; digit+ | digit+ \u0026quot;.\u0026quot; digit* as num { NUM (float_of_string num) } | '+'\t{ PLUS } | '-'\t{ MINUS } | '*'\t{ MULTIPLY } | '/'\t{ DIVIDE } | '^'\t{ CARET } | 'n'\t{ UMINUS } | _\t{ token lexbuf } | eof\t{ raise End_of_file }  The Controlling Function In keeping with the spirit of this example, the controlling function is kept to the bare minimum. To start the process of parsings, the only requirement is that it call parser function Parser.input with two argumenst: lexical analyzer function Lexer.token and lexbuf of Lexing.lexbuf type.\n(* file: main.ml *) (* Assumes the parser file is \u0026quot;rtcalc.mly\u0026quot; and the lexer file is \u0026quot;lexer.mll\u0026quot;. *) let main () = try let lexbuf = Lexing.from_channel stdin in while true do Rtcalc.input Lexer.token lexbuf done with End_of_file -\u0026gt; exit 0 let _ = Printexc.print main ()  The Error Reporting Routine When ther parser function detects a syntax error, it calls a function named parse_error with the string \u0026ldquo;syntax error\u0026rdquo; as argument. The default parse_error function does nothing and returns, thus initiating error recovery (see Error Recovery). The user can define a customized parse_error function in the header section of the grammar file such as:\nlet parse_error s = (* Called by the parser function on error *) print_endline s; flush stdout  After parse_error returns, the Ocamlyacc parser may recover from the error and continue parsing if the grammar contains a suitable error rule (see Error Recovery). Otherwise, the parser aborts by raising the Parsing.Parse_error exception. We have not written any error rules in this example, so any invalid input will cause the calculator program to raise exception. This is not clean behavior for a real calculator, but it is adequate for the first example.\nRunning Ocamlyacc to Make the Parser Before running Ocamlyacc to produce a parser, we need to decide how to arrange all the source code in source files. For our example, we make three files: rpcalc.mly for Ocamlyacc grammar file, lexer.mll for Ocamllex input file, main.ml which contains main function which calls our parser function.\nYou can use the following command to convert the parser grammar file into a parser file:\nocamlyacc file_name.mly  In this example the file was called rpcalc.mly (for \u0026ldquo;Reverse Polish CALCulator\u0026rdquo;). Ocamlyacc produces a file named file_name.ml. The file output by Ocamlyacc contains the source code for parser function input. The additional functions in the input file (parse_error) are copied verbatim to the output.\nCompiling the Parser File Here is how to compile and run the parser file and lexer file:\n# List files in current directory. $ ls .depend Makefile lexer.mll main.ml rpcalc.mly # Compile the Ocamlyacc parser. $ make ocamlyacc rpcalc.mly ocamlc -c rpcalc.mli ocamllex lexer.mll 15 states, 304 transitions, table size 1306 bytes ocamlc -c lexer.ml ocamlc -c rpcalc.ml ocamlc -c main.ml ocamlc -o rpcalc lexer.cmo rpcalc.cmo main.cmo rm rpcalc.mli lexer.ml rpcalc.ml # List files again. $ ls ./ .depend lexer.cmo main.cmi main.ml rpcalc.cmi rpcalc.mly ../ Makefile lexer.cmi lexer.mll main.cmo rpcalc*\trpcalc.cmo  The file rpcalc now contains the executable code. Here is an example session using rpcalc.\n$ rpcalc 4 9 + 13 3 7 + 3 4 5 *+- -13 3 7 + 3 4 5 * + - n\tNote the unary minus, n 13 5 6 / 4 n + -3.166666667 3 4 ^\tExponentiation 81 ^D\tEnd-of-file indicator $  "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/packingwidgets/theoryofpackingboxes/",
	"title": "Theory of packing boxes",
	"tags": [],
	"description": "Most packing is done by creating boxes.",
	"content": "Most packing is done by creating boxes. These are invisible widget containers that we can pack our widgets into which come in two forms, a horizontal box, and a vertical box. When packing widgets into a horizontal box, the objects are inserted horizontally from left to right or right to left depending on the call used. In a vertical box, widgets are packed from top to bottom or vice versa. You may use any combination of boxes inside or beside other boxes to create the desired effect.\nTo create a new horizontal box, we use a call to GPack.hbox (), and for vertical boxes, GPack.vbox (). The box#pack or box#add method is used to place objects inside of these containers. An object may be another container or a widget. In fact, many widgets are actually containers themselves, including the button, but we usually only use a label inside a button.\nBy using this method, GTK knows where you want to place your widgets so it can do automatic resizing and other nifty things. There are also a number of options as to how your widgets should be packed. As you can imagine, this method gives us a quite a bit of flexibility when placing and creating widgets.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/timeouts/timeouts/",
	"title": "Timeouts",
	"tags": [],
	"description": "Using the following function you can create a timeout function that will be called every _interval_ milliseconds.",
	"content": "You may be wondering how you make GTK do useful work when in gtk_main. Well, you have several options. Using the following function you can create a timeout function that will be called every \u0026ldquo;interval\u0026rdquo; milliseconds.\nval GMain.Timeout.add : ms:int -\u0026gt; callback:(unit -\u0026gt; bool) -\u0026gt; id The first argument is the number of milliseconds between calls to your function. The second argument is the function you wish to have called. The return value is an integer \u0026ldquo;tag\u0026rdquo; which may be used to stop the timeout by calling:\nval GMain.Timeout.remove : id -\u0026gt; unit You may also stop the timeout function by returning false from your callback function. Obviously this means if you want your function to continue to be called, it should return true.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/widgetoverview/typeconversion/",
	"title": "Type conversion",
	"tags": [],
	"description": "Type conversion",
	"content": "You\u0026rsquo;ll notice as you go on that you need a type conversion. What you will see are:\nmethod as_widget : Gtk.widget Gtk.obj method coerce : widget These are all used to cast arguments in functions. You\u0026rsquo;ll see them in the examples, and can usually tell when to use them simply by looking at the function\u0026rsquo;s declaration.\nFor example:\nbox#pack button#corece; This casts the button into a widget.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/",
	"title": "ocamllex tutorial",
	"tags": [],
	"description": "This is a tutorial on how to use ocamllex.",
	"content": " This is a tutorial on how to use ocamllex which is distributed with Ocaml language.\nAbout this document Lots of part of this document are borrowed from the flex manual.\nAll license term in this document is NOT related with ocamlyacc; it is ONLY for this document.\nPlease mail all comments and suggestions to me.\nThe companion tutorial for ocamlyacc is available at ocamlyacc tutorial.\nThe old tutorial and source of the examples used in this document can be found here.\n Introduction  ocamllex is a tool for generating scanners: programs which recognized lexical patterns in text.\n Some simple examples  First some simple examples to get the flavor of how one uses ocamllex. The following ocamllex input specifies a scanner which whenever it encounters the string \u0026#34;current_directory\u0026#34; will replace it with the current directory: ...\n Format of the input file  The ocamllex input file consists of four sections; header, definitions, rules and trailer section: ...\n Patterns  The patterns in the input are written using regular expressions in the style of lex, with a more Caml-like syntax.\n How the input is matched  When the generated scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, it takes the one matching the most text (the \u0026#34;longest match\u0026#34; principle). If it finds two or more matches of the same length, the rule listed first in the ocamllex input file is chosen (the \u0026#34;first match\u0026#34; principle).\n Actions  Each pattern in a rule has a corresponding action, which can be any arbitrary Ocaml expression.\n The generted scanner  The output of ocamllex is the file lex.ml when it is invoked as `ocamllex lex.mll`. The generated file contains the scanning functions, a number of tables used by it for matching tokens, and a number of auxiliary routines.\n Start conditions  ocamllex provides a mechanism for conditionally activating rules. When you want do activate the other rule, just call the other entrypoint function.\n Interfacing with ocamlyacc  One of the main uses of ocamllex is as a companion to the ocamlyacc parser-generator. ocamlyacc parsers call one of the scanning functions to find the next input token.\n Options  ocamllex has the following options: ...\n Usage tips  The number of status transitions generated by ocamllex are limited to at most 32767. If you use too many transitions, for example, too many keywords, ocamllex generates the following error message ...\n Examples  This chapter includes examples in complete form. Some are revised from the code fragments of the previous chapters.\n License    "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/usagetips/",
	"title": "Usage tips",
	"tags": [],
	"description": "The number of status transitions generated by ocamllex are limited to at most 32767. If you use too many transitions, for example, too many keywords, ocamllex generates the following error message ...",
	"content": ""
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "This chapter includes examples in complete form. Some are revised from the code fragments of the previous chapters.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamllex-tutorial/license/",
	"title": "License",
	"tags": [],
	"description": " ",
	"content": "  License in flex manual  Copyright (C) 1990 The Regents of the University of California. All rights reserved.\n Copyright and permission  Ocamllex Adaptation Copyright and Permissions Notice\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/alignmentwidget/",
	"title": "Alignment widget",
	"tags": [],
	"description": "The alignment widget allows you to place a widget within its window at a position and size relative to the size of the Alignment widget itself.",
	"content": "The alignment widget allows you to place a widget within its window at a position and size relative to the size of the Alignment widget itself. For example, it can be very useful for centering a widget within the window.\nGBin.alignment is the function associated with the Alignment widget:\nval GBin.alignment : ?xalign:Gtk.clampf -\u0026gt; ?yalign:Gtk.clampf -\u0026gt; ?xscale:Gtk.clampf -\u0026gt; ?yscale:Gtk.clampf -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; alignment This function creates a new Alignment widget with the specified parameters.\nThe parameters of Gtk.clampf type are floating point numbers which can range from 0.0 to 1.0. The xalign and yalign arguments affect the position of the widget placed within the Alignment widget. The xscale and yscale arguments effect the amount of space allocated to the widget.\nA child widget can be added to this Alignment widget using:\nmethod add : GObj.widget -\u0026gt; unit For an example of using an Alignment widget, refer to the example for the Progress Bar widget.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/arrows/",
	"title": "Arrows",
	"tags": [],
	"description": "The Arrow widget draws an arrowhead, facing in a number of possible directions and having a number of possible styles.",
	"content": "The Arrow widget draws an arrowhead, facing in a number of possible directions and having a number of possible styles. It can be very useful when placed on a button in many applications. Like the Label widget, it emits no signals.\nGMisc.arrrow is the function for creating an Arrow widget:\nval GMisc.arrow : ?kind:Gtk.Tags.arrow_type -\u0026gt; ?shadow:Gtk.Tags.shadow_type -\u0026gt; ?xalign:float -\u0026gt; ?yalign:float -\u0026gt; ?xpad:int -\u0026gt; ?ypad:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; arrow kind : default value is `RIGHT shadow : default value is `OUT This creates a new arrow widget with the indicated type and appearance. The second allows these values to be altered retrospectively. The ?kind argument may take one of the following values:\n`UP `DOWN `LEFT `RIGHT These values obviously indicate the direction in which the arrow will point. The ?shadow argument may take one of these values:\n`IN `OUT (the default) `ETCHED_IN `ETCHED_OUT `NONE Here\u0026rsquo;s a brief example to illustrate their use.\n(* file: arrow.ml *) (* Create an Arrow widget with the specified parameters * and pack in into a button *) let create_arrow_button ~kind ~shadow ~packing () = let button = GButton.button ~packing () in let arrow = GMisc.arrow ~kind ~shadow ~packing:button#add () in button let main () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Arrow Buttons\u0026#34; ~border_width:10 () in (* Set a handler for destroy event that immediately exits GTK. *) window#connect#destroy ~callback:GMain.Main.quit; (* Create a box to hold the arrow/buttons *) let box = GPack.hbox ~border_width:2 ~packing:window#add () in let f (kind, shadow) = create_arrow_button ~kind ~shadow ~packing:box#add (); () in List.iter f [(`UP, `IN); (`DOWN, `OUT); (`LEFT, `ETCHED_IN); (`RIGHT, `ETCHED_OUT) ]; window#show (); (* Rest in main and wait for the fun to begin! *) GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/compiling/",
	"title": "Compiling hello world",
	"tags": [],
	"description": "Compiling hello world",
	"content": "To compile use:\nocamlc -I +lablgtk2 -o helloworld lablgtk.cma gtkInit.cmo helloworld.ml The options are:\n -I +lablgtk2: adds the subdirectory lablgtk2 of the standard library to the search path. In that directory, there are compiled interface files (.cmi), compiled object code files (.cmo), libraries (.cma) related with lablgtk2.\n -o helloworld: specify the name of the output file produced by the linker.\n  The library and object that are usually linked in are:\n The LablGtk library (lablgtk.cma), the GTK+ widget library.\n gtkInit object(gtkInit.cmo), containing gtkInit function. If you use this object code, you don\u0026rsquo;t have to call GtkMain.Main.init () function before any lablgtk functions.\n  There are many other options and libraries very useful, please refer the ocaml manual.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/",
	"title": "Concepts of ocamlyacc",
	"tags": [],
	"description": "This chapter introduces many of the basic concepts without which the details of Ocamlyacc will not make sense.  If you do not already know how to use Ocamlyacc, we suggest you start by reading this chapter carefully.",
	"content": "This chapter introduces many of the basic concepts without which the details of Ocamlyacc will not make sense. If you do not already know how to use Ocamlyacc, we suggest you start by reading this chapter carefully.\n Languages and context-free grammars  In order for Ocamlyacc to parse a language, it must be described by a context-free grammar.\n From Foraml Rules to Ocamlyacc Input  A formal grammar is a mathematical construct. To define the language for Ocamlyacc, you must write a file expressing the grammar in Ocamlyacc syntax.\n Semantic values  A formal grammar is a mathematical construct. To define the language for Ocamlyacc, you must write a file expressing the grammar in Ocamlyacc syntax.\n Semantic actions  A grammar rule can have an action made up of Ocaml statements. Each time the parser recognizes a match for that rule, the action is executed.\n Locations  Locations in order to keep track of the textual position, or location, of each syntactic construct.\n Ocamlyacc output  When you run Ocamlyacc, you give it a Ocamlyacc grammar file as input. The output is a Ocaml source file that parses the language described by the grammar.\n Stages in use ocamlyacc  The actual language-design process using Ocamlyacc, from grammar specification to a working compiler or interpreter, has these parts:\n Overall layout of grammar  The general form of a Ocamlyacc grammar file is as follows:\n "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/license/copyright/",
	"title": "Copyright and permission",
	"tags": [],
	"description": "Copyright and Permission",
	"content": "Copyright \u0026copy; 2004-2019 SooHyoung Oh.\nPermission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.\nPermission is granted to copy and distribute modified versions of this document under the conditions for verbatim copying, provided that this copyright notice is included exactly as in the original, and that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.\nPermission is granted to copy and distribute translations of this document into another language, under the above conditions for modified versions.\nIf you are intending to incorporate this document into a published work, please contact the maintainer, and we will make an effort to ensure that you have the most up to date information available.\nThere is no guarantee that this document lives up to its intended purpose. This is simply provided as a free resource. As such, the authors and maintainers of the information provided within can not make any guarantee that the information is even accurate.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/packingwidgets/detailsofboxes/",
	"title": "Details of boxes",
	"tags": [],
	"description": "Because of this flexibility, packing boxes in GTK can be confusing at first.",
	"content": "Because of this flexibility, packing boxes in GTK can be confusing at first. There are a lot of options, and it\u0026rsquo;s not immediately obvious how they all fit together. In the end, however, there are basically five different styles.\nEach line contains one horizontal box (hbox) with several buttons. The call to #pack method is shorthand for the call to pack each of the buttons into the hbox. Each of the buttons is packed into the hbox the same way.\nThis is the declaration of the #pack method.\nmethod pack : ?from:Gtk.Tags.pack_type -\u0026gt; ?expand:bool -\u0026gt; ?fill:bool -\u0026gt; ?padding:int -\u0026gt; GObj.widget -\u0026gt; unit from : default value is `START expand : default vaue is false fill : default value is true, ignored if expand is false The first optional argument from can have `START or `END. The ~from:`START will start at the top and work its way down in a vbox, and pack left to right in an hbox. The ~from:`END will do the opposite, packing from bottom to top in a vbox, and right to left in an hbox. Using from option allows us to right justify or left justify our widgets and may be mixed in any way to achieve the desired effect.\nThe expand argument controls whether the widgets are laid out in the box to fill in all the extra space in the box so the box is expanded to fill the area allotted to it (true); or the box is shrunk to just fit the widgets (false). Setting expand to false will allow you to do right and left justification of your widgets. Otherwise, they will all expand to fit into the box.\nThe fill argument to the #pack method control whether the extra space is allocated to the objects themselves (true), or as extra padding in the box around these objects (false). It only has an effect if the expand argument is also true.\nThe last argument is the object you are packing into the box. The objects will all be buttons for now, so we\u0026rsquo;ll be packing buttons into boxes.\nWhen creating a new box, the function looks like this (GPack.hbox ()):\nGPack.hbox : ?homogeneous:bool -\u0026gt; ?spacing:int -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; box spacing: 0 by default homogeneous: false by default The homogeneous argument to GPack.hbox () (and the same for GPack.vbox ()) controls whether each object in the box has the same size (i.e., the same width in an hbox, or the same height in a vbox). If it is set, the #pack method essentially as if the expand argument was always turned on.\nWhat\u0026rsquo;s the difference between spacing (set when the box is created) and padding (set when elements are packed)? Spacing is added between objects, and padding is added on either side of an object. The following figure should make it clearer:\nHere is the code used to create the above images. I\u0026rsquo;ve commented it fairly heavily so I hope you won\u0026rsquo;t have any problems following it. Compile it yourself and play with it.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/scribble/drawingareawidget/",
	"title": "Drawing",
	"tags": [],
	"description": "We now turn to the process of drawing on the screen.",
	"content": "We now turn to the process of drawing on the screen. The widget we use for this is the DrawingArea widget. A drawing area widget is essentially an X window and nothing more. It is a blank canvas in which we can draw whatever we like. A drawing area is created using the call:\nval GMisc.drawing_area : ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; drawing_area The arguments width and height specifies the default size of the drawing area.\nThe default size can be overridden, as is true for all widgets, by calling misc#set_size_request method, and that, in turn, can be overridden if the user manually resizes the the window containing the drawing area.\nIt should be noted that when we create a DrawingArea widget, we are completely responsible for drawing the contents. If our window is obscured then uncovered, we get an exposure event and must redraw what was previously hidden.\nHaving to remember everything that was drawn on the screen so we can properly redraw it can, to say the least, be a nuisance. In addition, it can be visually distracting if portions of the window are cleared, then redrawn step by step. The solution to this problem is to use an offscreen backing pixmap. Instead of drawing directly to the screen, we draw to an image stored in server memory but not displayed, then when the image changes or new portions of the image are displayed, we copy the relevant portions onto the screen.\nTo create an offscreen pixmap, we call the function:\nval GDraw.pixmap : width:int -\u0026gt; height:int -\u0026gt; ?mask:bool -\u0026gt; ?window:\u0026lt; misc : #misc_ops; .. \u0026gt; -\u0026gt; ?colormap:Gdk.colormap -\u0026gt; unit -\u0026gt; pixmap The window parameter specifies a GDK window that this pixmap takes some of its properties from. width and height specify the size of the pixmap. colormap tells the color depth, that is the number of bits per pixel, for the new window. If the colormap is not specified, default_colormap() is used.\nWe create the pixmap in our \u0026ldquo;configure\u0026rdquo; handler. This event is generated whenever the window changes size, including when it is originally created.\n(* Backing pixmap for drawing area *) let backing = ref (GDraw.pixmap ~width:200 ~height:200 ()) (* Create a new backing pixmap of the appropriate size *) let configure window backing ev = let width = GdkEvent.Configure.width ev in let height = GdkEvent.Configure.height ev in let pixmap = GDraw.pixmap ~width ~height ~window () in pixmap#set_foreground `WHITE; pixmap#rectangle ~x:0 ~y:0 ~width ~height ~filled:true (); backing := pixmap; true The call to rectangle method clears the pixmap initially to white. We\u0026rsquo;ll say more about that in a moment.\nOur exposure event handler then simply copies the relevant portion of the pixmap onto the screen (we determine the area we need to redraw by using GdkEvent.Expost.area method to the exposure event):\n(* Redraw the screen from the backing pixmap *) let expose (drawing_area:GMisc.drawing_area) (backing:GDraw.pixmap ref) ev = let area = GdkEvent.Expose.area ev in let x = Gdk.Rectangle.x area in let y = Gdk.Rectangle.y area in let width = Gdk.Rectangle.width area in let height = Gdk.Rectangle.width area in let drawing = drawing_area#misc#realize (); new GDraw.drawable (drawing_area#misc#window) in drawing#put_pixmap ~x ~y ~xsrc:x ~ysrc:y ~width ~height !backing#pixmap; false We\u0026rsquo;ve now seen how to keep the screen up to date with our pixmap, but how do we actually draw interesting stuff on our pixmap? There are a large number of calls in GTK\u0026rsquo;s GDK library for drawing on drawables. A drawable is simply something that can be drawn upon. It can be a window, a pixmap, or a bitmap (a black and white image). We\u0026rsquo;ve already seen two such calls above, rectangle and put_pixmap methods. The some of them are: see GDraw.drawable\nmethod arc : x:int -\u0026gt; y:int -\u0026gt; width:int -\u0026gt; height:int -\u0026gt; ?filled:bool -\u0026gt; ?start:float -\u0026gt; ?angle:float -\u0026gt; unit -\u0026gt; unit method line : x:int -\u0026gt; y:int -\u0026gt; x:int -\u0026gt; y:int -\u0026gt; unit method point : x:int -\u0026gt; y:int -\u0026gt; unit method polygon : ?filled:bool -\u0026gt; (int * int) list -\u0026gt; unit method rectangle : x:int -\u0026gt; y:int -\u0026gt; width:int -\u0026gt; height:int -\u0026gt; ?filled:bool -\u0026gt; unit -\u0026gt; unit method string : string -\u0026gt; font:Gdk.font -\u0026gt; x:int -\u0026gt; y:int -\u0026gt; unit method points : (int * int) list -\u0026gt; unit method lines : (int * int) list -\u0026gt; unit method segments : ((int * int) * (int * int)) list -\u0026gt; unit method put_layout : x:int -\u0026gt; y:int -\u0026gt; ?fore:color -\u0026gt; ?back:color -\u0026gt; Pango.layout -\u0026gt; unit method put_image : x:int -\u0026gt; y:int -\u0026gt; ?xsrc:int -\u0026gt; ?ysrc:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; Gdk.image -\u0026gt; unit method put_pixmap : x:int -\u0026gt; y:int -\u0026gt; ?xsrc:int -\u0026gt; ?ysrc:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; Gdk.pixmap -\u0026gt; unit method put_rgb_data : width:int -\u0026gt; height:int -\u0026gt; ?x:int -\u0026gt; ?y:int -\u0026gt; ?dither:Gdk.Tags.rgb_dither -\u0026gt; ?row_stride:int -\u0026gt; Gpointer.region -\u0026gt; unit method put_pixbuf : x:int -\u0026gt; y:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?dither:Gdk.Tags.rgb_dither -\u0026gt; ?x_dither:int -\u0026gt; ?y_dither:int -\u0026gt; ?src_x:int -\u0026gt; ?src_y:int -\u0026gt; GdkPixbuf.pixbuf -\u0026gt; unit All of these functions uses graphics context (GC). A graphics context encapsulates information about things such as foreground and background color and line width. GDK has a full set of functions for creating and modifying graphics contexts. GDraw.drawable has the default GC and you can change it using:\nmethod set_background : color -\u0026gt; unit method set_foreground : color -\u0026gt; unit method set_clip_region : Gdk.region -\u0026gt; unit method set_clip_origin : x:int -\u0026gt; y:int -\u0026gt; unit method set_clip_mask : Gdk.bitmap -\u0026gt; unit method set_clip_rectangle : Gdk.Rectangle.t -\u0026gt; unit method set_line_attributes : ?width:int -\u0026gt; ?style:Gdk.GC.gdkLineStyle -\u0026gt; ?cap:Gdk.GC.gdkCapStyle -\u0026gt; ?join:Gdk.GC.gdkJoinStyle -\u0026gt; unit -\u0026gt; unit Our function draw_brush, which does the actual drawing on the screen, is then:\n(* Draw a rectangle on the screen *) let draw_brush (area:GMisc.drawing_area) (backing:GDraw.pixmap ref) x y = let x = x - 5 in let y = y - 5 in let width = 10 in let height = 10 in let update_rect = Gdk.Rectangle.create ~x ~y ~width ~height in !backing#set_foreground `BLACK; !backing#rectangle ~x ~y ~width ~height ~filled:true (); area#misc#draw (Some update_rect) After we draw the rectangle representing the brush onto the pixmap, we call the method:\nmethod misc#draw : Gdk.Rectangle.t option -\u0026gt; unit which notifies X that the given area needs to be updated. X will eventually generate an expose event (possibly combining the areas passed in several calls to misc#draw) which will cause our expose event handler to copy the relevant portions to the screen.\nWe have now covered the entire drawing program except for a few mundane details like creating the main window.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/formalrule/",
	"title": "From Foraml Rules to Ocamlyacc Input",
	"tags": [],
	"description": "A formal grammar is a mathematical construct. To define the language for Ocamlyacc, you must write a file expressing the grammar in Ocamlyacc syntax.",
	"content": "A formal grammar is a mathematical construct. To define the language for Ocamlyacc, you must write a file expressing the grammar in Ocamlyacc syntax: a Ocamlyacc grammar file. See Ocamlyacc Grammar Files.\nA nonterminal symbol in the formal grammar is represented in Ocamlyacc input as an identifier, like an identifier in Ocaml. It is like regular Caml symbol, except that it cannot end with \u0026lsquo; (single quote). It should start in lower case, such as expr, stmt or declaration.\nThe Ocamlyacc representation for a terminal symbol is also called a token types. Token typess should be declared in Ocamlyacc Declaration Section and they are added as constructors for the token concrete type. As constructors, they should start with upper case: for example, Integer, Identifier, IF or RETURN. The terminal symbol error is reserved for error recovery. See Symbols.\nThe grammar rules also have an expression in Ocamlyacc syntax. For example, here is the Ocamlyacc rule for a C return statement.\nstmt: RETURN expr SEMICOLON ;  See Syntax of Grammar Rules.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/gtkrcfiles/gtkrcfileformat/",
	"title": "GTK&#39;s rc file format",
	"tags": [],
	"description": "What if you have a function which you want to be called when nothing else is happening?",
	"content": "The format of the GTK file is illustrated in the example below. This is the testgtkrc file from the GTK distribution, but I\u0026rsquo;ve added a few comments and things. You may wish to include this explanation in your application to allow the user to fine tune his application.\nThere are several directives to change the attributes of a widget.\n fg - Sets the foreground color of a widget.\n bg - Sets the background color of a widget.\n bg_pixmap - Sets the background of a widget to a tiled pixmap.\n font - Sets the font to be used with the given widget.\n  In addition to this, there are several states a widget can be in, and you can set different colors, pixmaps and fonts for each state. These states are:\n NORMAL - The normal state of a widget, without the mouse over top of it, and not being pressed, etc.\n PRELIGHT - When the mouse is over top of the widget, colors defined using this state will be in effect.\n ACTIVE - When the widget is pressed or clicked it will be active, and the attributes assigned by this tag will be in effect.\n INSENSITIVE - When a widget is set insensitive, and cannot be activated, it will take these attributes.\n SELECTED - When an object is selected, it takes these attributes.\n  When using the \u0026ldquo;fg\u0026rdquo; and \u0026ldquo;bg\u0026rdquo; keywords to set the colors of widgets, the format is:\nfg[\u0026lt;STATE\u0026gt;] = { Red, Green, Blue } Where STATE is one of the above states (PRELIGHT, ACTIVE, etc), and the Red, Green and Blue are values in the range of 0 - 1.0, { 1.0, 1.0, 1.0 } being white. They must be in float form, or they will register as 0, so a straight \u0026ldquo;1\u0026rdquo; will not work, it must be \u0026ldquo;1.0\u0026rdquo;. A straight \u0026ldquo;0\u0026rdquo; is fine because it doesn\u0026rsquo;t matter if it\u0026rsquo;s not recognized. Unrecognized values are set to 0.\nbg_pixmap is very similar to the above, except the colors are replaced by a filename.\npixmap_path is a list of paths separated by \u0026ldquo;:\u0026ldquo;\u0026rsquo;s. These paths will be searched for any pixmap you specify.\nThe font directive is simply:\nfont = \u0026#34;\u0026lt;font name\u0026gt;\u0026#34; The only hard part is figuring out the font string. Using xfontsel or a similar utility should help.\nThe \u0026ldquo;widget_class\u0026rdquo; sets the style of a class of widgets. These classes are listed in the widget overview on the class hierarchy.\nThe \u0026ldquo;widget\u0026rdquo; directive sets a specifically named set of widgets to a given style, overriding any style set for the given widget class. These widgets are registered inside the application using the misc#set_name call. This allows you to specify the attributes of a widget on a per widget basis, rather than setting the attributes of an entire widget class. I urge you to document any of these special widgets so users may customize them.\nWhen the keyword parent is used as an attribute, the widget will take on the attributes of its parent in the application.\nWhen defining a style, you may assign the attributes of a previously defined style to this new one.\nstyle \u0026#34;main_button\u0026#34; = \u0026#34;button\u0026#34; { font = \u0026#34;-adobe-helvetica-medium-r-normal--*-100-*-*-*-*-*-*\u0026#34; bg[PRELIGHT] = { 0.75, 0, 0 } } This example takes the \u0026ldquo;button\u0026rdquo; style, and creates a new \u0026ldquo;main_button\u0026rdquo; style simply by changing the font and prelight background color of the \u0026ldquo;button\u0026rdquo; style.\nOf course, many of these attributes don\u0026rsquo;t apply to all widgets. It\u0026rsquo;s a simple matter of common sense really. Anything that could apply, should.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/",
	"title": "Getting started",
	"tags": [],
	"description": "To begin our introduction to GTK, we&#39;ll start with the simplest program possible.",
	"content": " To begin our introduction to GTK, we\u0026rsquo;ll start with the simplest program possible. This program will create a 200x200 pixel window and has no way of exiting except to be killed by using the shell.\n(* file: base.ml *) let main () = let window = GWindow.window () in window#show (); GMain.Main.main () let _ = main () You can compile the above program with ocamlc using:\nocamlc -I +lablgtk2 -o base lablgtk.cma gtkInit.cmo base.ml\nThe meaning of the unusual compilation options is explained below in Compiling Hello World.\nThe first two lines of code create and display a window.\nlet window = GWindow.window () in window#show (); Rather than create a window of 0x0 size, a window without children is set to 200x200 by default so you can still manipulate it.\nThe GWindow.window#show method lets GTK know that we are done setting the attributes of this widget, and that it can display it.\nThe last line enters the GTK main processing loop.\nGMain.Main.main () GMain.Main.main is another call you will see in every GTK application. When control reaches this point, GTK will sleep waiting for events (such as button or key presses), timeouts, or file IO notifications to occur. In our simple example, however, events are ignored.\nHello World in GTK Now for a program with a widget (a button). It\u0026rsquo;s the classic hello world a la GTK.\n(* file: hello.ml *) (* This is a callback function. *) let hello () = print_endline \u0026#34;Hello World\u0026#34;; flush stdout (* Another callback function. * If you return [false] in the \u0026#34;delete_event\u0026#34; signal handler, * GTK will emit the \u0026#34;destroy\u0026#34; signal. Returning [true] means * you don\u0026#39;t want the window to be destroyed. * This is useful for popping up \u0026#39;are you sure you want to quit?\u0026#39; * type dialogs. *) let delete_event ev = print_endline \u0026#34;Delete event occurred\u0026#34;; flush stdout; (* Change [true] to [false] and the main window will be destroyed with * a \u0026#34;delete event\u0026#34; *) true let destroy () = GMain.Main.quit () let main () = (* Create a new window and sets the border width of the window. *) let window = GWindow.window ~border_width:10 () in (* When the window is given the \u0026#34;delete_event\u0026#34; signal (this is given * by the window manager, usually by the \u0026#34;close\u0026#34; option, or on the * titlebar), we ask it to call the delete_event () function * as defined above. *) window#event#connect#delete ~callback:delete_event; (* Here we connect the \u0026#34;destroy\u0026#34; event to a signal handler. * This event occurs when we call window#destroy method * or if we return [false] in the \u0026#34;delete_event\u0026#34; callback. *) window#connect#destroy ~callback:destroy; (* Creates a new button with the label \u0026#34;Hello World\u0026#34;. * and packs the button into the window (a gtk container). *) let button = GButton.button ~label:\u0026#34;Hello World\u0026#34; ~packing:window#add () in (* When the button receives the \u0026#34;clicked\u0026#34; signal, it will call the * function hello(). The hello() function is defined above. *) button#connect#clicked ~callback:hello; (* This will cause the window to be destroyed by calling * window#destroy () when \u0026#34;clicked\u0026#34;. Again, the destroy * signal could come from here, or the window manager. *) button#connect#clicked ~callback:window#destroy; (* The final step is to display the window. *) window#show (); (* All GTK applications must have a GMain.Main.main (). Control ends here * and waits for an event to occur (like a key press or * mouse event). *) GMain.Main.main () let _ = main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/timeouts/idlefunctions/",
	"title": "Idle functions",
	"tags": [],
	"description": "What if you have a function which you want to be called when nothing else is happening?",
	"content": "What if you have a function which you want to be called when nothing else is happening?\nval GMain.Idle.add : callback:(unit -\u0026gt; bool) -\u0026gt; id This causes GTK to call the specified function whenever nothing else is happening.\nval GMain.Idle.remove : id -\u0026gt; unit I won\u0026rsquo;t explain the meaning of the arguments as they follow very much like the ones above. The callback function of GMain.Idle.add will be called whenever the opportunity arises. As with the others, returning false will stop the idle function from being called.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/infixcalculator/",
	"title": "Infix Notation Calculator",
	"tags": [],
	"description": "Infix Notation Calculator: calc",
	"content": "We now modify rpcalc to handle infix operators instead of postfix. Infix notation involves the concept of operator precedence and the need for parentheses nested to arbitrary depth. Here is the Ocamlyacc code for calc.mly, an infix desk-top calculator.\n/* file: calc.mly */ /* Infix notatoin calculator -- calc */ %{ open Printf %} /* Ocamlyacc Declarations */ %token NEWLINE %token LPAREN RPAREN %token \u0026lt;float\u0026gt; NUM %token PLUS MINUS MULTIPLY DIVIDE CARET %left PLUS MINUS %left MULTIPLY DIVIDE %left NEG\t/* negation -- unary minus */ %right CARET\t/* exponentiation */ %start input %type \u0026lt;unit\u0026gt; input /* Grammar follows */ %% input:\t/* empty */\t{ } | input line\t{ } ; line:\tNEWLINE\t{ } | exp NEWLINE\t{ printf \u0026quot;\\t%.10g\\n\u0026quot; $1; flush stdout } ; exp:\tNUM\t{ $1 } | exp PLUS exp\t{ $1 +. $3 } | exp MINUS exp\t{ $1 -. $3 } | exp MULTIPLY exp\t{ $1 *. $3 } | exp DIVIDE exp\t{ $1 /. $3 } | MINUS exp %prec NEG\t{ -. $2 } | exp CARET exp\t{ $1 ** $3 } | LPAREN exp RPAREN\t{ $2 } ; %%  There are two important new features shown in this code.\nIn the second section (Ocamlyacc declarations), %left says they are left-associative operators. The declarations %left and %right (right associativity) is used for the declaration of associativity.\nOperator precedence is determined by the line ordering of the declarations; the higher the line number of the declaration (lower on the page or screen), the higher the precedence. Hence, exponentiation has the highest precedence, unary minus (NEG) is next, followed by MULTIPLY and DIVIDE, and so on. See Operator Precedence.\nThe other important new feature is the %prec in the grammar section for the unary minus operator. The %prec simply instructs Ocamlyacc that the rule | MINUS exp has the same precedence as NEG\u0026mdash;in this case the next-to-highest. See Context-Dependent Precedence.\nHere is a sample run of calc.mly:\n$ calc 4 + 4.5 - (34/(8*3+-3)) 6.880952381 -56 + 2 -54 3 ^ 2 9  "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parserinterface/lexicalfunctions/",
	"title": "Lexical Functions",
	"tags": [],
	"description": "The lexical analyzer function, named after rule declarations, recognizes tokens from the input stream and returns them to the parser.",
	"content": "The lexical analyzer function, named after rule declarations, recognizes tokens from the input stream and returns them to the parser. Ocamlyacc does not create this function automatically; you must write it so that parser function can call it. The function is sometimes referred to as a lexical scanner.\nThis function is usually generated by ocamllex. See Chapter 12 Lexer and parser generators (ocamllex, ocamlyacc).\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/menuwidgets/manualmenuexample/",
	"title": "Manual menu example",
	"tags": [],
	"description": "Manual menu example",
	"content": "That should about do it. Let\u0026rsquo;s take a look at an example to help clarify.\nlet uprint msg () = print_endline msg; flush stdout let create_file_menu ~packing () = let file_menu = GMenu.menu ~packing () in let f (label, callback) = let item = GMenu.menu_item ~label ~packing:file_menu#append () in ignore (item#connect#activate ~callback) in List.iter f [(\u0026#34;Open\u0026#34;, uprint \u0026#34;Open\u0026#34;); (\u0026#34;Save\u0026#34;, uprint \u0026#34;Save\u0026#34;); (\u0026#34;Quit\u0026#34;, GMain.Main.quit)]; file_menu let button_pressed menu ev = let button = GdkEvent.Button.button ev in if button = 3 then ( menu#popup ~button ~time:(GdkEvent.Button.time ev); true ) else false let main () = let window = GWindow.window ~title:\u0026#34;GMenu Demo\u0026#34; () in window#connect#destroy ~callback:GMain.Main.quit; let vbox = GPack.vbox ~packing:window#add () in let menu_bar = GMenu.menu_bar ~packing:vbox#add () in let file_item = GMenu.menu_item ~label:\u0026#34;File\u0026#34; ~packing:menu_bar#append () in let menu = create_file_menu ~packing:file_item#set_submenu () in let view = GText.view ~width:200 ~height:100 ~packing:vbox#add () in view#event#connect#button_press ~callback:(button_pressed menu); window#show (); GMain.Main.main () let _ = main () You may also set a menu item to be insensitive and, using an accelerator table, bind keys to menu functions.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/creatingwidgets/memorymanagement/",
	"title": "Memory management",
	"tags": [],
	"description": "Important efforts have been dedicated to cooperate with Gtk&#39;s reference counting mechanism.",
	"content": "Important efforts have been dedicated to cooperate with Gtk\u0026rsquo;s reference counting mechanism. As a result you should generally be able to use Gdk/Gtk data structures without caring about memory management. They will be freed when nobody points to them any more. This also means that you do not need to pay too much attention to whether a data structure is still alive or not. If it is not, you should get an error rather than a core dump. The case of Gtk objects deserves special care. Since they are interactive, we cannot just destroy them when they are no longer referenced. They have to be explicitely destroyed. If a widget was added to a container widget, it will automatically be destroyed when its last container is destroyed. For this reason you need only destroy toplevel widgets.\nIMPORTANT: Some Gtk data structures are allocated in the Caml heap, and there use in signals (Gtk functions internally cally callbacks) relies on their address being stable during a function call. For this reason automatic compaction is disabled in GtkMain. If you need it, you may use compaction through Gc.compact where it is safe (timeouts, other threads\u0026hellip;), but do not enable automatic compaction.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/operatorprecedence/",
	"title": "Operator Precedence",
	"tags": [],
	"description": "the Ocamlyacc declarations for operator precedence allow you to specify when to shift and when to reduce.",
	"content": " Another situation where shift/reduce conflicts appear is in arithmetic expressions. Here shifting is not always the preferred resolution; the Ocamlyacc declarations for operator precedence allow you to specify when to shift and when to reduce.\nWhen Precedence is Needed Consider the following ambiguous grammar fragment (ambiguous because the input 1 - 2 * 3 can be parsed in two different ways):\nexpr: expr MINUS expr | expr MULTIPLY expr | expr LT expr | LPAREN expr RPAREN ... ;  Suppose the parser has seen the tokens 1, - and 2; should it reduce them via the rule for the subtraction operator? It depends on the next token. Of course, if the next token is ), we must reduce; shifting is invalid because no single rule can reduce the token sequence - 2 ) or anything starting with that. But if the next token is * or **, we have a choice: either shifting or reduction would allow the parse to complete, but with different results.\nTo decide which one Ocamlyacc should do, we must consider the results. If the next operator token op is shifted, then it must be reduced first in order to permit another opportunity to reduce the difference. The result is (in effect) 1 - (2 op 3). On the other hand, if the subtraction is reduced before shifting op, the result is (1 - 2) op 3. Clearly, then, the choice of shift or reduce should depend on the relative precedence of the operators - and op: * should be shifted first, but not **.\nWhat about input such as 1 - 2 - 5; should this be (1 - 2) - 5 or should it be 1 - (2 - 5)? For most operators we prefer the former, which is called left association. The latter alternative, right association, is desirable for assignment operators. The choice of left or right association is a matter of whether the parser chooses to shift or reduce when the stack contains 1 - 2 and the look-ahead token is -: shifting makes right-associativity.\nSpecifying Operator Precedence Ocamlyacc allows you to specify these choices with the operator precedence declarations %left and %right. Each such declaration contains a list of tokens, which are operators whose precedence and associativity is being declared. The %left declaration makes all those operators left-associative and the %right declaration makes them right-associative. A third alternative is %nonassoc, which declares that it is a syntax error to find the same operator twice \u0026ldquo;in a row\u0026rdquo;.\nThe relative precedence of different operators is controlled by the order in which they are declared. The first %left or %right declaration in the file declares the operators whose precedence is lowest, the next such declaration declares the operators whose precedence is a little higher, and so on.\nPrecedence Examples In our example, we would want the following declarations:\n%left LT %left MINUS %left MULTIPLY  In a more complete example, which supports other operators as well, we would declare them in groups of equal precedence. For example, \u0026lsquo;+\u0026rsquo; is declared with \u0026lsquo;-\u0026rsquo;:\n%left LT GT EQ NE LE GE %left PLUS MINUS %left MULTIPLY DIVIDE  (Here NE and so on stand for the operators for \u0026ldquo;not equal\u0026rdquo; and so on. We assume that these tokens are more than one character long and therefore are represented by names, not character literals.)\nHow Precedence Works The first effect of the precedence declarations is to assign precedence levels to the terminal symbols declared. The second effect is to assign precedence levels to certain rules: each rule gets its precedence from the last terminal symbol mentioned in the components. (You can also specify explicitly the precedence of a rule. See Context-Dependent Precedence.)\nFinally, the resolution of conflicts works by comparing the precedence of the rule being considered with that of the look-ahead token. If the token\u0026rsquo;s precedence is higher, the choice is to shift. If the rule\u0026rsquo;s precedence is higher, the choice is to reduce. If they have equal precedence, the choice is made based on the associativity of that precedence level. The verbose output file made by -v (see Invoking Ocamlyacc) says how each conflict was resolved.\nNot all rules and not all tokens have precedence. If either the rule or the look-ahead token has no precedence, then the default is to shift.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/rangewidgets/scrollbarwidgets/",
	"title": "Scale widget",
	"tags": [],
	"description": "Scale widgets are used to allow the user to visually select and manipulate a value within a specific range.",
	"content": " Scale widgets are used to allow the user to visually select and manipulate a value within a specific range. You might want to use a scale widget, for example, to adjust the magnification level on a zoomed preview of a picture, or to control the brightness of a color, or to specify the number of minutes of inactivity before a screensaver takes over the screen.\nCreating a Scale Widget As with scrollbars, there is a widget type for horizontal and vertical scale widgets. (Most programmers seem to favour horizontal scale widgets.) The following function GRange.scale creates vertical or horizontal scale widgets according to the argument;`VERTICAL or `HORIZONTAL:\nval GRange.scale : Gtk.Tags.orientation -\u0026gt; ?adjustment:GData.adjustment -\u0026gt; ?digits:int -\u0026gt; ?draw_value:bool -\u0026gt; ?value_pos:Gtk.Tags.position -\u0026gt; ?inverted:bool -\u0026gt; ?update_policy:Gtk.Tags.update_type -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; scale digits : default value is 1 draw_value : default value is false value_pos : default value is `LEFT inverted : default value is false update_policy : default value is `CONTINUOUS The adjustment argument may be given which has already been created with GData.adjustment, or may not, in which case, an anonymous Adjustment is created with all of its values set to 0.0 (which isn\u0026rsquo;t very useful in this case). In order to avoid confusing yourself, you probably want to create your adjustment with a page_size of 0.0 so that its upper value actually corresponds to the highest value the user can select. (If you\u0026rsquo;re already thoroughly confused, read the section on Adjustments again for an explanation of what exactly adjustments do and how to create and manipulate them.)\nFunctions and Signals (well, functions, at least) Scale widgets can display their current value as a number beside the trough. The default behaviour is to show the value, but you can change this with this function:\nmethod set_draw_value : bool -\u0026gt; unit The value displayed by a scale widget is rounded to one decimal point by default, as is the value field in its Adjustment. You can change this with:\nmethod set_digits : int -\u0026gt; unit where digits is the number of decimal places you want. You can set digits to anything you like, but no more than 13 decimal places will actually be drawn on screen.\nFinally, the value can be drawn in different positions relative to the trough:\nmethod set_value_pos : Gtk.Tags.position -\u0026gt; unit The argument can take one of the following values:\n`LEFT `RIGHT `TOP `BOTTOM If you position the value on the \u0026ldquo;side\u0026rdquo; of the trough (e.g., on the top or bottom of a horizontal scale widget), then it will follow the slider up and down the trough.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/shiftreduceconflicts/",
	"title": "Shift Reduct Conflicts",
	"tags": [],
	"description": "The situation, where either a shift or a reduction would be valid, is called a shift/reduce conflict.",
	"content": "Suppose we are parsing a language which has if-then and if-then-else statements, with a pair of rules like this:\nif_stmt: IF expr THEN stmt | IF expr THEN stmt ELSE stmt ;  Here we assume that IF, THEN and ELSE are terminal symbols for specific keyword tokens.\nWhen the ELSE token is read and becomes the look-ahead token, the contents of the stack (assuming the input is valid) are just right for reduction by the first rule. But it is also legitimate to shift the ELSE, because that would lead to eventual reduction by the second rule.\nThis situation, where either a shift or a reduction would be valid, is called a shift/reduce conflict. Ocamlyacc is designed to resolve these conflicts by choosing to shift, unless otherwise directed by operator precedence declarations. To see the reason for this, let\u0026rsquo;s contrast it with the other alternative.\nSince the parser prefers to shift the ELSE, the result is to attach the else-clause to the innermost if-statement, making these two inputs equivalent:\nif x then if y then win (); else lose; if x then do; if y then win (); else lose; end;  But if the parser chose to reduce when possible rather than shift, the result would be to attach the else-clause to the outermost if-statement, making these two inputs equivalent:\nif x then if y then win (); else lose; if x then do; if y then win (); end; else lose;  The conflict exists because the grammar as written is ambiguous: either parsing of the simple nested if-statement is legitimate. The established convention is that these ambiguities are resolved by attaching the else-clause to the innermost if-statement; this is what Ocamlyacc accomplishes by choosing to shift rather than reduce. (It would ideally be cleaner to write an unambiguous grammar, but that is very hard to do in this case.) This particular ambiguity was first encountered in the specifications of Algol 60 and is called the \u0026ldquo;dangling else\u0026rdquo; ambiguity.\nThe definition of if_stmt above is solely to blame for the conflict, but the conflict does not actually appear without additional rules. Here is a complete Ocamlyacc input file that actually manifests the conflict:\n%token IF THEN ELSE variable %% stmt: expr | if_stmt ; if_stmt: IF expr THEN stmt | IF expr THEN stmt ELSE stmt ; expr: variable ;  "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/symbols/",
	"title": "Symbols, Terminal and Nonterminal",
	"tags": [],
	"description": "Symbols in Ocamlyacc grammars represent the grammatical classifications of the language. A terminal symbol (also known as a token type) represents a class of syntactically equivalent tokens. A nonterminal symbol stands for a class of syntactically equivalent groupings.",
	"content": "Symbols in Ocamlyacc grammars represent the grammatical classifications of the language.\nA terminal symbol (also known as a token type) represents a class of syntactically equivalent tokens. You use the symbol in grammar rules to mean that a token in that class is allowed. The symbol is represented in the Ocamlyacc parser by a value of variant type, and the lexer function function returns a token type to indicate what kind of token has been read.\nA nonterminal symbol stands for a class of syntactically equivalent groupings. The symbol name is used in writing grammar rules. It should start with lower case.\nSymbol names can contain letters, digits (not at the beginning), underscores.\nThe terminal symbols in the grammar is a token type which is a value of variable type in Ocaml. So it should be start with upper case. Each such name must be defined with a Ocamlyacc declaration with %token. See Token Type Names.\nThe value returned by the lexer function is always one of the terminal symbols. Each token type becomes a Ocaml value of variant type in the parser file, so lexer function can return one.\nBecause the lexer function is defined in a separate file, you need to arrange for the token-type definitions to be available there. After invoking \u0026ldquo;ocamlyacc filename.mly\u0026rdquo;, the file filename.mli is generated which contains token-type definitions. It is used in lexer function.\nThe symbol error is a terminal symbol reserved for error recovery (see Error Recovery; you shouldn\u0026rsquo;t use it for any other purpose.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/buttonwidget/togglebuttons/",
	"title": "Toggle buttons",
	"tags": [],
	"description": "Toggle buttons are derived from normal buttons and are very similar, except they will always be in one of two states, alternated by a click.",
	"content": "Toggle buttons are derived from normal buttons and are very similar, except they will always be in one of two states, alternated by a click. They may be depressed, and when you click again, they will pop back up. Click again, and they will pop back down.\nToggle buttons are the basis for check buttons and radio buttons, as such, many of the calls used for toggle buttons are inherited by radio and check buttons. I will point these out when we come to them.\nCreating a new toggle button; see GButton.toggle_button:\nval GButton.toggle_button : ?label:string -\u0026gt; ?use_mnemonic:bool -\u0026gt; ?stock:GtkStock.id -\u0026gt; ?relief:Gtk.Tags.relief_style -\u0026gt; ?active:bool -\u0026gt; ?draw_indicator:bool -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; toggle_button As you can imagine, these work identically to the normal button widget calls. You can create a blank toggle button, and with ~lablel or ~use_mnemonic, a button with a label widget already packed into it. The usemnemonic variant additionally parses the label for \u0026lsquo;\u0026rsquo;-prefixed mnemonic characters.\nTo retrieve the state of the toggle widget, including radio and check buttons, we use a construct as shown in our example below. This tests the state of the toggle button, by calling the active method of the toggle widget\u0026rsquo;s structure. The signal of interest to us emitted by toggle buttons (the toggle button, check button, and radio button widgets) is the \u0026ldquo;toggled\u0026rdquo; signal. To check the state of these buttons, set up a signal handler to catch the toggled signal, and get its state. The callback will look something like:\nmethod toggled : callback:(unit -\u0026gt; unit) -\u0026gt; GtkSignal.id To force the state of a toggle button, and its children, the radio and check buttons, use this method:\nmethod set_active : bool -\u0026gt; unit The above call can be used to set the state of the toggle button, and its children the radio and check buttons. Passing a true or false as the argument to specify whether it should be down (depressed) or up (released). Default is up, or false.\nNote that when you use the set_active method, and the state is actually changed, it causes the \u0026ldquo;clicked\u0026rdquo; and \u0026ldquo;toggled\u0026rdquo; signals to be emitted from the button.\nmethod active : bool This returns the current state of the toggle button.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/movingon/upgradedhelloworld/",
	"title": "Upgraded hello world",
	"tags": [],
	"description": "A slightly improved helloworld with better examples of callbacks.",
	"content": "Let\u0026rsquo;s take a look at a slightly improved helloworld with better examples of callbacks. This will also introduce us to our next topic, packing widgets.\n(* file: hello2.ml *) let clicked msg () = print_endline msg; flush stdout let delete_event ev = GMain.Main.quit (); false let main () = (* Create a new window and sets the border width and title of the window. *) let window = GWindow.window ~title:\u0026#34;Hello Buttons!\u0026#34; ~border_width:10 () in (* Here we just set a handler for delete_event that immediately * exits GTK. *) window#event#connect#delete ~callback:delete_event; (* We create a box to pack widgets into. This is described in detail * in the \u0026#34;packing\u0026#34; section. The box is not really visible, it * is just used as a tool to arrange widgets. * And put the box into the main window. *) let box1 = GPack.hbox ~packing:window#add () in (* Creates a new button with the label \u0026#34;Button 1\u0026#34;. * Instead of box1#add, we pack this button into the invisible * box, which has been packed into the window. *) let button = GButton.button ~label:\u0026#34;Button 1\u0026#34; ~packing:box1#pack () in (* Now when the button is clicked, we call the \u0026#34;clicked\u0026#34; function * with \u0026#34;button 1\u0026#34; as its argument *) button#connect#clicked ~callback:(clicked \u0026#34;button 1\u0026#34;); (* Do these same steps again to create a second button *) let button = GButton.button ~label:\u0026#34;Button 2\u0026#34; ~packing:box1#pack () in (* Call the same callback function with a different argument, * passing \u0026#34;button 2\u0026#34; instead. *) button#connect#clicked ~callback:(clicked \u0026#34;button 2\u0026#34;); (* Display the window. *) window#show (); (* Rest in GMain.Main.main and wait for the fun to begin! *) GMain.Main.main () let _ = main () Compile this program using the same linking arguments as our first example. You\u0026rsquo;ll notice this time there is no easy way to exit the program, you have to use your window manager or command line to kill it. A good exercise for the reader would be to insert a third \u0026ldquo;Quit\u0026rdquo; button that will exit the program. You may also wish to play with the options to box#pack () while reading the next section. Try resizing the window, and observe the behavior.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/adjustments/usingadjustment/",
	"title": "Using adjustments",
	"tags": [],
	"description": "Using adjustments",
	"content": "The adjustable widgets can be roughly divided into those which use and require specific units for these values and those which treat them as arbitrary numbers. The group which treats the values as arbitrary numbers includes the range widgets (scrollbars and scales, the progress bar widget, and the spin button widget). These widgets are all the widgets which are typically \u0026ldquo;adjusted\u0026rdquo; directly by the user with the mouse or keyboard. They will treat the lower and upper values of an adjustment as a range within which the user can manipulate the adjustment\u0026rsquo;s value. By default, they will only modify the value of an adjustment.\nThe other group includes the text widget, the viewport widget, the compound list widget, and the scrolled window widget. All of these widgets use pixel values for their adjustments. These are also all widgets which are typically \u0026ldquo;adjusted\u0026rdquo; indirectly using scrollbars. While all widgets which use adjustments can either create their own adjustments or use ones you supply, you\u0026rsquo;ll generally want to let this particular category of widgets create its own adjustments. Usually, they will eventually override all the values except the value itself in whatever adjustments you give them, but the results are, in general, undefined (meaning, you\u0026rsquo;ll have to read the source code to find out, and it may be different from widget to widget).\nNow, you\u0026rsquo;re probably thinking, since text widgets and viewports insist on setting everything except the value of their adjustments, while scrollbars will only touch the adjustment\u0026rsquo;s value, if you share an adjustment object between a scrollbar and a text widget, manipulating the scrollbar will automagically adjust the viewport widget? Of course it will! Just like this:\n... (* creates its own adjustments *) let viewport = GBin.viewport () in (* uses the newly-created adjustment for the scrollbar as well *) let vscrollbar = GRange.scrollbar `VERTICAL ~adjustment:viewport#vadjustment () in ..."
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/widgetoverview/widgethierarchy/",
	"title": "Widget hierarchy",
	"tags": [],
	"description": "The class hierarchy tree used to implement widgets.",
	"content": "This section shows the hierarchy of widgets in C version. I\u0026rsquo;m not sure this is correct or not in ocaml version. And the names of widgets used in this section are C version, not ocaml version.\n For your reference, here is the class hierarchy tree used to implement widgets. (Deprecated widgets and auxiliary classes have been omitted.)\nGObject | GtkObject +GtkWidget | +GtkMisc | | +GtkLabel | | | `GtkAccelLabel | | +GtkArrow | | `GtkImage | +GtkContainer | | +GtkBin | | | +GtkAlignment | | | +GtkFrame | | | | `GtkAspectFrame | | | +GtkButton | | | | +GtkToggleButton | | | | | `GtkCheckButton | | | | | `GtkRadioButton | | | | `GtkOptionMenu | | | +GtkItem | | | | +GtkMenuItem | | | | +GtkCheckMenuItem | | | | | `GtkRadioMenuItem | | | | +GtkImageMenuItem | | | | +GtkSeparatorMenuItem | | | | `GtkTearoffMenuItem | | | +GtkWindow | | | | +GtkDialog | | | | | +GtkColorSelectionDialog | | | | | +GtkFileSelection | | | | | +GtkFontSelectionDialog | | | | | +GtkInputDialog | | | | | `GtkMessageDialog | | | | `GtkPlug | | | +GtkEventBox | | | +GtkHandleBox | | | +GtkScrolledWindow | | | `GtkViewport | | +GtkBox | | | +GtkButtonBox | | | | +GtkHButtonBox | | | | `GtkVButtonBox | | | +GtkVBox | | | | +GtkColorSelection | | | | +GtkFontSelection | | | | `GtkGammaCurve | | | `GtkHBox | | | +GtkCombo | | | `GtkStatusbar | | +GtkFixed | | +GtkPaned | | | +GtkHPaned | | | `GtkVPaned | | +GtkLayout | | +GtkMenuShell | | | +GtkMenuBar | | | `GtkMenu | | +GtkNotebook | | +GtkSocket | | +GtkTable | | +GtkTextView | | +GtkToolbar | | `GtkTreeView | +GtkCalendar | +GtkDrawingArea | | `GtkCurve | +GtkEditable | | +GtkEntry | | `GtkSpinButton | +GtkRuler | | +GtkHRuler | | `GtkVRuler | +GtkRange | | +GtkScale | | | +GtkHScale | | | `GtkVScale | | `GtkScrollbar | | +GtkHScrollbar | | `GtkVScrollbar | +GtkSeparator | | +GtkHSeparator | | `GtkVSeparator | +GtkInvisible | +GtkPreview | `GtkProgressBar +GtkAdjustment +GtkCellRenderer | +GtkCellRendererPixbuf | +GtkCellRendererText | +GtkCellRendererToggle +GtkItemFactory +GtkTooltips `GtkTreeViewColumn"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/",
	"title": "ocamlyacc tutorial",
	"tags": [],
	"description": "This is a tutorial on how to use ocamlyacc.",
	"content": " This is a tutorial on how to use ocamlyacc which is distributed with Ocaml language.\nAbout this document Lots of part of this document are borrowed from the bison manual.\nAll license term in this document is NOT related with ocamlyacc; it is ONLY for this document.\nPlease mail all comments and suggestions to me.\nThe companion tutorial for ocamllex is available at ocamllex tutorial.\nThe old tutorial and source of the examples used in this document can be found here.\n Introduction  `Ocamlyacc` is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar.\n Concepts of ocamlyacc  This chapter introduces many of the basic concepts without which the details of Ocamlyacc will not make sense. If you do not already know how to use Ocamlyacc, we suggest you start by reading this chapter carefully.\n Examples  Now we show and explain three sample programs written using Ocamlyacc: a reverse polish notation calculator, an algebraic (infix) notation calculator, and a multi-function calculator.\n Grammar Files  Ocamlyacc takes as input a context-free grammar specification and produces a Ocaml-language function that recognizes correct instances of the grammar. The Ocamlyacc grammar input file conventionally has a name ending in .mly.\n Parser interface  The Ocamlyacc parser is actually Ocaml functions named after start symbols.\n Parser algorithm  As Ocamlyacc reads tokens, it pushes them onto a stack along with their semantic values.\n Error Recovery  It is not usually acceptable to have a program terminate on a parse error. For example, a compiler should recover sufficiently to parse the rest of the input file and check it for errors; a calculator should accept another expression.\n Debugging your parser  To debug the parser generated by ocamlyacc: ...\n Invoking Ocamlyacc  The usual way to invoke Bison is as follows: ocamlyacc filename.mly Here filename.mly is the grammar file name. The parser file\u0026rsquo;s name is made by replacing the .mly with .ml. Thus, the \u0026ldquo;ocamlyacc foo.mly\u0026rdquo; yields foo.ml. Options Ocamlyacc options  License   Bison license Bison License Copyright and permission Copyright and Permission  "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/adjustments/adjustmentinternals/",
	"title": "Adjustment internals",
	"tags": [],
	"description": "Using adjustments",
	"content": "Ok, you say, that\u0026rsquo;s nice, but what if I want to create my own handlers to respond when the user adjusts a range widget or a spin button, and how do I get at the value of the adjustment in these handlers?\nYou can use the following accessor to inspect the value of an adjustment:\nmethod value : float Since, when you set the value of an Adjustment, you generally want the change to be reflected by every widget that uses this adjustment, GTK provides this convenience function to do this:\nmethod set_value : float -\u0026gt; unit As mentioned earlier, Adjustment is a subclass of Object just like all the various widgets, and thus it is able to emit signals. This is, of course, why updates happen automagically when you share an adjustment object between a scrollbar and another adjustable widget; all adjustable widgets connect signal handlers to their adjustment\u0026rsquo;s value_changed signal, as can your program. Here\u0026rsquo;s the definition of this signal:\nmethod value_changed : callback:(unit -\u0026gt; unit) -\u0026gt; GtkSignal.id The various widgets that use the Adjustment object will emit this signal on an adjustment whenever they change its value. This happens both when user input causes the slider to move on a range widget, as well as when the program explicitly changes the value with set_value method. So, for example, if you have a scale widget, and you want to change the rotation of a picture whenever its value changes, you would create a callback like this:\nlet cb_rotate_picture adj picture () = picture#set_rotation adj#value; ... and connect it to the scale widget\u0026rsquo;s adjustment like this:\nadj#connect#value_changed ~callback:(cb_rotate_picture adj picture); What about when a widget needs to reconfigure the upper or lower fields of its adjustment, such as when a user adds more text to a text widget? In this case, you can use\nmethod set_bounds : ?lower:float -\u0026gt; ?upper:float -\u0026gt; ?step_incr:float -\u0026gt; ?page_incr:float -\u0026gt; ?page_size:float -\u0026gt; unit -\u0026gt; unit When an adjustment is reconfigured, it emits the changed signal, which looks like this:\nmethod changed : callback:(unit -\u0026gt; unit) -\u0026gt; GtkSignal.id Range widgets typically connect a handler to this signal, which changes their appearance to reflect the change - for example, the size of the slider in a scrollbar will grow or shrink in inverse proportion to the difference between the lower and upper values of its adjustment.\nNow go forth and adjust!\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/menuwidgets/automaticmenu/",
	"title": "Automatic menu generation",
	"tags": [],
	"description": "You can generate menu automatically using GToolbox.build_menu.",
	"content": " You can generate menu automatically using GToolbox.build_menu.\nval GToolbox.build_menu : GMenu.menu -\u0026gt; entries:menu_entry list -\u0026gt; unit The first argument of this function is the GMenu.menu with which various menu entries will be associated. And the function takes a value of GToolbox.menu_entry type as the second argument:\ntype menu_entry = [ `I of string * (unit -\u0026gt; unit) | `C of string * bool * (bool -\u0026gt; unit) | `R of (string * bool * (bool -\u0026gt; unit)) list | `M of string * menu_entry list | `S ]  `I: means GMenu.menu_item. It takes as arguments the label of menu_item and the callback function which is called when the menu_item is selected.\n `C: means GMenu.check_menu_item. It takes as arguments the label of check_menu_item, the default state value, and the callback function which is called when the menu_item is selected.\n `R: means GMenu.radio_menu_item. It takes a radio_menu_item description list as an argument. Each radio_menu_item description consists of (label, default state, callback function).\n `M: means GMenu.menu. It takes as arguments the label of menu and the list of menu_entry which will be associated with this menu.\n `S: means GMenu.separator_item.\n  You can use GToolbox.menu_entry for popup menu using GToolbox.popup_menu:\nval GToolbox.popup_menu : entries:menu_entry list -\u0026gt; button:int -\u0026gt; time:int32 -\u0026gt; unit Automatic Menu Generation Example (* file: menu_entry.ml *) let print msg () = print_endline msg; flush stdout let print_toggle selected = if selected then print_endline \u0026#34;On\u0026#34; else print_endline \u0026#34;Off\u0026#34;; flush stdout let print_selected n selected = if selected then ( print_endline (string_of_int n); flush stdout ) let file_entries = [ `I (\u0026#34;New\u0026#34;, print \u0026#34;New\u0026#34;); `I (\u0026#34;Open\u0026#34;, print \u0026#34;Open\u0026#34;); `I (\u0026#34;Save\u0026#34;, print \u0026#34;Save\u0026#34;); `I (\u0026#34;Save As\u0026#34;, print \u0026#34;Save As\u0026#34;); `S; `I (\u0026#34;Quit\u0026#34;, GMain.Main.quit) ] let option_entries = [ `C (\u0026#34;Check\u0026#34;, false, print_toggle); `S; `R [(\u0026#34;Rad1\u0026#34;, true, print_selected 1); (\u0026#34;Rad2\u0026#34;, false, print_selected 2); (\u0026#34;Rad3\u0026#34;, false, print_selected 3)] ] let help_entries = [ `I (\u0026#34;About\u0026#34;, print \u0026#34;About\u0026#34;); ] let entries = [ `M (\u0026#34;File\u0026#34;, file_entries); `M (\u0026#34;Options\u0026#34;, option_entries); `M (\u0026#34;Help\u0026#34;, help_entries) ] let create_menu label menubar = let item = GMenu.menu_item ~label ~packing:menubar#append () in GMenu.menu ~packing:item#set_submenu () let main () = (* Make a window *) let window = GWindow.window ~title:\u0026#34;Menu Entry\u0026#34; ~border_width:10 () in window#connect#destroy ~callback:GMain.Main.quit; let main_vbox = GPack.vbox ~packing:window#add () in let menubar = GMenu.menu_bar ~packing:main_vbox#add () in let menu = create_menu \u0026#34;File\u0026#34; menubar in GToolbox.build_menu menu ~entries:file_entries; let menu = create_menu \u0026#34;Options\u0026#34; menubar in GToolbox.build_menu menu ~entries:option_entries; let menu = create_menu \u0026#34;Help\u0026#34; menubar in GToolbox.build_menu menu ~entries:help_entries; (* Popup menu *) let button = GButton.button ~label:\u0026#34;Popup\u0026#34; ~packing:main_vbox#add () in button#connect#clicked ~callback:(fun () -\u0026gt; GToolbox.popup_menu ~entries ~button:0 ~time:(GtkMain.Main.get_current_event_time ()) ); window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/buttonwidget/checkbuttons/",
	"title": "Check buttons",
	"tags": [],
	"description": "Check buttons inherit many properties and functions from the the toggle buttons.",
	"content": "Check buttons inherit many properties and functions from the the toggle buttons above, but look a little different. Rather than being buttons with text inside them, they are small squares with the text to the right of them. These are often used for toggling options on and off in applications.\nThe creation functions are similar to those of the normal button. See GButton.check_button.\nval GButton.check_button : ?label:string -\u0026gt; ?use_mnemonic:bool -\u0026gt; ?stock:GtkStock.id -\u0026gt; ?relief:Gtk.Tags.relief_style -\u0026gt; ?active:bool -\u0026gt; ?draw_indicator:bool -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; toggle_button This function call with ~lablel option creates a check button with a label beside it.\nChecking the state of the check button is identical to that of the toggle button.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/rangewidgets/commonrangefunctions/",
	"title": "Common range functions",
	"tags": [],
	"description": "Common range functions",
	"content": " The Range widget class is fairly complicated internally, but, like all the \u0026ldquo;base class\u0026rdquo; widgets, most of its complexity is only interesting if you want to hack on it. Also, almost all of the functions and signals it defines are only really used in writing derived widgets. There are, however, a few useful functions that will work on all range widgets.\nSetting the Update Policy The \u0026ldquo;update policy\u0026rdquo; of a range widget defines at what points during user interaction it will change the value field of its Adjustment and emit the \u0026ldquo;value_changed\u0026rdquo; signal on this Adjustment. The update policies, defined as type Gtk.Tags.update_type, are:\n `CONTINUOUS: This is the default. The \u0026ldquo;value_changed\u0026rdquo; signal is emitted continuously, i.e., whenever the slider is moved by even the tiniest amount.\n `DISCONTINUOUS: The \u0026ldquo;value_changed\u0026rdquo; signal is only emitted once the slider has stopped moving and the user has released the mouse button.\n `DELAYED: The \u0026ldquo;value_changed\u0026rdquo; signal is emitted when the user releases the mouse button, or if the slider stops moving for a short period of time.\n  The update policy of a range widget can be set by calling this function:\nmethod set_update_policy : Gtk.Tags.update_type -\u0026gt; unit Getting and Setting Adjustments Getting and setting the adjustment for a range widget \u0026ldquo;on the fly\u0026rdquo; is done, predictably, with:\nmethod adjustment : GData.adjustment method set_adjustment : GData.adjustment -\u0026gt; unit adjustment method returns the adjustment to which range is connected.\nset_adjustment method does absolutely nothing if you pass it the adjustment that range is already using, regardless of whether you changed any of its fields or not. If you pass it a new Adjustment, it will disconnect the old one if it exists, connect the appropriate signals to the new one, and call the private function gtk_range_adjustment_changed(), which will (or at least, is supposed to\u0026hellip;) recalculate the size and/or position of the slider and redraw if necessary.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parserinterface/errorfunctions/",
	"title": "Error Functions",
	"tags": [],
	"description": "The Ocamlyacc parser detects a parse error or syntax error whenever it reads a token which cannot satisfy any syntax rule.",
	"content": "The Ocamlyacc parser detects a parse error or syntax error whenever it reads a token which cannot satisfy any syntax rule. An action in the grammar can also explicitly proclaim an error, using the raise Parsing.Parse_error.\nThe Ocamlyacc parser expects to report the error by calling an error reporting function named parse_error, which is optional. The default parse_error function does nothing and returns. It is called by the parser function whenever a syntax error is found, and it receives one argument. For a parse error, the string is normally \u0026ldquo;syntax error\u0026rdquo;.\nThe following definition suffices in simple programs:\nlet parse_error s = print_endline s  After parse_error returns to the parse function, the latter will attempt error recovery if you have written suitable error recovery grammar rules (see Error Recovery). If recovery is impossible, the parse function will raise Parsing.Parse_error exception.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/gtkrcfiles/examplercfile/",
	"title": "Example rc file",
	"tags": [],
	"description": "Example rc file",
	"content": "# pixmap_path \u0026#34;\u0026lt;dir 1\u0026gt;:\u0026lt;dir 2\u0026gt;:\u0026lt;dir 3\u0026gt;:...\u0026#34; # pixmap_path \u0026#34;/usr/include/X11R6/pixmaps:/home/imain/pixmaps\u0026#34; # # style \u0026lt;name\u0026gt; [= \u0026lt;name\u0026gt;] # { # \u0026lt;option\u0026gt; # } # # widget \u0026lt;widget_set\u0026gt; style \u0026lt;style_name\u0026gt; # widget_class \u0026lt;widget_class_set\u0026gt; style \u0026lt;style_name\u0026gt; # Here is a list of all the possible states. Note that some do not apply to # certain widgets. # # NORMAL - The normal state of a widget, without the mouse over top of # it, and not being pressed, etc. # # PRELIGHT - When the mouse is over top of the widget, colors defined # using this state will be in effect. # # ACTIVE - When the widget is pressed or clicked it will be active, and # the attributes assigned by this tag will be in effect. # # INSENSITIVE - When a widget is set insensitive, and cannot be # activated, it will take these attributes. # # SELECTED - When an object is selected, it takes these attributes. # # Given these states, we can set the attributes of the widgets in each of # these states using the following directives. # # fg - Sets the foreground color of a widget. # fg - Sets the background color of a widget. # bg_pixmap - Sets the background of a widget to a tiled pixmap. # font - Sets the font to be used with the given widget. # # This sets a style called \u0026#34;button\u0026#34;. The name is not really important, as # it is assigned to the actual widgets at the bottom of the file. style \u0026#34;window\u0026#34; { #This sets the padding around the window to the pixmap specified. #bg_pixmap[\u0026lt;STATE\u0026gt;] = \u0026#34;\u0026lt;pixmap filename\u0026gt;\u0026#34; bg_pixmap[NORMAL] = \u0026#34;warning.xpm\u0026#34; } style \u0026#34;scale\u0026#34; { #Sets the foreground color (font color) to red when in the \u0026#34;NORMAL\u0026#34; #state. fg[NORMAL] = { 1.0, 0, 0 } #Sets the background pixmap of this widget to that of its parent. bg_pixmap[NORMAL] = \u0026#34;\u0026lt;parent\u0026gt;\u0026#34; } style \u0026#34;button\u0026#34; { # This shows all the possible states for a button. The only one that # doesn\u0026#39;t apply is the SELECTED state. fg[PRELIGHT] = { 0, 1.0, 1.0 } bg[PRELIGHT] = { 0, 0, 1.0 } bg[ACTIVE] = { 1.0, 0, 0 } fg[ACTIVE] = { 0, 1.0, 0 } bg[NORMAL] = { 1.0, 1.0, 0 } fg[NORMAL] = { .99, 0, .99 } bg[INSENSITIVE] = { 1.0, 1.0, 1.0 } fg[INSENSITIVE] = { 1.0, 0, 1.0 } } # In this example, we inherit the attributes of the \u0026#34;button\u0026#34; style and then # override the font and background color when prelit to create a new # \u0026#34;main_button\u0026#34; style. style \u0026#34;main_button\u0026#34; = \u0026#34;button\u0026#34; { font = \u0026#34;-adobe-helvetica-medium-r-normal--*-100-*-*-*-*-*-*\u0026#34; bg[PRELIGHT] = { 0.75, 0, 0 } } style \u0026#34;toggle_button\u0026#34; = \u0026#34;button\u0026#34; { fg[NORMAL] = { 1.0, 0, 0 } fg[ACTIVE] = { 1.0, 0, 0 } # This sets the background pixmap of the toggle_button to that of its # parent widget (as defined in the application). bg_pixmap[NORMAL] = \u0026#34;\u0026lt;parent\u0026gt;\u0026#34; } style \u0026#34;text\u0026#34; { bg_pixmap[NORMAL] = \u0026#34;marble.xpm\u0026#34; fg[NORMAL] = { 1.0, 1.0, 1.0 } } style \u0026#34;ruler\u0026#34; { font = \u0026#34;-adobe-helvetica-medium-r-normal--*-80-*-*-*-*-*-*\u0026#34; } # pixmap_path \u0026#34;~/.pixmaps\u0026#34; # These set the widget types to use the styles defined above. # The widget types are listed in the class hierarchy, but could probably be # just listed in this document for the users reference. widget_class \u0026#34;GtkWindow\u0026#34; style \u0026#34;window\u0026#34; widget_class \u0026#34;GtkDialog\u0026#34; style \u0026#34;window\u0026#34; widget_class \u0026#34;GtkFileSelection\u0026#34; style \u0026#34;window\u0026#34; widget_class \u0026#34;*Gtk*Scale\u0026#34; style \u0026#34;scale\u0026#34; widget_class \u0026#34;*GtkCheckButton*\u0026#34; style \u0026#34;toggle_button\u0026#34; widget_class \u0026#34;*GtkRadioButton*\u0026#34; style \u0026#34;toggle_button\u0026#34; widget_class \u0026#34;*GtkButton*\u0026#34; style \u0026#34;button\u0026#34; widget_class \u0026#34;*Ruler\u0026#34; style \u0026#34;ruler\u0026#34; widget_class \u0026#34;*GtkText\u0026#34; style \u0026#34;text\u0026#34; # This sets all the buttons that are children of the \u0026#34;main window\u0026#34; to # the main_button style. These must be documented to be taken advantage of. widget \u0026#34;main window.*GtkButton*\u0026#34; style \u0026#34;main_button\u0026#34;"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/",
	"title": "Examples",
	"tags": [],
	"description": "Now we show and explain three sample programs written using Ocamlyacc: a reverse polish notation calculator, an algebraic (infix) notation calculator, and a multi-function calculator.",
	"content": "Now we show and explain three sample programs written using Ocamlyacc: a reverse polish notation calculator, an algebraic (infix) notation calculator, and a multi-function calculator. These examples are simple, but Ocamlyacc grammars for real programming languages are written the same way\n Reverse Polish Notation Calculator  Reverse Polish Notation Calculator: rpcalc\n Infix Notation Calculator  Infix Notation Calculator: calc\n Simple Error Recovery  Simple Error Recovery\n Location Tracking Calculator  Location Tracking Calculator: ltcalc\n Multi-Function Calculator  Multi-Function Calculator: mfcalc\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/fixedcontainer/",
	"title": "Fixed container",
	"tags": [],
	"description": "The Fixed container allows you to place widgets at a fixed position within it&#39;s window, relative to it&#39;s upper left hand corner.",
	"content": "The Fixed container allows you to place widgets at a fixed position within it\u0026rsquo;s window, relative to it\u0026rsquo;s upper left hand corner. The position of the widgets can be changed dynamically.\nGPack.fixed is the function associated with the fixed widget:\nval GPack.fixed : ?has_window:bool -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; fixed method put : GObj.widget -\u0026gt; x:int -\u0026gt; y:int -\u0026gt; unit method move : GObj.widget -\u0026gt; x:int -\u0026gt; y:int -\u0026gt; unit The function GPack.fixed allows you to create a new Fixed container.\nput method places widget in the container fixed at the position specified by x and y.\nmove method allows the specified widget to be moved to a new position.\nmethod set_has_window : bool -\u0026gt; unit method has_window : bool Normally, Fixed widgets don\u0026rsquo;t have their own X window. Since this is different from the behaviour of Fixed widgets in earlier releases of GTK, the set_has_window method allows the creation of Fixed widgets with their own window. It has to be called before realizing the widget.\nThe following example illustrates how to use the Fixed Container.\n(* file: fixed.ml *) (* Global variables to store the position of the widget * within the fixed container *) let rx = ref 50 let ry = ref 50 (* This callback function moves the button to a new position * in the Fixed container. *) let move_button but fixed () = rx := (!rx + 30) mod 300; ry := (!ry + 50) mod 300; fixed#move but#coerce ~x:!rx ~y:!ry let main () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Fixed Container\u0026#34; ~border_width:10 () in (* Here we connect the \u0026#34;destroy\u0026#34; event to a signal handler *) window#connect#destroy ~callback:GMain.Main.quit; (* Create a Fixed Container *) let fixed = GPack.fixed ~packing:window#add () in for i = 1 to 3 do (* Creates a new button with the label \u0026#34;Press me\u0026#34; * and packs the button into the fixed containers window. *) let button = GButton.button ~label:\u0026#34;Press me\u0026#34; ~packing:(fixed#put ~x:(i*50) ~y:(i*50)) () in (* When the button receives the \u0026#34;clicked\u0026#34; signal, it will call the * function move_button passing it the Fixed Container as its * argument. *) button#connect#clicked ~callback:(move_button button fixed) done; (* Display the window and enter the event loop *) window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/movingon/",
	"title": "Moving on",
	"tags": [],
	"description": "More on signal handlers",
	"content": "  More on signal handlers  Lets take another look at the #connect#signal_name declaration.\n Upgraded hello world  A slightly improved helloworld with better examples of callbacks.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/packingwidgets/packingdemoprogram/",
	"title": "Packing demonstration program",
	"tags": [],
	"description": "Packing demonstration program",
	"content": "(* file: packbox.ml *) (* Make a new hbox filled with button-labels. Arguments of the * variables we\u0026#39;re interested are passed in to this fuction. * We do not show the box, butdo show everything inside. *) let make_box ~homogeneous ~spacing ~expand ~fill ~padding ?packing () = (* Create a new hbox with the appropriate homogeneous * and spacing settings *) let box = GPack.box `HORIZONTAL ~homogeneous ~spacing ?packing () in (* Create a series of buttons with the appropriate settings *) let button = GButton.button ~label:\u0026#34;box_pack\u0026#34; ~packing:(box#pack ~expand ~fill ~padding) () in let button = GButton.button ~label:\u0026#34;(box\u0026#34; ~packing:(box#pack ~expand ~fill ~padding) () in let button = GButton.button ~label:\u0026#34;button,\u0026#34; ~packing:(box#pack ~expand ~fill ~padding) () in (* Create a button with the label depending on the value of * expand. *) let button = GButton.button ~label:(if expand then \u0026#34;TRUE,\u0026#34; else \u0026#34;FALSE,\u0026#34;) ~packing:(box#pack ~expand ~fill ~padding) () in (* This is the same as the button creation for \u0026#34;expand\u0026#34;. *) let button = GButton.button ~label:(if fill then \u0026#34;TRUE,\u0026#34; else \u0026#34;FALSE,\u0026#34;) ~packing:(box#pack ~expand ~fill ~padding) () in let button = GButton.button ~label:(Printf.sprintf \u0026#34;%d)\u0026#34; padding) ~packing:(box#pack ~expand ~fill ~padding) () in box let main () = if Array.length Sys.argv \u0026lt; 2 then ( prerr_endline \u0026#34;usage: packbox num, where num is 1, 2, or 3.\u0026#34;; exit 1 ); let which = int_of_string Sys.argv.(1) in (* Create our window *) let window = GWindow.window ~title:\u0026#34;Packing\u0026#34; ~border_width:10 () in (* You should always rememeber to connect the destroy signal * to the main window. This is very important for proper intutive * behavior *) window #connect#destroy ~callback:GMain.Main.quit; let box1 = GPack.vbox ~packing:window#add () in (* which example to show. These correspond to the pictures above. *) begin match which with | 1 -\u0026gt; (* Create a new label. *) let label = GMisc.label ~text:\u0026#34;hbox_new (false, 0);\u0026#34; () in (* Align the label to the left side. We\u0026#39;ll discuss this function and * others in the section on Widget Attributes. *) label#set_xalign 0.0; label#set_yalign 0.0; (* Pack the label into the vertical box (vobx box1). Remember that * widget added to a vbox will be packed one on top of the otehr in * order. *) box1#pack ~expand:false ~fill:false ~padding:0 label#coerce; (* Call our make box function *) let box2 = make_box ~homogeneous:false ~spacing:0 ~expand:false ~fill:false ~padding:0 () in box1#pack ~expand:false ~fill:false ~padding:0 box2#coerce; (* Call our make box function *) let box2 = make_box ~homogeneous:false ~spacing:0 ~expand:true ~fill:false ~padding:0 () in box1#pack ~expand:false ~fill:false ~padding:0 box2#coerce; (* Call our make box function *) let box2 = make_box ~homogeneous:false ~spacing:0 ~expand:true ~fill:true ~padding:0 () in box1#pack ~expand:false ~fill:false ~padding:0 box2#coerce; (* Creates a separator, we\u0026#39;ll learn more about these later, * but they are quite simple. *) let separator = GMisc.separator `HORIZONTAL () in box1#pack ~expand:false ~fill:true ~padding:0 separator#coerce; (* Create another new label, and show it. *) let label = GMisc.label ~text:\u0026#34;hbox_new (true, 0);\u0026#34; () in label#set_xalign 0.0; label#set_yalign 0.0; box1#pack ~expand:false ~fill:false ~padding:0 label#coerce; let box2 = make_box ~homogeneous:true ~spacing:0 ~expand:true ~fill:false ~padding:0 () in box1#pack ~expand:false ~fill:false ~padding:0 box2#coerce; let box2 = make_box ~homogeneous:true ~spacing:0 ~expand:true ~fill:true ~padding:0 () in box1#pack ~expand:false ~fill:false ~padding:0 box2#coerce; (* Another new separator. *) let separator = GMisc.separator `HORIZONTAL () in box1#pack ~expand:false ~fill:true ~padding:5 separator#coerce; | 2 -\u0026gt; (* Create a new label, remember box1 is a vbox as created * near the beginning of main(). * You can give widget attributes on widget creation. * See: ~xalign, ~yalign, ~packing *) let label = GMisc.label ~text:\u0026#34;hbox_new (false, 10);\u0026#34; ~xalign:0.0 ~yalign:0.0 ~packing:(box1#pack ~expand:false ~fill:false ~padding:0) () in (* Packing is done in make_box () *) make_box ~homogeneous:false ~spacing:10 ~expand:true ~fill:false ~padding:0 ~packing:(box1#pack ~expand:false ~fill:false ~padding:0) (); (* Same: packing is done in make_box () *) make_box ~homogeneous:false ~spacing:10 ~expand:true ~fill:true ~padding:0 ~packing:(box1#pack ~expand:false ~fill:false ~padding:0) (); (* Packing is done in GMisc.separator () *) GMisc.separator `HORIZONTAL ~packing:(box1#pack ~expand:false ~fill:true ~padding:5) (); (* Alignment and packing is done in GMisc.label () *) GMisc.label ~text:\u0026#34;hbox_new (false, 0);\u0026#34; ~xalign:0.0 ~yalign:0.0 ~packing:(box1#pack ~expand:false ~fill:false ~padding:0) (); make_box ~homogeneous:false ~spacing:0 ~expand:true ~fill:false ~padding:10 ~packing:(box1#pack ~expand:false ~fill:false ~padding:0) (); make_box ~homogeneous:false ~spacing:0 ~expand:true ~fill:true ~padding:10 ~packing:(box1#pack ~expand:false ~fill:false ~padding:0) (); GMisc.separator `HORIZONTAL ~packing:(box1#pack ~expand:false ~fill:true ~padding:5) (); () | 3 -\u0026gt; (* This demonstrates the ability to use \u0026#34;pack ~from:`END\u0026#34; to * right justify widgets. First, we create a new box as before. *) let box2 = make_box ~homogeneous:false ~spacing:0 ~expand:false ~fill:false ~padding:0 () in (* Create the label that will be put at the end. * and pack it using \u0026#34;pack ~from:`END\u0026#34;, so it is put on the right * side of the hbox created in the make_box () call. *) let label = GMisc.label ~text:\u0026#34;end\u0026#34; ~packing:(box2#pack ~from:`END ~expand:false ~fill:false ~padding:0) () in (* Pack box2 into box1 (the vbox remember ? :) *) box1#pack ~expand:false ~fill:false ~padding:0 box2#coerce; (* A separator for the bottom. * And pack the separator into the vbox (box1) created near the start * of main () *) let separator = GMisc.separator `HORIZONTAL ~packing:(box1#pack ~expand:false ~fill:true ~padding:5) () in (* This explicitly set the separstor to 400 pixels wide by 5 pixels * high. This is so the hbox we created will also be 400 pixels wide, * and the \u0026#34;end\u0026#34; label will be separated from the other labels in the * hbox. Otherwise, all the widgets in the hbox would be packed as * close together as possible. *) separator#misc#set_size_request ~width:400 ~height:5 () | _ -\u0026gt; () end; (* Create another new hbox. remember we can use as many as we need! *) let quitbox = GPack.hbox ~homogeneous:false ~spacing:0 ~packing:(box1#pack ~expand:false ~fill:false ~padding:0) () in (* Our quit button. *) let button = GButton.button ~label:\u0026#34;Quit\u0026#34; ~packing:(box1#pack ~expand:false ~fill:false ~padding:0) () in button#connect#clicked ~callback:GMain.Main.quit; (* Showing the window last so everything pops up at once. *) window#show (); (* And of course, our main function. *) GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/semanticvalues/",
	"title": "Semantic values",
	"tags": [],
	"description": "A formal grammar is a mathematical construct. To define the language for Ocamlyacc, you must write a file expressing the grammar in Ocamlyacc syntax.",
	"content": "A formal grammar selects tokens only by their classifications: for example, if a rule mentions the terminal symbol `integer constant\u0026rsquo;, it means that any integer constant is grammatically valid in that position. The precise value of the constant is irrelevant to how to parse the input: if x+4 is grammatical then x+1 or x+3989 is equally grammatical.\nBut the precise value is very important for what the input means once it is parsed. A compiler is useless if it fails to distinguish between 4, 1 and 3989 as constants in the program! Therefore, each token in a Ocamlyacc grammar has both a token type and a semantic value. See Defining Language Semantics, for details.\nThe token type is a terminal symbol defined in the grammar, such as INTEGER, IDENTIFIER or SEMICOLON. It tells everything you need to know to decide where the token may validly appear and how to group it with other tokens. The grammar rules know nothing about tokens except their types.\nThe semantic value has all the rest of the information about the meaning of the token, such as the value of an integer, or the name of an identifier. (A token such as SEMICOLON which is just punctuation doesn\u0026rsquo;t need to have any semantic value.)\nFor example, an input token might be classified as token type INTEGER and have the semantic value 4. Another input token might have the same token type INTEGER but value 3989. When a grammar rule says that INTEGER is allowed, either of these tokens is acceptable because each is an INTEGER. When the parser accepts the token, it keeps track of the token\u0026rsquo;s semantic value.\nEach grouping can also have a semantic value as well as its nonterminal symbol. For example, in a calculator, an expression typically has a semantic value that is a number. In a compiler for a programming language, an expression typically has a semantic value that is a tree structure describing the meaning of the expression.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/simpleerrorrecovery/",
	"title": "Simple Error Recovery",
	"tags": [],
	"description": "Simple Error Recovery",
	"content": "Up to this point, this manual has not addressed the issue of error recovery\u0026mdash;how to continue parsing after the parser detects a syntax error. All we have handled is error reporting with parse_error. Recall that by default, the parser function raises exception after calling parse_error. This means that an erroneous input line causes the calculator program to raise exception and exit. Now we show how to rectify this deficiency.\nThe Ocamlyacc language itself includes the reserved word error, which may be included in the grammar rules. In the example below it has been added to one of the alternatives for line:\nline: NEWLINE | exp NEWLINE\t{ printf \u0026quot;\\t%.10g\\n\u0026quot; $1; flush stdout } | error NEWLINE\t{ } ;  This addition to the grammar allows for simple error recovery in the event of a parse error. If an expression that cannot be evaluated is read, the error will be recognized by the third rule for line, and parsing will continue. (The parse_error function is still called.) The action executes the statement and continues to parse.\nThis form of error recovery deals with syntax errors. There are other kinds of errors; for example, division by zero, which raises an exception that is normally fatal. A real calculator program must handle this exception and resume parsing input lines; it would also have to discard the rest of the current line of input. We won\u0026rsquo;t discuss this issue further because it is not specific to Ocamlyacc programs.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/syntaxofrules/",
	"title": "Syntax of grammar rules",
	"tags": [],
	"description": "A Ocamlyacc grammar rule has the following general form:",
	"content": "A Ocamlyacc grammar rule has the following general form:\nresult: symbol ... symbol { semantic-action } | ... | symbol ... symbol { semantic-action } ;  where result is the nonterminal symbol that this rule describes, and symbol are various terminal and nonterminal symbols that are put together by this rule (see Symbols).\nFor example,\nexp: exp PLUS exp\t{} ;  says that two groupings of type exp, with a PLUS token in between, can be combined into a larger grouping of type exp.\nWhitespace in rules is significant only to separate symbols. You can add extra whitespace as you wish.\nAt the end of the components there must be one action that determine the semantics of the rule. An action looks like this:\n{Ocaml code}  See Actions for detail description.\nMultiple rules for the same result can be written separately or can be joined with the vertical-bar character | as follows:\nresult: rule1-symbol ... rule1-symbol { rule1-semantic-action } | rule2-symbol ... rule2-symbol { rule2-semantic-action } | ... ;  They are still considered distinct rules even when joined in this way.\nIf components in a rule is empty, it means that result can match the empty string. For example, here is how to define a comma-separated sequence of zero or more exp groupings:\nexpseq: /* empty */\t{} | expseq1\t{} ; expseq1: exp\t{} | expseq1 COMMA exp\t{} ;  It is customary to write a comment /* empty */ in each rule with no components.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/signalandcallback/",
	"title": "Theory of Signals and Callbacks",
	"tags": [],
	"description": "Theory of Signals and Callbacks",
	"content": "Before we look in detail at helloworld, we\u0026rsquo;ll discuss signals and callbacks. GTK is an event driven toolkit, which means it will sleep in GMain.Main.main until an event occurs and control is passed to the appropriate function.\nThis passing of control is done using the idea of \u0026ldquo;signals\u0026rdquo;. (Note that these signals are not the same as the Unix system signals, and are not implemented using them, although the terminology is almost identical.) When an event occurs, such as the press of a mouse button, the appropriate signal will be \u0026ldquo;emitted\u0026rdquo; by the widget that was pressed. This is how GTK does most of its useful work. There are signals that all widgets inherit, such as \u0026ldquo;destroy\u0026rdquo;, and there are signals that are widget specific, such as \u0026ldquo;toggled\u0026rdquo; on a toggle button.\nTo make a button perform an action, we set up a signal handler to catch these signals and call the appropriate function. This is done by using a function such as:\nwidget#connect#signal_name ~callback:(unit -\u0026gt; unit) -\u0026gt; GtkSignal.id where the widget is the one which will be emitting the signal, and the signal_name is the name of the signal you wish to catch. The callback is the function you wish to be called when it is caught.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/tooltips/",
	"title": "Tooltips object",
	"tags": [],
	"description": "The little text strings that pop up when you leave your pointer over a button or other widget for a few seconds.",
	"content": "These are the little text strings that pop up when you leave your pointer over a button or other widget for a few seconds. They are easy to use, so I will just explain them without giving an example. If you want to see some code, take a look at the testgtk.ml program distributed with LablGTK.\nWidgets that do not receive events (widgets that do not have their own window) will not work with tooltips.\nThe first call you will use creates a new tooltip using GData.tooltips function. You only need to do this once for a set of tooltips as the GData.tooltips object this function returns can be used to create multiple tooltips.\nval GData.tooltips : ?delay:int -\u0026gt; unit -\u0026gt; tooltips Once you have created a new tooltip, and the widget you wish to use it on, simply use this call to set it:\nmethod set_tip : ?text:string -\u0026gt; ?privat:string -\u0026gt; GObj.widget -\u0026gt; unit The ?text argument is the text you with to say, which is followed by the widget you wish to have this tooltip pop up for wish it to say. The ?privat argument is a text string that can be used as an identifier when using GtkTipsQuery to implement context sensitive help. For now, you don\u0026rsquo;t have to give it.\nHere\u0026rsquo;s a short example:\nlet tooltips = GData.tooltips () in let button = GButton.button ~label:\u0026#34;This is button1\u0026#34; () in . . . tooltips#set_tip button#coerce ~text:\u0026#34;This is button1\u0026#34;; There are other calls that can be used with tooltips. I will just list them with a brief description of what they do.\nmethod enable : unit -\u0026gt; unit Enable a disabled set of tooltips.\nmethod disable : unit -\u0026gt; unit Disable an enabled set of tooltips.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/widgetoverview/widgetswithoutwindows/",
	"title": "Widget without windows",
	"tags": [],
	"description": "The following widgets do not have an associated window.",
	"content": "The names of widgets used in this section are C version, not ocaml version.\n The following widgets do not have an associated window. If you want to capture events, you\u0026rsquo;ll have to use the EventBox. See the section on the EventBox widget.\nGtkAlignment GtkArrow GtkBin GtkBox GtkButton GtkCheckButton GtkFixed GtkImage GtkLabel GtkMenuItem GtkNotebook GtkPaned GtkRadioButton GtkRange GtkScrolledWindow GtkSeparator GtkTable GtkToolbar GtkAspectFrame GtkFrame GtkVBox GtkHBox GtkVSeparator GtkHSeparator We\u0026rsquo;ll further our exploration of GTK by examining each widget in turn, creating a few simple functions to display them. Another good source is the testgtk program that comes with LablGtk. It can be found in examples/testgtk.ml.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/",
	"title": "lablgtk2 tutorial",
	"tags": [],
	"description": "lablgtk2 tutorial",
	"content": "This is ocaml adaptation of the GTK+ 2.0 Tutoirial.\nThe old tutorial and source of the examples used in this document can be found here.\n Introduction  Introduction\n Getting started  To begin our introduction to GTK, we\u0026#39;ll start with the simplest program possible.\n Moving on  More on signal handlers\n Packing widgets  When creating an application, you\u0026#39;ll want to put more than one widget inside a window.\n Widget overview  The general steps to creating a widget in GTK are ...\n Creating Widgets  You create a widget by ...\n Button widget  We\u0026#39;ve almost seen all there is to see of the button widget. It\u0026#39;s pretty simple. There is however more than one way to create a button.\n Adjustments  GTK has various widgets that can be visually adjusted by the user using the mouse or the keyboard, such as the range widgets, described in the Range Widgets section.\n Range widgets  The category of range widgets includes the ubiquitous scrollbar widget and the less common scale widget.\n Miscellaneous widgets  Labels, arrows, tooltips, progress bars, dialog widgets, ...\n Container widgets  EventBox, Alignment widget, fixed container, layout container, ...\n Menu widgets  There are two ways to create menus: there\u0026#39;s the easy way, and there\u0026#39;s the hard way. Both have their uses, but you can usually use the Itemfactory (the easy way).\n Undocumented widgets  These all require authors! :) Please consider contributing to our tutorial.\n Setting widget attributes  This describes the functions used to operate on widgets. These can be used to set style, padding, size, etc.\n Timeouts and idle functions  Timeouts and idle functions\n Advanced event and signal handling  Advanced event and signal handling\n Clipboard  Text copy and paste is a good example of clipboard widget. You can do inter-processor communication throuth the widget.\n Drag-and-drop  GTK\u0026#43; has a high level set of functions for doing inter-process communication via the drag-and-drop system. GTK\u0026#43; can perform drag-and-drop on top of the low level Xdnd and Motif drag-and-drop protocols.\n GTK\u0026#39;s rc files  GTK has its own way of dealing with application defaults, by using rc files. These can be used to set the colors of just about any widget, and can also be used to tile pixmaps onto the background of some widgets.\n Scribble, drawing program  In this section, we will build a simple drawing program. In the process, we will examine how to handle mouse events, how to draw in a window, and how to do drawing better by using a backing pixmap.\n Contributing  This document, like so much other great software out there, was created for free by volunteers. If you are at all knowledgeable about any aspect of GTK that does not already have documentation, please consider contributing to this document.\n Credits  We would like to thank the following for their contributions to this text.\n Tutorial copyright and permissions notice    "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/contextdependentprecedence/",
	"title": "Context-Dependent Precedence",
	"tags": [],
	"description": "Often the precedence of an operator depends on the context.",
	"content": "Often the precedence of an operator depends on the context. This sounds outlandish at first, but it is really very common. For example, a minus sign typically has a very high precedence as a unary operator, and a somewhat lower precedence (lower than multiplication) as a binary operator.\nThe Ocamlyacc precedence declarations, %left, %right and %nonassoc, can only be used once for a given token; so a token has only one precedence declared in this way. For context-dependent precedence, you need to use an additional mechanism: the %prec modifier for rules.\nThe %prec modifier declares the precedence of a particular rule by specifying a terminal symbol whose precedence should be used for that rule. It\u0026rsquo;s not necessary for that symbol to appear otherwise in the rule. The modifier\u0026rsquo;s syntax is:\n%prec terminal-symbol\nand it is written after the components of the rule. Its effect is to assign the rule the precedence of terminal-symbol, overriding the precedence that would be deduced for it in the ordinary way. The altered rule precedence then affects how conflicts involving that rule are resolved (see Operator Precedence).\nHere is how %prec solves the problem of unary minus. First, declare a precedence for a fictitious terminal symbol named UMINUS. There are no tokens of this type, but the symbol serves to stand for its precedence:\n... %left PLUS MINUS %left MULTIPLY %left UMINUS Now the precedence of UMINUS can be used in specific rules: exp: ... | exp MINUS exp ... | MINUS exp %prec UMINUS  "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/events/",
	"title": "Events",
	"tags": [],
	"description": "There is a set of events that reflect the Window event mechanism.",
	"content": "In addition to the signal mechanism described above, there is a set of events that reflect the Window event mechanism. Callbacks may also be attached to these events. These events are: (see event_signals)\n any button_press button_release scroll motion_notify delete destroy expose key_press key_release enter_notify leave_notify configure focus_in focus_out map unmap property_notify selection_clear selection_request selection_notify proximity_in proximity_out visibility_notify client no_expose window_state  In order to connect a callback function to one of these events you use the #event#connect method, using one of the above event names as the event_signal_name like this:\nwidget#event#connect#event_signal_name ~callback:(event -\u0026gt; bool) -\u0026gt; GtkSignal.id The callback function for events has a slightly different form than that for signals as you can see.\nThe argument of the callback function event may have various type which will depend upon which of the above events has occurred. The components of the event structure will depend upon the type of the event. The possible types of event are: (see event_signals)\nGtk.Tags.event_type Gdk.event [`DELETE] Gdk.event [`DESTROY] Gdk.event [`MAP] Gdk.event [`UNMAP] Gdk.event GdkEvent.Button.t GdkEvent.Crossing.t GdkEvent.Configure.t GdkEvent.Expose.t GdkEvent.Focus.t GdkEvent.Key.t GdkEvent.Motion.t GdkEvent.Proximity.t GdkEvent.Selection.t ... So, to connect a callback function to one of these events we would use something like:\nbutton#event#connect#button_press ~callback:button_pressed; This assumes that button is a Button widget. Now, when the mouse is over the button and a mouse button is pressed, the function button_pressed will be called. This function may be declared as:\nbutton_pressed (ev:GdkEvent.Button.t) = ... true (* or false *) Note that the argument has a type GdkEvent.Button.t as we know what type of event will occur for this function to be called.\nThe value returned from this function indicates whether the event should be propagated further by the GTK event handling mechanism. Returning true indicates that the event has been handled, and that it should not propagate further. Returning false continues the normal event handling. See the section on Advanced Event and Signal Handling for more details on this propagation process.\nFor details on the GdkEvent data types, see the appendix entitled GDK Event Types.\nThe GDK selection and drag-and-drop APIs also emit a number of events which are reflected in GTK by the signals. See Signals on the source widget and Signals on the destination widget for details on the signatures of the callback functions for these signals:\n #drag#connect#beginning #drag#connect#ending #drag#connect#data_delete #drag#connect#motion #drag#connect#drop #drag#connect#data_get #drag#connect#data_received   "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/",
	"title": "Grammar Files",
	"tags": [],
	"description": "Ocamlyacc takes as input a context-free grammar specification and produces a Ocaml-language function that recognizes correct instances of the grammar. The Ocamlyacc grammar input file conventionally has a name ending in .mly.",
	"content": "Ocamlyacc takes as input a context-free grammar specification and produces a Ocaml-language function that recognizes correct instances of the grammar. The Ocamlyacc grammar input file conventionally has a name ending in .mly. See Invoking Ocamlyacc.\n Grammar outline  A Ocamlyacc grammar file has four main sections, shown here with the appropriate delimiters:\n Symbols, Terminal and Nonterminal  Symbols in Ocamlyacc grammars represent the grammatical classifications of the language. A terminal symbol (also known as a token type) represents a class of syntactically equivalent tokens. A nonterminal symbol stands for a class of syntactically equivalent groupings.\n Syntax of grammar rules  A Ocamlyacc grammar rule has the following general form:\n Recursive Rules  A rule is called recursive when its result nonterminal appears also on its right hand side.\n Defineing Language Semantics  The grammar rules for a language determine only the syntax. The semantics are determined by the semantic values associated with various tokens and groupings, and by the actions taken when various groupings are recognized.\n Tracking Locations  Though grammar rules and semantic actions are enough to write a fully functional parser, it can be useful to process some additionnal informations, especially symbol locations.\n Nonterminal Symbols  The Ocamlyacc declarations section of a Ocamlyacc grammar defines the symbols used in formulating the grammar and the data types of semantic values. All token type must be declared. Nonterminal symbols must be declared if you need to specify which data type to use for the semantic value.\n Ocamlyacc Declarations  The Ocamlyacc declarations section of a Ocamlyacc grammar defines the symbols used in formulating the grammar and the data types of semantic values.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/rangewidgets/keymousebindings/",
	"title": "Key and mouse bindings",
	"tags": [],
	"description": "All of the GTK range widgets react to mouse clicks in more or less the same way.",
	"content": "All of the GTK range widgets react to mouse clicks in more or less the same way. Clicking button-1 in the trough will cause its adjustment\u0026rsquo;s page_increment to be added or subtracted from its value, and the slider to be moved accordingly. Clicking mouse button-2 in the trough will jump the slider to the point at which the button was clicked. Clicking button-3 in the trough of a range or any button on a scrollbar\u0026rsquo;s arrows will cause its adjustment\u0026rsquo;s value to change by step_increment at a time.\nScrollbars are not focusable, thus have no key bindings. The key bindings for the other range widgets (which are, of course, only active when the widget has focus) are do not differentiate between horizontal and vertical range widgets.\nAll range widgets can be operated with the left, right, up and down arrow keys, as well as with the Page Up and Page Down keys. The arrows move the slider up and down by step_increment, while Page Up and Page Down move it by page_increment.\nThe user can also move the slider all the way to one end or the other of the trough using the keyboard. This is done with the Home and End keys.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/layoutcontainer/",
	"title": "Layout container",
	"tags": [],
	"description": "The Layout container is similar to the Fixed container except that it implements an infinite (where infinity is less than 2^32) scrolling area.",
	"content": "The Layout container is similar to the Fixed container except that it implements an infinite (where infinity is less than 2^32) scrolling area. The X window system has a limitation where windows can be at most 32767 pixels wide or tall. The Layout container gets around this limitation by doing some exotic stuff using window and bit gravities, so that you can have smooth scrolling even when you have many child widgets in your scrolling area.\nA Layout container is created using GPack.layout:\nval GPack.layout : ?hadjustment:GData.adjustment -\u0026gt; ?vadjustment:GData.adjustment -\u0026gt; ?layout_width:int -\u0026gt; ?layout_height:int -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; layout As you can see, you can optionally specify the Adjustment objects that the Layout widget will use for its scrolling.\nYou can add and move widgets in the Layout container using the following two functions:\nmethod move : GObj.widget -\u0026gt; x:int -\u0026gt; y:int -\u0026gt; unit method put : GObj.widget -\u0026gt; x:int -\u0026gt; y:int -\u0026gt; unit The size of the Layout container can be set using the next functions:\nmethod set_height : int -\u0026gt; unit method set_width : int -\u0026gt; unit The final four functions for use with Layout widgets are for manipulating the horizontal and vertical adjustment widgets:\nmethod hadjustment : GData.adjustment method vadjustment : GData.adjustment method set_hadjustment : GData.adjustment -\u0026gt; unit method set_vadjustment : GData.adjustment -\u0026gt; unit"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/locationtrackingcalculator/",
	"title": "Location Tracking Calculator",
	"tags": [],
	"description": "Location Tracking Calculator: ltcalc",
	"content": "This example extends the infix notation calculator with location tracking. This feature will be used to improve the error messages. For the sake of clarity, this example is a simple integer calculator, since most of the work needed to use locations will be done in the lexical analyser.\n3.4.1. Declarations for ltcalc\nThe Ocaml and Ocamlyacc declarations for the location tracking calculator are the same as the declarations for the infix notation calculator except open Lexing.\n/* file: ltcalc.mly / / Location tracking calculator. */ %{ open Printf open Lexing %}\n/* Ocamlyacc Declarations */ %token NEWLINE %token LPAREN RPAREN %token  NUM %token PLUS MINUS MULTIPLY DIVIDE CARET\n%left PLUS MINUS %left MULTIPLY DIVIDE %left NEG /* negation \u0026ndash; unary minus / %right CARET / exponentiation */\n%start input %type  input\n/* Grammar follows */ %%\nNote there are no declarations specific to locations. Defining a data type for storing locations is not needed: we will use the type provided by default (see Data Type of Locations), which is a four member structure with the following fields:\ntype Lexing.position = { pos_fname : string; pos_lnum : int; pos_bol : int; pos_cnum : int; } 3.4.2. Grammar Rules for ltcalc\nWhether handling locations or not has no effect on the syntax of your language. Therefore, grammar rules for this example will be very close to those of the previous example: we will only modify them to benefit from the new information.\nHere, we will use locations to report divisions by zero, and locate the wrong expressions or subexpressions.\ninput: /* empty */ { } | input line { } ; line: NEWLINE { } | exp NEWLINE { Printf.printf \u0026ldquo;\\t%.10g\\n\u0026rdquo; $1; flush stdout } ; exp: NUM { $1 } | exp PLUS exp { $1 +. $3 } | exp MINUS exp { $1 -. $3 } | exp MULTIPLY exp { $1 *. $3 } | exp DIVIDE exp { if $3 \u0026lt;\u0026gt; 0.0 then $1 /. $3 else ( let start_pos = Parsing.rhs_start_pos 3 in let end_pos = Parsing.rhs_end_pos 3 in printf \u0026ldquo;%d.%d-%d.%d: division by zero\u0026rdquo; start_pos.pos_lnum (start_pos.pos_cnum - start_pos.pos_bol) end_pos.pos_lnum (end_pos.pos_cnum - end_pos.pos_bol); 1.0 ) } | MINUS exp %prec NEG { -. $2 } | exp CARET exp { $1 ** $3 } | LPAREN exp RPAREN { $2 } ;\nThis code shows how to reach locations inside of semantic actions. For rule components, use the following functions,\nval Parsing.rhs_start_pos : int -\u0026gt; Lexing.position val Parsing.rhs_end_pos : int -\u0026gt; Lexing.position\nwhere the integer parameter says the position of the components on the right-hand side of the rule. It is 1 for the leftmost component.\nFor groupings, use the following functions.\nval Parsing.symbol_start_pos : unit -\u0026gt; Lexing.position val Parsing.symbol_end_pos : unit -\u0026gt; Lexing.position\nWe don\u0026rsquo;t need to calculate the values of the position: the output parser does it automatically. symbol_start_pos is set to the beginning of the leftmost component, and symbol_end_pos to the end of the rightmost component.\n3.4.3. The \u0026ldquo;ltcalc\u0026rdquo; Lexical Analyzer\nUntil now, we relied on Ocamlyacc\u0026rsquo;s defaults to enable location tracking. The next step is to rewrite the lexical analyser, and make it able to feed the parser with the token locations, as it already does for semantic values.\nTo this end, we must take into account every single character of the input text, to avoid the computed locations of being fuzzy or wrong. lexbuf.lex_curr_p.pos_cnum is updated automatically for scanning a character by the lexer engine, so you have to update only lexbuf.lex_curr_p.pos_lnum and lexbuf.lex_curr_p.pos_bol.\n(* file: lexer.mll ) ( Lexical analyzer returns one of the tokens: the token NUM of a floating point number, operators (PLUS, MINUS, MULTIPLY, DIVIDE, CARET, UMINUS), or NEWLINE. It skips all blanks and tabs, and unknown characters and raises End_of_file on EOF. *)\n{ open Ltcalc open Lexing let incr_lineno lexbuf = let pos = lexbuf.lex_curr_p in lexbuf.lex_curr_p \u0026lt;- { pos with pos_lnum = pos.pos_lnum + 1; pos_bol = pos.pos_cnum; } } let digit = [\u0026lsquo;0\u0026rsquo;-\u0026lsquo;9\u0026rsquo;] rule token = parse | [\u0026rsquo; \u0026lsquo; \u0026lsquo;\\t\u0026rsquo;] { token lexbuf } | \u0026lsquo;\\n\u0026rsquo; { incr_lineno lexbuf; NEWLINE } | digit+ | \u0026ldquo;.\u0026rdquo; digit+ | digit+ \u0026ldquo;.\u0026rdquo; digit* as num { NUM (float_of_string num) } | \u0026lsquo;+\u0026rsquo; { PLUS } | \u0026lsquo;-\u0026rsquo; { MINUS } | \u0026lsquo;*\u0026rsquo; { MULTIPLY } | \u0026lsquo;/\u0026rsquo; { DIVIDE } | \u0026lsquo;^\u0026rsquo; { CARET } | \u0026lsquo;(\u0026rsquo; { LPAREN } | \u0026lsquo;)\u0026rsquo; { RPAREN } | _ { token lexbuf } | eof { raise End_of_file }\nBasically, the lexical analyzer performs the same processing as before: it skips blanks and tabs, and reads numbers, operators or delimiters. In addition, it updates lexbuf.lex_curr_p containing the token\u0026rsquo;s location.\nNow, each time this function returns a token, the parser has its number as well as its semantic value, and its location in the text.\nRemember that computing locations is not a matter of syntax. Every character must be associated to a location update, whether it is in valid input, in comments, in literal strings, and so on.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/packingwidgets/packingusingtables/",
	"title": "Packing using tables",
	"tags": [],
	"description": "Another way of packing - Tables.",
	"content": "Let\u0026rsquo;s take a look at another way of packing - Tables. These can be extremely useful in certain situations.\nUsing tables, we create a grid that we can place widgets in. The widgets may take up as many spaces as we specify.\nThe first thing to look at, of course, is the GPack.table function:\nval GPack.table : ?columns:int -\u0026gt; ?rows:int -\u0026gt; ?homogeneous:bool -\u0026gt; ?row_spacings:int -\u0026gt; ?col_spacings:int -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; table The ?rows specifies the number of rows to make in the table, while the ?columns, obviously, is the number of columns.\nThe ?homogeneous argument has to do with how the table\u0026rsquo;s boxes are sized. If homogeneous is true, the table boxes are resized to the size of the largest widget in the table. If homogeneous is false, the size of a table boxes is dictated by the tallest widget in its same row, and the widest widget in its column.\nThe rows and columns are laid out from 0 to n, where n was the number specified in the call to GPack.table. So, if you specify rows = 2 and columns = 2, the layout would look something like this:\n0 1 2 0+----------+----------+ | | | 1+----------+----------+ | | | 2+----------+----------+ Note that the coordinate system starts in the upper left hand corner. To place a widget into a box, use the following function:\nmethod attach : left:int -\u0026gt; top:int -\u0026gt; ?right:int -\u0026gt; ?bottom:int -\u0026gt; ?expand:Gtk.Tags.expand_type -\u0026gt; ?fill:Gtk.Tags.expand_type -\u0026gt; ?shrink:Gtk.Tags.expand_type -\u0026gt; ?xpadding:int -\u0026gt; ?ypadding:int -\u0026gt; GObj.widget -\u0026gt; unit left : column number to attach the left side of the widget to top : row number to attach the top of the widget to right : default value is left+1 bottom : default value is top+1 expand : default value is `NONE fill : default value is `BOTH shrink : default value is `NONE The left and right attach arguments specify where to place the widget, and how many boxes to use. If you want a button in the lower right table entry of our 2x2 table, and want it to fill that entry only, left would be = 1, right = 2, top = 1, bottom = 2.\nNow, if you wanted a widget to take up the whole top row of our 2x2 table, you\u0026rsquo;d use left = 0, right = 2, top = 0, bottom = 1.\nThe other options are:\n ?fill: If the table box is larger than the widget, and ?fill is specified, the widget will expand to use all the room available.\n ?shrink: If the table widget was allocated less space then was requested (usually by the user resizing the window), then the widgets would normally just be pushed off the bottom of the window and disappear. If ?shrink is specified, the widgets will shrink with the table.\n ?expand: This will cause the table to expand to use up any remaining space in the window.\n  Padding is just like in boxes, creating a clear area around the widget specified in pixels.\nWe also have set_row_spacing and set_col_spacing meethods. These places spacing between the rows at the specified row or column.\nmethod set_row_spacing : int -\u0026gt; int -\u0026gt; unit and\nmethod set_col_spacing : int -\u0026gt; int -\u0026gt; unit Note that for columns, the space goes to the right of the column, and for rows, the space goes below the row.\nYou can also set a consistent spacing of all rows and/or columns with:\nmethod set_row_spacings : int -\u0026gt; unit And,\nmethod set_col_spacings : int -\u0026gt; unit Note that with these calls, the last row and last column do not get any spacing.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/packingwidgets/",
	"title": "Packing widgets",
	"tags": [],
	"description": "When creating an application, you&#39;ll want to put more than one widget inside a window.",
	"content": "When creating an application, you\u0026rsquo;ll want to put more than one widget inside a window. Our first helloworld example only used one widget so we could simply use a #add (or #pack) method call to \u0026ldquo;pack\u0026rdquo; the widget into the window. But when you want to put more than one widget into a window, how do you control where that widget is positioned? This is where packing comes in.\n Theory of packing boxes  Most packing is done by creating boxes.\n Details of boxes  Because of this flexibility, packing boxes in GTK can be confusing at first.\n Packing demonstration program  Packing demonstration program\n Packing using tables  Another way of packing - Tables.\n Table packing example  A window with three buttons in a 2x2 table.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/progressbar/",
	"title": "Progress bars",
	"tags": [],
	"description": "Progress bars are used to show the status of an operation.",
	"content": "Progress bars are used to show the status of an operation. They are pretty easy to use, as you will see with the code below. But first lets start out with the calls to create a new progress bar using GRange.progress_bar.\nval GRange.progress_bar: ?orientation:Gtk.Tags.progress_bar_orientation -\u0026gt; ?pulse_step:float -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; progress_bar orientation : default value is `LEFT_TO_RIGHT pulse_step : default value is 0.1 Now that the progress bar has been created we can use it.\nmethod set_fraction : float -\u0026gt; unit The argument is the amount \u0026ldquo;completed\u0026rdquo;, meaning the amount the progress bar has been filled from 0-100%. This is passed to the method as a float number ranging from 0.0 to 1.0\nGTK v1.2 has added new functionality to the progress bar that enables it to display its value in different ways, and to inform the user of its current value and its range.\nA progress bar may be set to one of a number of orientations using the function\nmethod set_orientation : Gtk.Tags.progress_bar_orientation -\u0026gt; unit The orientation argument may take one of the following values to indicate the direction in which the progress bar moves:\n`LEFT_TO_RIGHT `RIGHT_TO_LEFT `BOTTOM_TO_TOP `TOP_TO_BOTTOM As well as indicating the amount of progress that has occured, the progress bar may be set to just indicate that there is some activity. This can be useful in situations where progress cannot be measured against a value range. The following function indicates that some progress has been made.\nmethod pulse : unit -\u0026gt; unit The step size of the activity indicator is set using the following function.\nmethod set_pulse_step : float -\u0026gt; unit When not in activity mode, the progress bar can also display a configurable text string within its trough, using the following function.\nmethod set_text : string -\u0026gt; unit You can turn off the display of the string by calling set_text method again with empty string as an argument.\nThe current text setting of a progressbar can be retrieved with the following function.\nmethod text : string Progress Bars are usually used with timeouts or other such functions (see section on Timeouts and Idle Functions) to give the illusion of multitasking. All will employ the set_fraction or pulse methods in the same manner.\nHere is an example of the progress bar, updated using timeouts. This code also shows you how to reset the Progress Bar.\n(* file: progressbar.ml *) let pulse_mode = ref false (* Update the value of the progress bar so that we get * some movement *) let progress_timeout pbar () = if !pulse_mode then pbar#pulse () else ( (* Calculate the value of the progress bar using the * value range set in the adjustment object *) let new_val = let v = pbar#fraction +. 0.01 in if v \u0026gt; 1.0 then 0.0 else v in pbar#set_fraction new_val ); (* As this is a timeout function, return true so that it * continues to get called *) true (* Callback that toggles the text display with the progress bar trough *) let toggle_show_text pbar () = let text = pbar#text in if text = \u0026#34;\u0026#34; then pbar#set_text \u0026#34;some text\u0026#34; else pbar#set_text \u0026#34;\u0026#34; (* Callback that toggles the activity mode of the progress bar *) let toggle_activity_mode pbar () = pulse_mode := not !pulse_mode; if !pulse_mode then pbar#pulse () else pbar#set_fraction 0.0 (* Callback that toggles the orientation of the progress bar *) let toggle_orientation pbar () = match pbar#orientation with | `LEFT_TO_RIGHT -\u0026gt; pbar#set_orientation `RIGHT_TO_LEFT | `RIGHT_TO_LEFT -\u0026gt; pbar#set_orientation `LEFT_TO_RIGHT | _ -\u0026gt; () (* Remove timer and quit *) let destroy_progress timer () = GMain.Timeout.remove timer; GMain.Main.quit () let main () = let window = GWindow.window ~title:\u0026#34;ProgressBar\u0026#34; () in let vbox = GPack.vbox ~border_width:10 ~packing:window#add () in (* Create a centering alignment object *) let align = GBin.alignment ~xalign:0.5 ~yalign:0.5 ~xscale:0.0 ~yscale:0.0 ~packing:vbox#add () in (* Create the progressbar *) let pbar = GRange.progress_bar ~packing:align#add () in (* Add a timer callback to update the value of the progress bar *) let timer = GMain.Timeout.add ~ms:100 ~callback:(progress_timeout pbar) in GMisc.separator `HORIZONTAL ~packing:vbox#add (); let table = GPack.table ~rows:3 ~columns:1 ~homogeneous:false ~packing:vbox#add () in (* Add a check button to select displaying of trough text *) let check = GButton.check_button ~label:\u0026#34;Show text\u0026#34; ~packing:(table#attach ~left:0 ~top:0) () in check#connect#clicked ~callback:(toggle_show_text pbar); (* Add a check button to toggle activity mode *) let check = GButton.check_button ~label:\u0026#34;Activity mode\u0026#34; ~packing:(table#attach ~left:0 ~top:1) () in check#connect#clicked ~callback:(toggle_activity_mode pbar); (* Add a check button to toggle orientation *) let check = GButton.check_button ~label:\u0026#34;Right to Left\u0026#34; ~packing:(table#attach ~left:0 ~top:2) () in check#connect#clicked ~callback:(toggle_orientation pbar); (* Add a buton to exit the program *) let button = GButton.button ~label:\u0026#34;Close\u0026#34; ~packing:vbox#add () in button#connect#clicked ~callback:(destroy_progress timer); window#connect#destroy ~callback:(destroy_progress timer); window#show (); GMain.Main.main () let _ = main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/buttonwidget/radiobuttons/",
	"title": "Radio buttons",
	"tags": [],
	"description": "Check buttons inherit many properties and functions from the the toggle buttons.",
	"content": "Radio buttons are similar to check buttons except they are grouped so that only one may be selected/depressed at a time. This is good for places in your application where you need to select from a short list of options.\nCreating a new radio button is done with one of these calls; see GButton.radio_button:\nval GButton.radio_button : ?group:Gtk.radio_button Gtk.group -\u0026gt; ?label:string -\u0026gt; ?use_mnemonic:bool -\u0026gt; ?stock:GtkStock.id -\u0026gt; ?relief:Gtk.Tags.relief_style -\u0026gt; ?active:bool -\u0026gt; ?draw_indicator:bool -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; radio_button You\u0026rsquo;ll notice the extra argument to these calls. They require a group to perform their duty properly. The first call to radio_button should not pass the ~group argument. Then create a group using:\nmethod group : Gtk.radio_button Gtk.group The important thing to remember is that group method must be called for each new button added to the group. The result is then passed into the next call to radio_button. This allows a chain of buttons to be established. The example below should make this clear.\nYou can shorten this slightly by using the following syntax, which removes the need for a variable to hold the list of buttons:\nlet button2 = GButton.radio_button ~label:\u0026#34;button2\u0026#34; ~group:button1#group () in It is also a good idea to explicitly set which button should be the default depressed button with:\nmethod set_active : bool -\u0026gt; unit This is described in the section on toggle buttons, and works in exactly the same way. Once the radio buttons are grouped together, only one of the group may be active at a time. If the user clicks on one radio button, and then on another, the first radio button will first emit a \u0026ldquo;toggled\u0026rdquo; signal (to report becoming inactive), and then the second will emit its \u0026ldquo;toggled\u0026rdquo; signal (to report becoming active).\nThe following example creates a radio button group with three buttons.\n(* file: radiobutton.ml *) open GMain let main () = let window = GWindow.window ~title:\u0026#34;radio buttons\u0026#34; ~border_width:0 () in window#connect#destroy ~callback:Main.quit; let box1 = GPack.vbox ~packing:window#add () in let box2 = GPack.vbox ~spacing:10 ~border_width:10 ~packing:box1#add () in let button1 = GButton.radio_button ~label:\u0026#34;button1\u0026#34; ~packing:box2#add () in let button2 = GButton.radio_button ~group:button1#group ~label:\u0026#34;button2\u0026#34; ~active:true ~packing:box2#add () in let button3 = GButton.radio_button ~group:button1#group ~label:\u0026#34;button3\u0026#34; ~packing:box2#add () in let separator = GMisc.separator `HORIZONTAL ~packing: box1#pack () in let box3 = GPack.vbox ~spacing:10 ~border_width:10 ~packing:box1#pack () in let button = GButton.button ~label:\u0026#34;close\u0026#34; ~packing:box3#add () in button#connect#clicked ~callback:Main.quit; button#grab_default (); window#show (); Main.main () let _ = main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/recursiverules/",
	"title": "Recursive Rules",
	"tags": [],
	"description": "A rule is called recursive when its result nonterminal appears also on its right hand side.",
	"content": "A rule is called recursive when its result nonterminal appears also on its right hand side. Nearly all Ocamlyacc grammars need to use recursion, because that is the only way to define a sequence of any number of a particular thing. Consider this recursive definition of a comma-separated sequence of one or more expressions:\nexpseq1: exp\t{} | expseq1 COMMA exp\t{} ;  Since the recursive use of expseq1 is the leftmost symbol in the right hand side, we call this left recursion. By contrast, here the same construct is defined using right recursion:\nexpseq1: exp\t{} | exp COMMA expseq1\t{} ;  Any kind of sequence can be defined using either left recursion or right recursion, but you should always use left recursion, because it can parse a sequence of any number of elements with bounded stack space. Right recursion uses up space on the Ocamlyacc stack in proportion to the number of elements in the sequence, because all the elements must be shifted onto the stack before the rule can be applied even once. See The Ocamyacc Parser Algorithm, for further explanation of this.\nIndirect or mutual recursion occurs when the result of the rule does not appear directly on its right hand side, but does appear in rules for other nonterminals which do appear on its right hand side.\nFor example:\nexpr: primary\t{} | primary PLUS primary\t{} ; primary: constant\t{} | LPAREN expr RPAREN\t{} ;  defines two mutually-recursive nonterminals, since each refers to the other.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/semanticactions/",
	"title": "Semantic actions",
	"tags": [],
	"description": "A grammar rule can have an action made up of Ocaml statements. Each time the parser recognizes a match for that rule, the action is executed.",
	"content": "In order to be useful, a program must do more than parse input; it must also produce some output based on the input. In a Ocamlyacc grammar, a grammar rule can have an action made up of Ocaml statements. Each time the parser recognizes a match for that rule, the action is executed. See Actions,\nMost of the time, the purpose of an action is to compute the semantic value of the whole construct from the semantic values of its parts. For example, suppose we have a rule which says an expression can be the sum of two expressions. When the parser recognizes such a sum, each of the subexpressions has a semantic value which describes how it was built up. The action for this rule should create a similar sort of value for the newly recognized larger expression.\nFor example, here is a rule that says an expression can be the sum of two subexpressions:\nexpr: expr PLUS expr { $1 + $3 } ;  The action says how to produce the semantic value of the sum expression from the values of the two subexpressions.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/widgetoverview/structureofwidgets/",
	"title": "Structure of widgets",
	"tags": [],
	"description": "Structure of widgets",
	"content": "The following modules provide classes to wrap the raw Gtk+ function calls. Here are the widget classes contained in each module:\n GPango: Pango font handling Gdk: pixmaps, etc\u0026hellip; GObj: gtkobj, widget, style GData: data, adjustment, tooltips GContainer: container, item_container GWindow: window, dialog, color_selection_dialog, file_selection, plug GPack: box, button_box, table, fixed, layout, packer, paned, notebook GBin: scrolled_window, event_box, handle_box, frame, aspect_frame, viewport, socket GButton: button, toggle_button, check_button, radio_button, toolbar GMenu: menu_item, tearoff_item, check_menu_item, radio_menu_item, menu_shell, menu, option_menu, menu_bar, factory GMisc: separator, statusbar, calendar, drawing_area, misc, arrow, image, pixmap, label, tips_query, color_selection, font_selection GTree: tree_item, tree, view (also tree/list_store, model) GList: list_item, liste, clist GEdit: editable, entry, spin_button, combo GRange: progress, progress_bar, range, scale, scrollbar GText: view (also buffer, iter, mark, tag, tagtable)  Practically, each widget class is composed of:\n coerce method, returning the object coerced to the type widget. as_widget method, returning the raw Gtk widget used for packing, etc\u0026hellip; destroy method, sending the destroy signal to the object. get_oid method, the equivalent of Oo.id for Gtk objects. connect sub-object, allowing one to widget specific signals (this is what prevents width subtyping in subclasses.) misc sub-object, giving access to miscellanous functionality of the basic gtkwidget class, and a misc#connect sub-object. event sub-object, for Xevent related functions (only if the widget has an Xwindow), and an event#connect sub-object. drag sub-object, containing drag and drop functions, and a drag#connect sub-object. widget specific methods.  Here is a diagram of the structure (- for methods, + for sub-objects)\n- coerce : widget - as_widget : Gtk.widget obj - destroy : unit -\u0026gt; unit - get_oid : int - ... + connect : mywidget_signals | - after | - signal_name : callback:(... -\u0026gt; ...) -\u0026gt; GtkSignal.id + misc : misc_ops | - show, hide, disconnect, ... | + connect : misc_signals + drag : drag_ops | - ... | + connect : drag_signals + event : event_ops | - add, ... | + connect : event_signals"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-treeview-tutorial/",
	"title": "lablgtk2 treeview tutorial",
	"tags": [],
	"description": "Under construction",
	"content": "This is a tutorial on how to use GTK+ 2.0 Gtk TreeView widget in Ocaml language.\nThe LablGtk version used here is LablGTK 2.4.0.\nThis tutorial is adapted from the original C language version written by Tim-Philipp Muller.\nPlease mail all comments and suggestions about Ocaml adaptation to me.\nThe examples referenced in this document can be found here.\nThis document is under construction and you can find the latest version here.\nFirst revision: 2004-09-18\nLast updated: 2019-05-05\nThis page is under construction.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/definesemantics/",
	"title": "Defineing Language Semantics",
	"tags": [],
	"description": "The grammar rules for a language determine only the syntax. The semantics are determined by the semantic values associated with various tokens and groupings, and by the actions taken when various groupings are recognized.",
	"content": " The grammar rules for a language determine only the syntax. The semantics are determined by the semantic values associated with various tokens and groupings, and by the actions taken when various groupings are recognized.\nFor example, the calculator calculates properly because the value associated with each expression is the proper number; it adds properly because the action for the grouping x + y is to add the numbers associated with x and y.\nData Types of Semantic Values In a simple program it may be sufficient to use the same data type for the semantic values of all language constructs. But in most programs, you will need different data types for different kinds of tokens and groupings. For example, a numeric constant may need type int or float, while a string constant or an identifier might need type string.\nTo use more than one data type for semantic values in one parser, Ocamlyacc requires you to do: Choose one of those types for each symbol (terminal or nonterminal) for which semantic values are used. This is done for tokens with the %token Ocamlyacc declaration (see Token Type Names) and for groupings with the %type Ocamlyacc declaration (see Nonterminal Symbols).\nActions An action accompanies a syntactic rule and contains Ocaml code to be executed each time an instance of that rule is recognized. The task of most actions is to compute a semantic value for the grouping built by the rule from the semantic values associated with tokens or smaller groupings.\nAn action consists of Ocaml statements surrounded by braces. All rules have just one action at the end of the rule, following all the components.\nThe Ocaml code in an action can refer to the semantic values of the components matched by the rule with the construct $n, which stands for the value of the nth component. The value of the evaluation of the action is the value for the grouping being constructed.\nHere is a typical example:\nexp: ... | exp PLUS exp { $1 +. $3 }  This rule constructs an exp from two smaller exp groupings connected by a plus-sign token. In the action, $1 and $3 refer to the semantic values of the two component exp groupings, which are the first and third symbols on the right hand side of the rule. The sum is returned so that it becomes the semantic value of the addition-expression just recognized by the rule. If there were a useful semantic value associated with the PLUS token, it could be referred to as \u0026lsquo;$2.\u0026rsquo;\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/dialogs/",
	"title": "Dialog widgets",
	"tags": [],
	"description": "The Dialog widget is very simple, and is actually just a window with a few things pre-packed into it for you.",
	"content": "The Dialog widget is very simple, and is actually just a window with a few things pre-packed into it for you.\nIt simply creates a window, and then packs a vbox into the top, which contains a separator and then an hbox called the \u0026ldquo;action_area\u0026rdquo;. After creating a dialog, you can reference the vbox and the action_area using the following methods:\nmethod vbox : GPack.box method action_area : GPack.button_box The Dialog widget can be used for pop-up messages to the user, and other similar tasks. GWindow.dialog is the function which creates a new Dialog.\nval GWindow.dialog: ?no_separator:bool -\u0026gt; ?parent:#window_skel -\u0026gt; ?destroy_with_parent:bool -\u0026gt; ?title:string -\u0026gt; ?allow_grow:bool -\u0026gt; ?allow_shrink:bool -\u0026gt; ?icon:GdkPixbuf.pixbuf -\u0026gt; ?modal:bool -\u0026gt; ?resizable:bool -\u0026gt; ?screen:Gdk.screen -\u0026gt; ?type_hint:Gdk.Tags.window_type_hint -\u0026gt; ?position:Gtk.Tags.window_position -\u0026gt; ?wm_name:string -\u0026gt; ?wm_class:string -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; [\u0026gt; `DELETE_EVENT ] dialog no_separator : default value is false destroy_with_parent : default value is false This function will create an empty dialog, and it is now up to you to use it. You could pack a button in the action_area by doing something like this:\nlet w = GWindow.dialog ... () in let button = GButton.button ... ~packing:w#action_area#add () in And you could add to the vbox area by packing, for instance, a label in it, try something like this:\nlet w = GWindow.dialog ... () in let label = GMisc.label ~text:\u0026#34;Dialogs are groovy\u0026#34; ~packing:w#vbox#add () in As an example in using the dialog box, you could put two buttons in the action_area, a Cancel button and an Ok button, and a label in the vbox area, asking the user a question or giving an error etc. Then you could attach a different signal to each of the buttons and perform the operation the user selects.\nIf the simple functionality provided by the default vertical and horizontal boxes in the two areas doesn\u0026rsquo;t give you enough control for your application, then you can simply pack another layout widget into the boxes provided. For example, you could pack a table into the vertical box.\nThe optional arguments allows to set one or more of the following flags.\n ?modal: make the dialog modal.\n ?destroy_with_parent: ensures that the dialog window is destroyed together with the parent.\n ?no_separator: omits the separator between the vbox and the action_area.\n  "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/rangewidgets/example/",
	"title": "Example",
	"tags": [],
	"description": "All of the GTK range widgets react to mouse clicks in more or less the same way.",
	"content": "It basically puts up a window with three range widgets all connected to the same adjustment, and a couple of controls for adjusting some of the parameters mentioned above and in the section on adjustments, so you can see how they affect the way these widgets work for the user.\n(* file: range.ml *) let cb_pos_menu_select hscale vscale pos () = hscale#set_value_pos pos; vscale#set_value_pos pos let cb_update_menu_select hscale vscale policy () = hscale#set_update_policy policy; vscale#set_update_policy policy let cb_digits_scale hscale vscale adj () = hscale#set_digits (int_of_float adj#value); vscale#set_digits (int_of_float adj#value) let clamp x low high = if x \u0026gt; high then high else if x \u0026lt; low then low else x let cb_page_size get (set: GData.adjustment) () = (* Set the page size and page increment size of the sample * adjustment to the value specified by the \u0026#34;Page Size\u0026#34; scale *) let v = get#value in set#set_bounds ~page_incr:v ~page_size:v (); (* This sets the adjustment and makes it emit the \u0026#34;chagnged\u0026#34; signal to * reconfigure all the widgets that are attatched to this signal. *) set#set_value (clamp set#value set#lower (set#upper -. set#page_size)) let cb_draw_value button hscale vscale () = hscale#set_draw_value button#active; vscale#set_draw_value button#active let make_menu_item ~label ~packing ~callback = let item = GMenu.menu_item ~label ~packing () in ignore (item#connect#activate ~callback) let create_range_controls () = (* Standard window-creating stuff *) let window = GWindow.window ~title:\u0026#34;Range controls\u0026#34; ~border_width:20 () in window#connect#destroy ~callback:GMain.Main.quit; let box1 = GPack.vbox ~packing:window#add () in let box2 = GPack.hbox ~border_width:10 ~packing:box1#add () in (* Note that the page_size value only makes a difference for * scrollbar widgets, and the highest value you\u0026#39;ll get is actually * (upper - page_size). *) let adj1 = GData.adjustment ~value:0.0 ~lower:0.0 ~upper:101.0 ~step_incr:0.1 ~page_incr:1.0 ~page_size:1.0 () in let vscale = GRange.scale `VERTICAL ~adjustment:adj1 ~packing:box2#add () in let box3 = GPack.vbox ~packing:box2#add () in (* Reuse the same adjustment *) let hscale = GRange.scale `HORIZONTAL ~adjustment:adj1 ~packing:box3#add () in (* Reuse the same adjustment again. * Default update_policy is `CONTINUOUS. * Notice the scales always be updated continuously * when the scrollbar is moved *) let scrollbar = GRange.scrollbar `HORIZONTAL ~adjustment:adj1 ~packing:box3#add () in let box2 = GPack.hbox ~border_width:10 ~packing:box1#add () in (* A checkbutton to control whether the value is displayed or not *) let button = GButton.check_button ~label:\u0026#34;Display value on scale widgets\u0026#34; ~active:true ~packing:box2#add () in button#connect#toggled ~callback:(cb_draw_value button hscale vscale); let box2 = GPack.hbox ~border_width:10 ~packing:box1#add () in let label = GMisc.label ~text:\u0026#34;Scale Value Position:\u0026#34; ~packing:box2#add () in let opt = GMenu.option_menu ~packing:box2#add () in let menu = GMenu.menu ~packing:opt#set_menu () in let f (label, pos) = make_menu_item ~label ~packing:menu#append ~callback:(cb_pos_menu_select hscale vscale pos) in List.iter f [(\u0026#34;Top\u0026#34;, `TOP); (\u0026#34;Bottom\u0026#34;, `BOTTOM); (\u0026#34;Left\u0026#34;, `LEFT); (\u0026#34;Right\u0026#34;, `RIGHT)]; let box2 = GPack.hbox ~border_width:10 ~packing:box1#add () in (* Yet another option menu, this time for the update policy of the * scale widgets *) let label = GMisc.label ~text:\u0026#34;Scale Update Policy:\u0026#34; ~packing:box2#add () in let opt = GMenu.option_menu ~packing:box2#add () in let menu = GMenu.menu ~packing:opt#set_menu () in let f (label, policy) = make_menu_item ~label ~packing:menu#append ~callback:(cb_update_menu_select hscale vscale policy) in List.iter f [(\u0026#34;Continuous\u0026#34;, `CONTINUOUS); (\u0026#34;Discontinuous\u0026#34;, `DISCONTINUOUS); (\u0026#34;Delayed\u0026#34;, `DELAYED)]; let box2 = GPack.hbox ~border_width:10 ~packing:box1#add () in let label = GMisc.label ~text:\u0026#34;Scale Digits:\u0026#34; ~packing:box2#add () in let adj2 = GData.adjustment ~value:1.0 ~lower:0.0 ~upper:5.0 ~step_incr:1.0 ~page_incr:1.0 ~page_size:0.0 () in adj2#connect#value_changed ~callback:(cb_digits_scale hscale vscale adj2); let scale = GRange.scale `HORIZONTAL ~adjustment:adj2 ~digits:0 ~packing:box2#add () in let box2 = GPack.hbox ~border_width:10 ~packing:box1#add () in (* And, one last Horizontal Scale widget for adjusting the page size of the * scrollbar *) let label = GMisc.label ~text:\u0026#34;Scrollbar Page Size:\u0026#34; ~packing:box2#add () in let adj2 = GData.adjustment ~value:1.0 ~lower:0.0 ~upper:101.0 ~step_incr:1.0 ~page_incr:1.0 ~page_size:0.0 () in adj2#connect#value_changed ~callback:(cb_page_size adj2 adj1); let scale = GRange.scale `HORIZONTAL ~adjustment:adj2 ~digits:0 ~packing:box2#add () in let separator = GMisc.separator `HORIZONTAL ~packing:box1#add () in let box2 = GPack.hbox ~border_width:10 ~packing:box1#add () in let button = GButton.button ~label:\u0026#34;Quit\u0026#34; ~packing:box2#add () in button#connect#clicked ~callback:GMain.quit; button#misc#set_can_default true; button#misc#grab_default (); window#show () let main () = create_range_controls (); GMain.Main.main () let _ = Printexc.print main () You will notice that the program does not call connect() for the \u0026ldquo;delete_event\u0026rdquo;, but only for the \u0026ldquo;destroy\u0026rdquo; signal. This will still perform the desired function, because an unhandled \u0026ldquo;delete_event\u0026rdquo; will result in a \u0026ldquo;destroy\u0026rdquo; signal being given to the window.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/frames/",
	"title": "Frames",
	"tags": [],
	"description": "Frames can be used to enclose one or a group of widgets with a box which can optionally be labelled.",
	"content": "Frames can be used to enclose one or a group of widgets with a box which can optionally be labelled. The position of the label and the style of the box can be altered to suit.\nA Frame can be created with the function GBin.frame :\nval frame : ?label:string -\u0026gt; ?label_xalign:Gtk.clampf -\u0026gt; ?label_yalign:Gtk.clampf -\u0026gt; ?shadow_type:Gtk.Tags.shadow_type -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; frame The label is by default placed in the upper left hand corner of the frame. A value of NULL for the label argument will result in no label being displayed. The text of the label can be changed using the next function.\nmethod set_label : string option -\u0026gt; unit The position of the label can be changed using these functions:\nmethod set_label_xalign : float -\u0026gt; unit method set_label_yalign : float -\u0026gt; unit xalign and yalign take values between 0.0 and 1.0. xalign indicates the position of the label along the top horizontal of the frame. yalign is not currently used. The default value of xalign is 0.0 which places the label at the left hand end of the frame.\nThe next function alters the style of the box that is used to outline the frame.\nmethod set_shadow_type : Gtk.Tags.shadow_type -\u0026gt; unit The type argument can take one of the following values:\n`NONE `IN `OUT `ETCHED_IN (the default) `ETCHED_OUT The following code example illustrates the use of the Frame widget.\n(* file: frame.ml *) let main () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Frame Example\u0026#34; ~width:300 ~height:300 ~border_width:10 () in (* Here we connect the \u0026#34;destroy\u0026#34; event to a signal handler *) window#connect#destroy ~callback:GMain.Main.quit; (* Create a Frame * Set the frame\u0026#39;s label * Align the label at the right of the frame * Set the style of the frame *) let frame = GBin.frame ~label:\u0026#34;Frame Widget\u0026#34; ~label_xalign:1.0 ~shadow_type:`ETCHED_OUT ~packing:window#add () in window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/locations/",
	"title": "Locations",
	"tags": [],
	"description": "Locations in order to keep track of the textual position, or location, of each syntactic construct.",
	"content": "Many applications, like interpreters or compilers, have to produce verbose and useful error messages. To achieve this, one must be able to keep track of the textual position, or location, of each syntactic construct. Ocamlyacc provides a mechanism for handling these locations.\nEach token has a semantic value. In a similar fashion, each token has an associated location, but the type of locations is the same for all tokens and groupings. Moreover, the output parser is equipped with a data structure for storing locations (see Locations, for more details).\nLike semantic values, locations can be reached in actions using functions of the Parsing module.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/examples/multifunctioncalculator/",
	"title": "Multi-Function Calculator",
	"tags": [],
	"description": "Multi-Function Calculator: mfcalc",
	"content": " Now that the basics of Ocamlyacc have been discussed, it is time to move on to a more advanced problem. The above calculators provided only five functions, +, -, *, / and ^. It would be nice to have a calculator that provides other mathematical functions such as sin, cos, etc.\nIn this example, we will show how to implement built-in functions whose syntax has this form:\nfunction_name (argument)  At the same time, we will add memory to the calculator, by allowing you to create named variables, store values in them, and use them later. Here is a sample session with the multi-function calculator:\n$ mfcalc pi = 3.14159265 3.1415927 sin(pi/2) 1 alpha = beta1 = 2.3 2.3 alpha 2.3 log(alpha) 0.83290912 exp(log(beta1)) 2.3 ^D $  Note that multiple assignment and nested function calls are permitted.\nDeclarations for mfcalc Here are the Ocaml and Ocamlyacc declarations for the multi-function calculator.\n/* file: mfcalc.mly */ %{ open Printf open Lexing let var_table = Hashtbl.create 16 %} /* Ocamlyacc Declarations */ %token NEWLINE %token LPAREN RPAREN EQ %token \u0026lt;float\u0026gt; NUM %token PLUS MINUS MULTIPLY DIVIDE CARET %token \u0026lt;string\u0026gt; VAR %token \u0026lt;float-\u0026gt;float\u0026gt; FNCT %left PLUS MINUS %left MULTIPLY DIVIDE %left NEG\t/* negation -- unary minus */ %right CARET\t/* exponentiation */ %start input %type \u0026lt;unit\u0026gt; input /* Grammar follows */ %%  Since values can have various types, it is necessary to associate a type with each grammar symbol whose semantic value is used. These symbols are NUM, VAR, FNCT, and exp. The declarations of terminals are augmented with information about their data type (placed between angle brackets).\nThe data type of non-terminal, exp, is nomally declared implicitly by the action.\nIn header section, a hash table called var_table is created for storing variable\u0026rsquo;s name and value. This will be used in the semantic action part. See The mfcalc Symbol Table.\nGrammar Rules for mfcalc Here are the grammar rules for the multi-function calculator. Most of them are copied directly from calc; three rules, those which mention VAR or FNCT, are new.\ninput:\t/* empty */\t{ } | input line\t{ } ; line:\tNEWLINE\t{ } | exp NEWLINE\t{ printf \u0026quot;\\t%.10g\\n\u0026quot; $1; flush stdout } | error NEWLINE\t{ } ; exp:\tNUM\t{ $1 } | VAR\t{ try Hashtbl.find var_table $1 with Not_found -\u0026gt; printf \u0026quot;no such variable '%s'\\n\u0026quot; $1; 0.0 } | VAR EQ exp\t{ Hashtbl.replace var_table $1 $3; $3 } | FNCT LPAREN exp RPAREN\t{ $1 $3 } | exp PLUS exp\t{ $1 +. $3 } | exp MINUS exp\t{ $1 -. $3 } | exp MULTIPLY exp\t{ $1 *. $3 } | exp DIVIDE exp\t{ $1 /. $3 } | MINUS exp %prec NEG\t{ -. $2 } | exp CARET exp\t{ $1 ** $3 } | LPAREN exp RPAREN\t{ $2 } ; %%  For the meaning of the semantic actions related with VAR, see The mfcalc Symbol Table.\nThe mfcalc Symbol Table The multi-function calculator requires a symbol table to keep track of the names and meanings of variables and functions. This doesn\u0026rsquo;t affect the grammar rules (except for the actions) or the Ocamlyacc declarations, but it requires some additional Ocaml functions for support.\nIn this example, we use two symbol tables: one for variables and one for functions. The variable symbol table is defined and used in parser and the function symbol table is defined and used in lexer.\nThe variable symbol table itself is implemented using the hash table. It has a key of string type and a value of float type.\nIt is a simple job to modify this code to install predefined variables such as pi or e as well.\nTwo important functions allow look-up and installation of symbols in the symbol table. The function Hashtbl.replace is passed a name and the value of the variable to be installed. The function Hashtbl.find is passed the name of the symbol to look up. If found, the value of that symbol is returned; otherwise zero is returned.\nThe lexical analyzer function must now recognize variables, numeric values, and the arithmetic operators. Strings of alphanumeric characters with a leading non-digit are recognized as either variables or functions depending on what the symbol table says about them.\nThe string is used for look up in the function symbol table. If the name appears in the table, the corresponding function is returned to the parser function as the value of FNCT. If it is not, VAR with the string is returned.\nNo change is needed in the handling of numeric values and arithmetic operators in the lexical analyzer function.\n(* file: lexer.mll *) { open Mfcalc open Lexing let create_hashtable size init = let tbl = Hashtbl.create size in List.iter (fun (key, data) -\u0026gt; Hashtbl.add tbl key data) init; tbl let fun_table = create_hashtable 16 [ (\u0026quot;sin\u0026quot;, sin); (\u0026quot;cos\u0026quot;, cos); (\u0026quot;tan\u0026quot;, tan); (\u0026quot;asin\u0026quot;, asin); (\u0026quot;acos\u0026quot;, acos); (\u0026quot;atan\u0026quot;, atan); (\u0026quot;log\u0026quot;, log); (\u0026quot;exp\u0026quot;, exp); (\u0026quot;sqrt\u0026quot;, sqrt); ] } let digit = ['0'-'9'] let ident = ['a'-'z' 'A'-'Z'] let ident_num = ['a'-'z' 'A'-'Z' '0'-'9'] rule token = parse | [' ' '\\t']\t{ token lexbuf } | '\\n'\t{ NEWLINE } | digit+ | \u0026quot;.\u0026quot; digit+ | digit+ \u0026quot;.\u0026quot; digit* as num { NUM (float_of_string num) } | '+'\t{ PLUS } | '-'\t{ MINUS } | '*'\t{ MULTIPLY } | '/'\t{ DIVIDE } | '^'\t{ CARET } | '('\t{ LPAREN } | ')'\t{ RPAREN } | '='\t{ EQ } | ident ident_num* as word { try let f = Hashtbl.find fun_table word in FNCT f with Not_found -\u0026gt; VAR word } | _\t{ token lexbuf } | eof\t{ raise End_of_file }  A hash table named fun_table is used for storing a function name and a value, that is, a function definition. It is initialized in the header part of the lexer file.\nThis program is both powerful and flexible. You may easily add new functions.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/parserstates/",
	"title": "Parser States",
	"tags": [],
	"description": "The function yyparse is implemented using a finite-state machine.",
	"content": "The function yyparse is implemented using a finite-state machine. The values pushed on the parser stack are not simply token type codes; they represent the entire sequence of terminal and nonterminal symbols at or near the top of the stack. The current state collects all the information about previous input which is relevant to deciding what to do next.\nEach time a look-ahead token is read, the current parser state together with the type of look-ahead token are looked up in a table. This table entry can say, \u0026ldquo;Shift the look-ahead token.\u0026rdquo; In this case, it also specifies the new parser state, which is pushed onto the top of the parser stack. Or it can say, \u0026ldquo;Reduce using rule number n.\u0026rdquo; This means that a certain number of tokens or groupings are taken off the top of the stack, and replaced by one grouping. In other words, that number of states are popped from the stack, and one new state is pushed.\nThere is one other alternative: the table can say that the look-ahead token is erroneous in the current state. This causes error processing to begin (see Error Recovery).\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parserinterface/",
	"title": "Parser interface",
	"tags": [],
	"description": "The Ocamlyacc parser is actually Ocaml functions named after start symbols.",
	"content": "The Ocamlyacc parser is actually Ocaml functions named after start symbols (see The Start-Symbol). Here we describe the interface conventions of parser functions and the other functions that it needs to use.\n Parser Functions  To cause parsing to occur, you call the parser function with two parameters.\n Lexical Functions  The lexical analyzer function, named after rule declarations, recognizes tokens from the input stream and returns them to the parser.\n Error Functions  The Ocamlyacc parser detects a parse error or syntax error whenever it reads a token which cannot satisfy any syntax rule.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/gettingstarted/steppingthroughhelloworld/",
	"title": "Stepping throught hello world",
	"tags": [],
	"description": "Now that we know the theory behind this, let&#39;s clarify by walking through the example helloworld program.",
	"content": "Now that we know the theory behind this, let\u0026rsquo;s clarify by walking through the example helloworld program.\nHere is the callback function that will be called when the button is \u0026ldquo;clicked\u0026rdquo;. We ignore both the widget and the data in this example, but it is not hard to do things with them. The next example will use the data argument to tell us which button was pressed.\nlet hello () = print_endline \u0026#34;Hello World\u0026#34;; flush stdout The next callback is a bit special. The \u0026ldquo;delete_event\u0026rdquo; occurs when the window manager sends this event to the application. We have a choice here as to what to do about these events. We can ignore them, make some sort of response, or simply quit the application.\nThe value you return in this callback lets GTK know what action to take. By returning true, we let it know that we don\u0026rsquo;t want to have the \u0026ldquo;destroy\u0026rdquo; signal emitted, keeping our application running. By returning false, we ask that \u0026ldquo;destroy\u0026rdquo; be emitted, which in turn will call our \u0026ldquo;destroy\u0026rdquo; signal handler.\nlet delete_event ev = print_endline \u0026#34;Delete event occurred\u0026#34;; flush stdout; true Here is another callback function which causes the program to quit by calling GMain.Main.quit (). This function tells GTK that it is to exit from GMain.Main.main when control is returned to it.\nlet destroy () = GMain.Main.quit () In \u0026ldquo;C\u0026rdquo; language, you have to use \u0026ldquo;main\u0026rdquo; for starting function name, but in \u0026ldquo;Ocaml\u0026rdquo;, you don\u0026rsquo;t have to. You may use any name for a fuction, and we\u0026rsquo;ll tell the system the name of the starting point. In this example, we\u0026rsquo;ll use \u0026ldquo;main\u0026rdquo; for the name of ther starting function.\nlet main () = Create a new window using GWindow.window. This is fairly straightforward. Memory is allocated for the GtkWidget *window structure so it now points to a valid structure. It sets up a new window, but it is not displayed until we call window#show () near the end of our program.\nlet window = GWindow.window ~border_width:10 () in This ~border_width option is used to set an attribute of a container object. This just sets the window so it has a blank area along the inside of it 10 pixels wide where no widgets will go. There are other similar functions which we will look at in the section on Setting Widget Attributes\nHere are two examples of connecting a signal handler to an object, in this case, the window. Here, the \u0026ldquo;delete_event\u0026rdquo; and \u0026ldquo;destroy\u0026rdquo; signals are caught. The first is emitted when we use the window manager to kill the window, or when we use the window#destroy () call passing in the window widget as the object to destroy. The second is emitted when, in the \u0026ldquo;delete_event\u0026rdquo; handler, we return false. The G_OBJECT and G_CALLBACK are macros that perform type casting and checking for us, as well as aid the readability of the code.\nwindow#event#connect#delete ~callback:delete_event; window#connect#destroy ~callback:destroy; This call creates a new button. It allocates space for a new GtkWidget structure in memory, initializes it, and makes the button pointer point to it. It will have the label \u0026ldquo;Hello World\u0026rdquo; on it when displayed.\nlet button = GButton.button ~label:\u0026#34;Hello World\u0026#34; ~packing:window#add () in There is a ~packing option, which will be explained in depth later on in Packing Widgets. But it is fairly easy to understand. It simply tells GTK that the button is to be placed in the window where it will be displayed. Note that a GTK container can only contain one widget. There are other widgets, that are described later, which are designed to layout multiple widgets in various ways.\nHere, we take this button, and make it do something useful. We attach a signal handler to it so when it emits the \u0026ldquo;clicked\u0026rdquo; signal, our hello() function is called. Obviously, the \u0026ldquo;clicked\u0026rdquo; signal is emitted when we click the button with our mouse pointer.\nbutton#connect#clicked ~callback:hello; We are also going to use this button to exit our program. This will illustrate how the \u0026ldquo;destroy\u0026rdquo; signal may come from either the window manager, or our program. When the button is \u0026ldquo;clicked\u0026rdquo;, same as above, it calls the first hello() callback function, and then this one in the order they are set up. You may have as many callback functions as you need, and all will be executed in the order you connected them.\nbutton#connect#clicked ~callback:window#destroy; Now we have everything set up the way we want it to be. With all the signal handlers in place, and the button placed in the window where it should be, we ask GTK to \u0026ldquo;show\u0026rdquo; the widgets on the screen. All widgets are \u0026ldquo;shown\u0026rdquo; by default except window widget. The window widget is shown last so the whole window will pop up at once rather than seeing the window pop up, and then the button form inside of it. Although with such a simple example, you\u0026rsquo;d never notice.\nwindow#show (); GMain.Main.main () And of course, we call GMain.Main.main () which waits for events to come from the X server/Window and will call on the widgets to emit signals when these events come.\nGMain.Main.main () And for the final thing, we should tell the system how to do this application. On executing the following line, the function named \u0026ldquo;main\u0026rdquo; will be called.\nlet _ = main () or, if you want to see error message which is raised on evaluating main () functon:\nlet _ = Printexc.print main () Now, when we click the mouse button on a GTK button, the widget emits a \u0026ldquo;clicked\u0026rdquo; signal. In order for us to use this information, our program sets up a signal handler to catch that signal, which dispatches the function of our choice. In our example, when the button we created is \u0026ldquo;clicked\u0026rdquo;, the hello() function is called , and then the next handler for this signal is called. This calls the window#destroy () function, destroying the window widget. This causes the window to emit the \u0026ldquo;destroy\u0026rdquo; signal, which is caught, and calls our destroy() callback function, which simply exits GTK.\nAnother course of events is to use the window manager to kill the window, which will cause the \u0026ldquo;delete_event\u0026rdquo; to be emitted. This will call our \u0026ldquo;delete_event\u0026rdquo; handler. If we return true here, the window will be left as is and nothing will happen. Returning false will cause GTK to emit the \u0026ldquo;destroy\u0026rdquo; signal which of course calls the \u0026ldquo;destroy\u0026rdquo; callback, exiting GTK.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/packingwidgets/tablepackingexample/",
	"title": "Table packing example",
	"tags": [],
	"description": "A window with three buttons in a 2x2 table.",
	"content": "Here we make a window with three buttons in a 2x2 table. The first two buttons will be placed in the upper row. A third, quit button, is placed in the lower row, spanning both columns. Which means it should look something like this:\nHere\u0026rsquo;s the source code:\n(* file: table.ml *) (* Our callback. *) let hello msg () = Printf.printf \u0026#34;Hello again - %s was pressed\\n\u0026#34; msg; flush stdout let main () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Table\u0026#34; ~border_width:20 () in (* Set a handler for destroy event that immediately exits GTK. *) window#connect#destroy ~callback:GMain.Main.quit; (* Create a 2x2 table and put it in the main window *) let table = GPack.table ~rows:2 ~columns:2 ~homogeneous:true ~packing:window#add () in (* Create first button *) let button = GButton.button ~label:\u0026#34;button 1\u0026#34; () in (* Insert button 1 into the upper left quadrant of the table *) table#attach ~left:0 ~top:0 (button#coerce); (* When the button is clicked, we call the \u0026#34;callback\u0026#34; function * with \u0026#34;button 1\u0026#34; as its argument *) button#connect#clicked ~callback:(hello \u0026#34;button 1\u0026#34;); (* Create second button *) let button2 = GButton.button ~label:\u0026#34;button 2\u0026#34; () in (* Insert button 2 into the upper right quadrant of the table *) table#attach ~left:1 ~top:0 (button2#coerce); (* When the button is clicked, we call the \u0026#34;callback\u0026#34; function * with \u0026#34;button 2\u0026#34; as its argument *) button2#connect#clicked ~callback:(hello \u0026#34;button 2\u0026#34;); (* Create \u0026#34;Quit\u0026#34; button *) let quit = GButton.button ~label:\u0026#34;Quit\u0026#34; () in (* Insert the quit button into the both * lower quadrants of the table *) table#attach ~left:0 ~right:2 ~top:1 (quit#coerce); (* When the \u0026#34;Quit\u0026#34; button is clicked, the program exits *) quit#connect#clicked ~callback:GMain.Main.quit; window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/widgetoverview/",
	"title": "Widget overview",
	"tags": [],
	"description": "The general steps to creating a widget in GTK are ...",
	"content": "The general steps to creating a widget in GTK are:\n Creation - one of various functions to create a new widget. The returned widget is an object and you can use it to get/set values or do something. These are all detailed in this section.\n Set the attributes of the widget. This can be done on widget creation.\n Pack the widget into a container using the appropriate call such as add or pack method. This can be done on widget creation.\n Connect all signals and events we wish to use to the appropriate handlers.\n If it is toplevel window, show() the widget. Except toplevel window, show is default.\n  show method lets GTK know that we are done setting the attributes of the widget, and it is ready to be displayed. You may also use hide metehod to make it disappear again. The order in which you show the widgets is not important, but I suggest showing the window last so the whole window pops up at once rather than seeing the individual widgets come up on the screen as they\u0026rsquo;re formed. The children of a widget (a window is a widget too) will not be displayed until the window itself is shown using the show() method.\n Type conversion  Type conversion\n Widget hierarchy  The class hierarchy tree used to implement widgets.\n Widget without windows  The following widgets do not have an associated window.\n Structure of widgets  Structure of widgets\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/aspectframes/",
	"title": "Aspect frames",
	"tags": [],
	"description": "The aspect frame widget is like a frame widget, except that it also enforces the aspect ratio (that is, the ratio of the width to the height) of the child widget to have a certain value, adding extra space if necessary.",
	"content": "The aspect frame widget is like a frame widget, except that it also enforces the aspect ratio (that is, the ratio of the width to the height) of the child widget to have a certain value, adding extra space if necessary. This is useful, for instance, if you want to preview a larger image. The size of the preview should vary when the user resizes the window, but the aspect ratio needs to always match the original image.\nTo create a new aspect frame use GBin.aspect_frame:\nval GBin.aspect_frame : ?obey_child:bool -\u0026gt; ?ratio:float -\u0026gt; ?xalign:Gtk.clampf -\u0026gt; ?yalign:Gtk.clampf -\u0026gt; ?label:string -\u0026gt; ?label_xalign:Gtk.clampf -\u0026gt; ?label_yalign:Gtk.clampf -\u0026gt; ?shadow_type:Gtk.Tags.shadow_type -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; aspect_frame xalign and yalign specify alignment as with Alignment widgets. If obey_child is true, the aspect ratio of a child widget will match the aspect ratio of the ideal size it requests. Otherwise, it is given by ratio.\nTo change the options of an existing aspect frame, you can use:\nmethod set_xalign : float -\u0026gt; unit method set_yalign : float -\u0026gt; unit method set_ratio : float -\u0026gt; unit method set_obey_child : bool -\u0026gt; unit As an example, the following program uses an AspectFrame to present a drawing area whose aspect ratio will always be 2:1, no matter how the user resizes the top-level window.\n(* file: aspectframe.ml *) let main () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Aspect Frame\u0026#34; ~border_width:10 () in (* Here we connect the \u0026#34;destroy\u0026#34; event to a signal handler *) window#connect#destroy ~callback:GMain.Main.quit; (* Create a Frame * Set the frame\u0026#39;s label * Align the label at the right of the frame * Set the style of the frame *) let aspect_frame = GBin.aspect_frame ~label:\u0026#34;2x1\u0026#34; ~xalign:0.5 (* center x *) ~yalign:0.5 (* center y *) ~ratio:2.0\t(* xsize/ysize = 2.0 *) ~obey_child:false (* ignore child\u0026#39;s aspect *) ~packing:window#add () in (* Now add a child widget to the aspect frame *) (* Ask for a 200x200 widnow, but the AspectFrame will give us a 200x100 * window since we are forcing a 2x1 aspect ratio *) let drawing_area = GMisc.drawing_area ~width:200 ~height:200 ~packing:aspect_frame#add () in window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/creatingwidgets/",
	"title": "Creating Widgets",
	"tags": [],
	"description": "You create a widget by ...",
	"content": "You create a widget by\n[Module].[widget name] options ... () Many optional arguments are admitted. The last two of them, packing: and show:, allow you respectively to call a function on your newly created widget, and to decide wether to show it immediately or not. By default all widgets except toplevel windows (GWindow module) are shown immediately.\n Default arguments  For many constructor or method arguments, default values are provided.\n Memory management  Important efforts have been dedicated to cooperate with Gtk\u0026#39;s reference counting mechanism.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/ocamlyaccoutput/",
	"title": "Ocamlyacc output",
	"tags": [],
	"description": "When you run Ocamlyacc, you give it a Ocamlyacc grammar file as input. The output is a Ocaml source file that parses the language described by the grammar.",
	"content": "When you run Ocamlyacc, you give it a Ocamlyacc grammar file as input. The output is a Ocaml source file that parses the language described by the grammar. This file is called a Ocamlyacc parser. Keep in mind that the Ocamlyacc utility and the Ocamlyacc parser are two distinct programs: the Ocamlyacc utility is a program whose output is the Ocamlyacc parser that becomes part of your program.\nThe job of the Ocamlyacc parser is to group tokens into groupings according to the grammar rules\u0026mdash;for example, to build identifiers and operators into expressions. As it does this, it runs the actions for the grammar rules it uses.\nThe tokens come from a function called the lexical analyzer that you must supply in some fashion. The Ocamlyacc parser calls the lexical analyzer each time it wants a new token. It doesn\u0026rsquo;t know what is \u0026ldquo;inside\u0026rdquo; the tokens (though their semantic values may reflect this). Typically the lexical analyzer makes the tokens by parsing characters of text, but Ocamlyacc does not depend on this. See The Lexical Analyzer Function.\nThe Ocamlyacc parser file is Ocaml code which defines functions which implements that grammar. Entry functions of the generated Ocaml code are named after the start symbols in grammar file. These functions do not make a complete Ocaml program: you must supply some additional functions. One is the lexical analyzer which should be given as an argument of the parser entry function. Another is an error-reporting function which the parser calls to report an error. In addition, a complete Ocaml program must has to call one (or more) of the generated entry functions or the parser will never run. See Parser Interface.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/",
	"title": "Parser algorithm",
	"tags": [],
	"description": "As Ocamlyacc reads tokens, it pushes them onto a stack along with their semantic values.",
	"content": "As Ocamlyacc reads tokens, it pushes them onto a stack along with their semantic values. The stack is called the parser stack. Pushing a token is traditionally called shifting.\nFor example, suppose the infix calculator has read 1 + 5 *, with a 3 to come. The stack will have four elements, one for each token that was shifted.\nBut the stack does not always have an element for each token read. When the last n tokens and groupings shifted match the components of a grammar rule, they can be combined according to that rule. This is called reduction. Those tokens and groupings are replaced on the stack by a single grouping whose symbol is the result (left hand side) of that rule. Running the rule\u0026rsquo;s action is part of the process of reduction, because this is what computes the semantic value of the resulting grouping.\nFor example, if the infix calculator\u0026rsquo;s parser stack contains this:\n1 + 5 * 3  and the next input token is a newline character, then the last three elements can be reduced to 15 via the rule:\nexpr: expr MULTIPLY expr;  Then the stack contains just these three elements:\n1 + 15  At this point, another reduction can be made, resulting in the single value 16. Then the newline token can be shifted.\nThe parser tries, by shifts and reductions, to reduce the entire input down to a single grouping whose symbol is the grammar\u0026rsquo;s start-symbol (see Languages and Context-Free Grammars).\nThis kind of parser is known in the literature as a bottom-up parser.\n Lookahead Tokens  The Ocamlyacc parser does not always reduce immediately as soon as the last n tokens and groupings match a rule.\n Operator Precedence  the Ocamlyacc declarations for operator precedence allow you to specify when to shift and when to reduce.\n Shift Reduct Conflicts  The situation, where either a shift or a reduction would be valid, is called a shift/reduce conflict.\n Context-Dependent Precedence  Often the precedence of an operator depends on the context.\n Parser States  The function yyparse is implemented using a finite-state machine.\n Reduce/Reduce Conflicts  A reduce/reduce conflict occurs if there are two or more rules that apply to the same sequence of input.\n Misterious Reduce/Reduce Conflicts  Sometimes reduce/reduce conflicts can occur that don\u0026#39;t look warranted.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/reducereduceconflicts/",
	"title": "Reduce/Reduce Conflicts",
	"tags": [],
	"description": "A reduce/reduce conflict occurs if there are two or more rules that apply to the same sequence of input.",
	"content": "A reduce/reduce conflict occurs if there are two or more rules that apply to the same sequence of input. This usually indicates a serious error in the grammar.\nFor example, here is an erroneous attempt to define a sequence of zero or more word groupings.\nsequence: /* empty */\t{ printf \u0026quot;empty sequence\\n\u0026quot; } | maybeword\t{} | sequence word\t{ printf \u0026quot;added word %s\\n\u0026quot; $2 } ; maybeword: /* empty */\t{ printf \u0026quot;empty maybeword\\n\u0026quot; } | word\t{ printf \u0026quot;single word %s\\n\u0026quot; $1 } ;  The error is an ambiguity: there is more than one way to parse a single word into a sequence. It could be reduced to a maybeword and then into a sequence via the second rule. Alternatively, nothing-at-all could be reduced into a sequence via the first rule, and this could be combined with the word using the third rule for sequence.\nThere is also more than one way to reduce nothing-at-all into a sequence. This can be done directly via the first rule, or indirectly via maybeword and then the second rule.\nYou might think that this is a distinction without a difference, because it does not change whether any particular input is valid or not. But it does affect which actions are run. One parsing order runs the second rule\u0026rsquo;s action; the other runs the first rule\u0026rsquo;s action and the third rule\u0026rsquo;s action. In this example, the output of the program changes.\nOcamlyacc resolves a reduce/reduce conflict by choosing to use the rule that appears first in the grammar, but it is very risky to rely on this. Every reduce/reduce conflict must be studied and usually eliminated. Here is the proper way to define sequence:\nsequence: /* empty */\t{ printf \u0026quot;empty sequence\\n\u0026quot; } | sequence word { printf \u0026quot;added word %s\\n\u0026quot; $2 } ;  Here is another common error that yields a reduce/reduce conflict:\nsequence: /* empty */ | sequence words | sequence redirects ; words: /* empty */ | words word ; redirects:/* empty */ | redirects redirect ;  The intention here is to define a sequence which can contain either word or redirect groupings. The individual definitions of sequence, words and redirects are error-free, but the three together make a subtle ambiguity: even an empty input can be parsed in infinitely many ways!\nConsider: nothing-at-all could be a words. Or it could be two words in a row, or three, or any number. It could equally well be a redirects, or two, or any number. Or it could be a words followed by three redirects and another words. And so on.\nHere are two ways to correct these rules. First, to make it a single level of sequence:\nsequence: /* empty */ | sequence word | sequence redirect ;  Second, to prevent either a words or a redirects from being empty:\nsequence: /* empty */ | sequence words | sequence redirects ; words: word | words word ; redirects:redirect | redirects redirect ;  "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/rulers/",
	"title": "Rulers",
	"tags": [],
	"description": "Ruler widgets are used to indicate the location of the mouse pointer in a given window.",
	"content": "Ruler widgets are used to indicate the location of the mouse pointer in a given window. A window can have a vertical ruler spanning across the width and a horizontal ruler spanning down the height. A small triangular indicator on the ruler shows the exact location of the pointer relative to the ruler.\nA ruler must first be created. Horizontal and vertical rulers are created using GRange.ruler\nval GRange.ruler: Gtk.Tags.orientation -\u0026gt; ?metric:Gtk.Tags.metric_type -\u0026gt; ?lower:float -\u0026gt; ?upper:float -\u0026gt; ?max_size:float -\u0026gt; ?position:float -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; ruler metric : default value is `PIXELS Orientation should be given as an argument. It can be HORIZONTAL for horizontal ruler andVERTICAL for vertical ruler.\nUnits of measure for rulers can bePIXELS,INCHES or `CENTIMETERS. This can be set using\nmethod set_metric : Gtk.Tags.metric_type -\u0026gt; unit The default measure is `PIXELS.\nOther important characteristics of a ruler are how to mark the units of scale and where the position indicator is initially placed. These are set for a ruler using\nmethod set_lower : float -\u0026gt; unit method set_upper : float -\u0026gt; unit method set_position : float -\u0026gt; unit method set_max_size : float -\u0026gt; unit The lower and upper define the extent of the ruler, and max_size is the largest possible number that will be displayed. Position defines the initial position of the pointer indicator within the ruler.\nA vertical ruler can span an 800 pixel wide window thus\nvruler#set_lower 0; vruler#set_upper 800; vruler#set_position 0; vruler#set_max_size 800; The markings displayed on the ruler will be from 0 to 800, with a number for every 100 pixels. If instead we wanted the ruler to range from 7 to 16, we would code\nvruler#set_lower 7; vruler#set_upper 16; vruler#set_position 0; vruler#set_max_size 20; The indicator on the ruler is a small triangular mark that indicates the position of the pointer relative to the ruler. If the ruler is used to follow the mouse pointer, the motion_notify_event signal should be connected to the motion_notify_event method of the ruler. To follow all mouse movements within a window area, we would use\narea#event#connect#motion_notify ~callback:(fun ev -\u0026gt; hruler#event#send (ev :\u0026gt; GdkEvent.any)); The following example creates a drawing area with a horizontal ruler above it and a vertical ruler to the left of it. The size of the drawing area is 600 pixels wide by 400 pixels high. The horizontal ruler spans from 7 to 13 with a mark every 100 pixels, while the vertical ruler spans from 0 to 400 with a mark every 100 pixels. Placement of the drawing area and the rulers is done using a table.\n(* file: ruler.ml *) let xsize = 600 let ysize = 400 let main () = let window = GWindow.window ~title:\u0026#34;Ruler\u0026#34; ~border_width:10 () in window#connect#destroy ~callback:GMain.Main.quit; (* Create a table for placing the ruler and the drawing area *) let table = GPack.table ~rows:3 ~columns:2 ~packing:window#add () in let area = GMisc.drawing_area ~width:xsize ~height:ysize ~packing:(table#attach ~left:1 ~top:1) () in area#event#add [`POINTER_MOTION; `POINTER_MOTION_HINT]; (* The horizontal ruler goes on the top. As the mouse moves across * the drawing area, a motion_notify_event is passed to the * approprite event handler for the ruler. *) let hruler = GRange.ruler `HORIZONTAL ~metric:`PIXELS ~lower:7.0 ~upper:13.0 ~position:0.0 ~max_size:20.0 ~packing:(table#attach ~left:1 ~top:0) () in area#event#connect#motion_notify ~callback:(fun ev -\u0026gt; hruler#event#send (ev :\u0026gt; GdkEvent.any)); (* The vertical ruler goes on the left. As the mouse moves across * the drawing area, a motion_notify_event is passed to the * approprite event handler for the ruler. *) let vruler = GRange.ruler `VERTICAL ~metric:`PIXELS ~lower:0.0 ~upper:(float ysize) ~position:0.0 ~max_size:(float ysize) ~packing:(table#attach ~left:0 ~top:1) () in area#event#connect#motion_notify ~callback:(fun ev -\u0026gt; vruler#event#send (ev :\u0026gt; GdkEvent.any)); window#show (); GMain.Main.main () let _ = main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/trackinglocations/",
	"title": "Tracking Locations",
	"tags": [],
	"description": "Though grammar rules and semantic actions are enough to write a fully functional parser, it can be useful to process some additionnal informations, especially symbol locations.",
	"content": " Though grammar rules and semantic actions are enough to write a fully functional parser, it can be useful to process some additionnal informations, especially symbol locations.\nThe way locations are handled is defined by providing a data type, and actions to take when rules are matched.\nData Type of Locations The data type for locations has the following type:\ntype position = { pos_fname : string;\t(* file name *) pos_lnum : int;\t(* line number *) pos_bol : int;\t(* the offset of the beginning of the line *) pos_cnum : int;\t(* the offset of the position *) }  The value of pos_bol field is the number of characters between the beginning of the file and the beginning of the line while the value of pos_cnum field is the number of characters between the beginning of the file and the position.\nThe lexing engine manages only the pos_cnum field of lexbuf.lex_curr_p with the number of characters read from the start of lexbuf. So you are reponsible for the other fields to be accurate. Before using the location in the parser, you have to set Lexing.lexbuf.lex_curr_p correctly in lexer, using such a function like this:\nlet incr_linenum lexbuf = let pos = lexbuf.Lexing.lex_curr_p in lexbuf.Lexing.lex_curr_p \u0026lt;- { pos with Lexing.pos_lnum = pos.Lexing.pos_lnum + 1; Lexing.pos_bol = pos.Lexing.pos_cnum; } ;;  Actions and Locations Actions are not only useful for defining language semantics, but also for describing the behavior of the output parser with locations. The most obvious way for building locations of syntactic groupings is very similar to the way semantic values are computed. In a given rule, several constructs can be used to access the locations of the elements being matched. The location of the nth component of the right hand side can be obtained with:\nval Parsing.rhs_start : int -\u0026gt; int val Parsing.rhs_end : int -\u0026gt; int  Parsing.rhs_start n returns the offset of the first character of the nth item on the right-hand side of the rule, while Parsing.rhs_end n returns the offset after the last character of the item. are to be called in the action part of a grammar rule only. n is 1 for the leftmost item and the first character in a file is at offset 0.\nOr you can use the following functions:\nval Parsing.rhs_start_pos : int -\u0026gt; Lexing.position val Parsing.rhs_end_pos : int -\u0026gt; Lexing.position   (Since Ocaml 3.08) These functions return a position instead of an offset (see Data Type of Locations).\n The location of the left hand side grouping can be referred by\nval Parsing.symbol_start : unit -\u0026gt; int val Parsing.symbol_end : unit -\u0026gt; int  The _symbolstart () returns the offset of the first character of the left-hand side of the rule while _symbolend () returns the offset after the last character.\n(Since Ocaml 3.08) The following functions are same as symbol_start and symbol_end, except returning a position instead of an offset (see Data Type of Locations).\nval Parsing.symbol_start_pos : unit -\u0026gt; Lexing.position val Parsing.symbol_end_pos : unit -\u0026gt; Lexing.position  Here is a basic example using the default data type for locations:\nexp:\t... | exp DIVIDE exp { if $3 \u0026lt;\u0026gt; 0.0 then $1 /. $3 else ( let start_pos = Parsing.rhs_start_pos 3 in let end_pos = Parsing.rhs_end_pos 3 in printf \u0026quot;%d.%d-%d.%d: division by zero\u0026quot; start_pos.pos_lnum (start_pos.pos_cnum - start_pos.pos_bol) end_pos.pos_lnum (end_pos.pos_cnum - end_pos.pos_bol); 1.0 ) }  "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/buttonwidget/",
	"title": "Button widget",
	"tags": [],
	"description": "We&#39;ve almost seen all there is to see of the button widget. It&#39;s pretty simple. There is however more than one way to create a button.",
	"content": "  Normal buttons  For many constructor or method arguments, default values are provided.\n Toggle buttons  Toggle buttons are derived from normal buttons and are very similar, except they will always be in one of two states, alternated by a click.\n Check buttons  Check buttons inherit many properties and functions from the the toggle buttons.\n Radio buttons  Check buttons inherit many properties and functions from the the toggle buttons.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/errorrecovery/",
	"title": "Error Recovery",
	"tags": [],
	"description": "It is not usually acceptable to have a program terminate on a parse error. For example, a compiler should recover sufficiently to parse the rest of the input file and check it for errors; a calculator should accept another expression.",
	"content": "It is not usually acceptable to have a program terminate on a parse error. For example, a compiler should recover sufficiently to parse the rest of the input file and check it for errors; a calculator should accept another expression.\nIn a simple interactive command parser where each input is one line, it may be sufficient to have the caller catch the exception and ignore the rest of the input line when that happens (and then call parse function again). But this is inadequate for a compiler, because it forgets all the syntactic context leading up to the error. A syntax error deep within a function in the compiler input should not cause the compiler to treat the following line like the beginning of a source file.\nYou can define how to recover from a syntax error by writing rules to recognize the special token error. This is a terminal symbol that is reserved for error handling. The Ocamlyacc parser generates an error token whenever a syntax error happens; if you have provided a rule to recognize this token in the current context, the parse can continue.\nFor example:\nstmnts: /* empty string */ {} | stmnts NEWLINE {} | stmnts exp NEWLINE {} | stmnts error NEWLINE {}\nThe fourth rule in this example says that an error followed by a newline makes a valid addition to any stmnts.\nWhat happens if a syntax error occurs in the middle of an exp? The error recovery rule, interpreted strictly, applies to the precise sequence of a stmnts, an error and a newline. If an error occurs in the middle of an exp, there will probably be some additional tokens and subexpressions on the stack after the last stmnts, and there will be tokens to read before the next newline. So the rule is not applicable in the ordinary way.\nBut Ocamlyacc can force the situation to fit the rule, by discarding part of the semantic context and part of the input. First it discards states and objects from the stack until it gets back to a state in which the error token is acceptable. (This means that the subexpressions already parsed are discarded, back to the last complete stmnts.) At this point the error token can be shifted. Then, if the old look-ahead token is not acceptable to be shifted next, the parser reads tokens and discards them until it finds a token which is acceptable. In this example, Ocamlyacc reads and discards input until the next newline so that the fourth rule can apply.\nThe choice of error rules in the grammar is a choice of strategies for error recovery. A simple and useful strategy is simply to skip the rest of the current input line or current statement if an error is detected:\nstmnt: error SEMICOLON {} /* on error, skip until SEMICOLON is read */\nIt is also useful to recover to the matching close-delimiter of an opening-delimiter that has already been parsed. Otherwise the close-delimiter will probably appear to be unmatched, and generate another, spurious error message:\nprimary: LPAREN expr RPAREN {} | LPAREN error RPAREN {} \u0026hellip; ;\nError recovery strategies are necessarily guesses. When they guess wrong, one syntax error often leads to another. In the above example, the error recovery rule guesses that an error is due to bad input within one stmnt. Suppose that instead a spurious semicolon is inserted in the middle of a valid stmnt. After the error recovery rule recovers from the first error, another syntax error will be found straightaway, since the text following the spurious semicolon is also an invalid stmnt.\nTo prevent an outpouring of error messages, the parser will output no error message for another syntax error that happens shortly after the first; only after three consecutive input tokens have been successfully shifted will error messages resume.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/parseralgorithm/mysteriousreducereductconflicts/",
	"title": "Misterious Reduce/Reduce Conflicts",
	"tags": [],
	"description": "Sometimes reduce/reduce conflicts can occur that don&#39;t look warranted.",
	"content": "Sometimes reduce/reduce conflicts can occur that don\u0026rsquo;t look warranted. Here is an example:\n%token ID COMMA COLON %% def: param_spec return_spec COMMA ; param_spec: type | name_list COLON type ; return_spec: type | name COLON type ; type: ID ; name: ID ; name_list: name | name COMMA name_list ;  It would seem that this grammar can be parsed with only a single token of look-ahead: when a param_spec is being read, an ID is a name if a comma or colon follows, or a type if another ID follows. In other words, this grammar is LR(1).\nHowever, Ocamlyacc, like most parser generators, cannot actually handle all LR(1) grammars. In this grammar, two contexts, that after an ID at the beginning of a param_spec and likewise at the beginning of a return_spec, are similar enough that Ocamlyacc assumes they are the same. They appear similar because the same set of rules would be active\u0026mdash;the rule for reducing to a name and that for reducing to a type. Ocamlyacc is unable to determine at that stage of processing that the rules would require different look-ahead tokens in the two contexts, so it makes a single parser state for them both. Combining the two contexts causes a conflict later. In parser terminology, this occurrence means that the grammar is not LALR(1).\nIn general, it is better to fix deficiencies than to document them. But this particular deficiency is intrinsically hard to fix; parser generators that can handle LR(1) grammars are hard to write and tend to produce parsers that are very large. In practice, Ocamlyacc is more useful as it is now.\nWhen the problem arises, you can often fix it by identifying the two parser states that are being confused, and adding something to make them look distinct. In the above example, adding one rule to return_spec as follows makes the problem go away:\n%token BOGUS ... %% ... return_spec: type | name COMMA type /* This rule is never used. */ | ID BOGUS ;  This corrects the problem because it introduces the possibility of an additional active rule in the context after the ID at the beginning of return_spec. This rule is not active in the corresponding context in a param_spec, so the two contexts receive distinct parser states. As long as the token BOGUS is never generated by yylex, the added rule cannot alter the way actual input is parsed.\nIn this particular example, there is another way to solve the problem: rewrite the rule for return_spec to use ID directly instead of via name. This also causes the two confusing contexts to have different sets of active rules, because the one for return_spec activates the altered rule for return_spec rather than the one for name.\nparam_spec: type | name_list COMMA type ; return_spec: type | ID COMMA type ;  "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/nonterminal/",
	"title": "Nonterminal Symbols",
	"tags": [],
	"description": "The Ocamlyacc declarations section of a Ocamlyacc grammar defines the symbols used in formulating the grammar and the data types of semantic values.  All token type must be declared. Nonterminal symbols must be declared if you need to specify which data type to use for the semantic value.",
	"content": " The Ocamlyacc declarations section of a Ocamlyacc grammar defines the symbols used in formulating the grammar and the data types of semantic values. See Symbols.\nAll token type must be declared. Nonterminal symbols must be declared if you need to specify which data type to use for the semantic value (see Data Types of Semantic Values).\nThe first rule in the file also specifies the start symbol, by default. If you want some other symbol to be the start symbol, you must declare it explicitly (see Languages and Context-Free Grammars).\nToken Type Names The basic way to declare a token type name (terminal symbol) is as follows:\n%token name ... name %token \u0026lt;type\u0026gt; name ... name  Ocamlyacc will convert this into a token type in the parser, so that the lexer function can use the name name to stand for this token type\u0026rsquo;s code.\nIn the event that the token has a value, you must augment the %token declaration to include the data type alternative delimited by angle-brackets (see Data Types of Semantic Values).\nFor example:\n%token \u0026lt;float\u0026gt; NUM\t/* define toke NUM and its type */  The type part is an arbitrary Caml type expression,\nOperator Precedence Use the %left, %right or %nonassoc declaration to specify token\u0026rsquo;s precedence and associativity, all at once. These are called precedence declarations. See Operator Precedence, for general information on operator precedence.\nThe syntax of a precedence declaration is\n%left symbols ...symbols %right symbols ...symbols %nonassoc symbols ...symbols  They specify the associativity and relative precedence for all the symbols:\nThe associativity of an operator op determines how repeated uses of the operator nest: whether x op y op z is parsed by grouping x with y first or by grouping y with z first. %left specifies left-associativity (grouping x with y first) and %right specifies right-associativity (grouping y with z first). %nonassoc specifies no associativity, which means that x op y op z is considered a syntax error.\nThe precedence of an operator determines how it nests with other operators. All the tokens declared in a single precedence declaration have equal precedence and nest together according to their associativity. When two tokens declared in different precedence declarations associate, the one declared later has the higher precedence and is grouped first.\nNonterminal Symbols You can declare the value type of each nonterminal symbol for which values are used. This is done with a %type declaration, like this:\n%type \u0026lt;type\u0026gt; nonterminal ... nonterminal  Here nonterminal is the name of a nonterminal symbol, and type is the name of the type that you want. You can give any number of start nonterminal symbols in the same %type declaration, if they have the same value type. Use spaces to separate the symbol names.\nThis is necessary for start symbols. For the type part, see Token Type Names.\nThe Start-Symbol You have to declare the start symbols using %start declaration as follows:\n%start symbol ... symbol  Each start symbol has a parsing function with the same name in the output file so you can use it as an entry point for the grammar. As noted eariler, type should be assinged to each start symbol using %type directive (see Nonterminal Symbols).\nOcamlyacc Declaration Summary Here is a summary of the declarations used to define a grammar:\n %token: Declare a terminal symbol (token type name) with no precedence or associativity specified (see Token Type Names). %right: Declare a terminal symbol (token type name) that is right-associative (see Operator Precedence). %left: Declare a terminal symbol (token type name) that is left-associative (see Operator Precedence). %nonassoc: Declare a terminal symbol (token type name) that is nonassociative (using it in a way that would be associative is a syntax error) (see Operator Precedence). %type: Declare the type of semantic values for a nonterminal symbol (see Nonterminal Symbols). %start: Specify the grammar\u0026rsquo;s start symbol (see The Start-Symbol).  "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/grammar/declarations/",
	"title": "Ocamlyacc Declarations",
	"tags": [],
	"description": "The Ocamlyacc declarations section of a Ocamlyacc grammar defines the symbols used in formulating the grammar and the data types of semantic values.",
	"content": "The Ocamlyacc declarations section of a Ocamlyacc grammar defines the symbols used in formulating the grammar and the data types of semantic values. See Symbols.\nAll token type must be declared. Nonterminal symbols must be declared if you need to specify which data type to use for the semantic value (see Data Types of Semantic Values).\nThe first rule in the file also specifies the start symbol, by default. If you want some other symbol to be the start symbol, you must declare it explicitly (see Languages and Context-Free Grammars).\n4.7.1. Token Type Names\nThe basic way to declare a token type name (terminal symbol) is as follows:\n%token name \u0026hellip; name %token  name \u0026hellip; name\nOcamlyacc will convert this into a token type in the parser, so that the lexer function can use the name name to stand for this token type\u0026rsquo;s code.\nIn the event that the token has a value, you must augment the %token declaration to include the data type alternative delimited by angle-brackets (see Data Types of Semantic Values).\nFor example:\n%token  NUM /* define toke NUM and its type */\nThe type part is an arbitrary Caml type expression,\n4.7.2. Operator Precedence\nUse the %left, %right or %nonassoc declaration to specify token\u0026rsquo;s precedence and associativity, all at once. These are called precedence declarations. See Operator Precedence, for general information on operator precedence.\nThe syntax of a precedence declaration is\n%left symbols \u0026hellip;symbols %right symbols \u0026hellip;symbols %nonassoc symbols \u0026hellip;symbols\nThey specify the associativity and relative precedence for all the symbols:\nThe associativity of an operator op determines how repeated uses of the operator nest: whether x op y op z is parsed by grouping x with y first or by grouping y with z first. %left specifies left-associativity (grouping x with y first) and %right specifies right-associativity (grouping y with z first). %nonassoc specifies no associativity, which means that x op y op z is considered a syntax error.\nThe precedence of an operator determines how it nests with other operators. All the tokens declared in a single precedence declaration have equal precedence and nest together according to their associativity. When two tokens declared in different precedence declarations associate, the one declared later has the higher precedence and is grouped first.\n4.7.3. Nonterminal Symbols\nYou can declare the value type of each nonterminal symbol for which values are used. This is done with a %type declaration, like this:\n%type  nonterminal \u0026hellip; nonterminal\nHere nonterminal is the name of a nonterminal symbol, and type is the name of the type that you want. You can give any number of start nonterminal symbols in the same %type declaration, if they have the same value type. Use spaces to separate the symbol names.\nThis is necessary for start symbols. For the type part, see Token Type Names.\n4.7.4. The Start-Symbol\nYou have to declare the start symbols using %start declaration as follows:\n%start symbol \u0026hellip; symbol\nEach start symbol has a parsing function with the same name in the output file so you can use it as an entry point for the grammar. As noted eariler, type should be assinged to each start symbol using %type directive (see Nonterminal Symbols).\n4.7.5. Ocamlyacc Declaration Summary\nHere is a summary of the declarations used to define a grammar:\n%token Declare a terminal symbol (token type name) with no precedence or associativity specified (see Token Type Names).\n%right Declare a terminal symbol (token type name) that is right-associative (see Operator Precedence).\n%left Declare a terminal symbol (token type name) that is left-associative (see Operator Precedence).\n%nonassoc Declare a terminal symbol (token type name) that is nonassociative (using it in a way that would be associative is a syntax error) (see Operator Precedence).\n%type Declare the type of semantic values for a nonterminal symbol (see Nonterminal Symbols).\n%start Specify the grammar\u0026rsquo;s start symbol (see The Start-Symbol).\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/panedwindow/",
	"title": "Paned window widget",
	"tags": [],
	"description": "The aspect frame widget is like a frame widget, except that it also enforces the aspect ratio (that is, the ratio of the width to the height) of the child widget to have a certain value, adding extra space if necessary.",
	"content": "The paned window widgets are useful when you want to divide an area into two parts, with the relative size of the two parts controlled by the user. A groove is drawn between the two portions with a handle that the user can drag to change the ratio. The division can either be horizontal (`HORIZONTAL) or vertical (`VERTICAL).\nTo create a new paned window, call GPack.paned with orientation(`HORIZONTAL or `VERTICAL):\nval GPack.paned : Gtk.Tags.orientation -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; paned After creating the paned window widget, you need to add child widgets to its two halves. To do this, use the functions:\nmethod add1 : GObj.widget -\u0026gt; unit method add2 : GObj.widget -\u0026gt; unit add1 method adds the child widget to the left or top half of the paned window. add2 method adds the child widget to the right or bottom half of the paned window.\nAs an example, we will create part of the user interface of an imaginary email program. A window is divided into two portions vertically, with the top portion being a list of email messages and the bottom portion the text of the email message. Most of the program is pretty straightforward. A couple of points to note: text can\u0026rsquo;t be added to a Text widget until it is realized. This could be done by calling #misc#realize method, but as a demonstration of an alternate technique, we connect a handler to the \u0026ldquo;realize\u0026rdquo; signal to add the text. Also, we need to add the GTK_SHRINK option to some of the items in the table containing the text window and its scrollbars, so that when the bottom portion is made smaller, the correct portions shrink instead of being pushed off the bottom of the window.\n(* file: paned.ml *) let cols = new GTree.column_list let str_col = cols#add Gobject.Data.string (* Create the list of \u0026#34;messages\u0026#34; *) let create_list () = (* Create a new scrolled window, with scrollbars only if needed *) let scrolled_window = GBin.scrolled_window ~hpolicy:`AUTOMATIC ~vpolicy:`AUTOMATIC () in let model = GTree.list_store cols in let treeview = GTree.view ~model ~packing:(scrolled_window#add_with_viewport) () in for i = 0 to 10 do let iter = model#append () in model#set ~row:iter ~column:str_col (Printf.sprintf \u0026#34;Message #%d\u0026#34; i) done; let renderer = GTree.cell_renderer_text [] in let column = GTree.view_column ~title:\u0026#34;Messages\u0026#34; ~renderer:(renderer, [\u0026#34;text\u0026#34;, str_col]) () in treeview#append_column column; scrolled_window#coerce (* Add some text to our text widget - this is a callback that is invoked * when our window is realized. We could also force our window to be * realized with #misc#realize, but it would have to be part of * a hierarchy first *) let insert_text (buffer: GText.buffer) = let iter = buffer#get_iter `START in buffer#insert ~iter ( \u0026#34;From: pathfinder@nasa.gov\\n\u0026#34; ^ \u0026#34;To: mom@nasa.gov\\n\u0026#34; ^ \u0026#34;Subject: Made it!\\n\u0026#34; ^ \u0026#34;\\n\u0026#34; ^ \u0026#34;We just got in this morning. The weather has been\\n\u0026#34; ^ \u0026#34;great - clear but cold, and there are lots of fun sights.\\n\u0026#34; ^ \u0026#34;Sojourner says hi. See you soon.\\n\u0026#34; ^ \u0026#34; -Path\\n\u0026#34;) (* Create a scrolled text area that displays a \u0026#34;message\u0026#34; *) let create_text () = let scrolled_window = GBin.scrolled_window ~hpolicy:`AUTOMATIC ~vpolicy:`AUTOMATIC () in let view = GText.view ~packing:scrolled_window#add () in let buffer = view#buffer in insert_text buffer; scrolled_window#coerce let main () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Paned Windows\u0026#34; ~border_width:10 ~width:450 ~height:400 () in (* Set a handler for destroy event that immediately exits GTK. *) window#connect#destroy ~callback:GMain.Main.quit; (* create a vpaned widget and add it to our toplevel window *) let vpaned = GPack.paned `VERTICAL ~packing:window#add () in (* Now create the contents of the two halves of the window *) let list = create_list () in vpaned#add1 list; let text = create_text () in vpaned#add2 text; window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/stages/",
	"title": "Stages in use ocamlyacc",
	"tags": [],
	"description": "The actual language-design process using Ocamlyacc, from grammar specification to a working compiler or interpreter, has these parts:",
	"content": "The actual language-design process using Ocamlyacc, from grammar specification to a working compiler or interpreter, has these parts:\nFormally specify the grammar in a form recognized by Ocamlyacc (see Ocamlyacc Grammar Files). For each grammatical rule in the language, describe the action that is to be taken when an instance of that rule is recognized. The action is described by a sequence of Ocaml statements.\nWrite a lexical analyzer to process input and pass tokens to the parser. The lexical analyzer may be written by hand in Ocaml (see The Lexical Analyzer Function). It could also be produced using ocamllex, but the use of ocamllex is not discussed in this manual.\nWrite a controlling function that calls the Ocamlyacc-produced parser.\nWrite error-reporting routines.\nTo turn this source code as written into a runnable program, you must follow these steps:\nRun Ocamlyacc on the grammar to produce the parser.\nCompile the code output by Ocamlyacc, as well as any other source files.\nLink the object files to produce the finished product.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/statusbars/",
	"title": "Statusbars",
	"tags": [],
	"description": "Statusbars are simple widgets used to display a text message.",
	"content": "Statusbars are simple widgets used to display a text message. They keep a stack of the messages pushed onto them, so that popping the current message will re-display the previous text message.\nIn order to allow different parts of an application to use the same statusbar to display messages, the statusbar widget issues Context Identifiers which are used to identify different \u0026ldquo;users\u0026rdquo;. The message on top of the stack is the one displayed, no matter what context it is in. Messages are stacked in last-in-first-out order, not context identifier order.\nA statusbar is created with a call to GMisc.status_bar :\nval GMisc.statusbar : ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; statusbar A new Context Identifier is requested using a call to the following function with a short textual description of the context:\nmethod new_context : name:string -\u0026gt; statusbar_context There are three functions that can operate on statusbar_contexts:\nmethod push : string -\u0026gt; Gtk.statusbar_message method pop : unit -\u0026gt; unit method remove : Gtk.statusbar_message -\u0026gt; unit The first, push method, is used to add a new message to the statusbar. It returns a Message Identifier, which can be passed later to the remove method to remove the message with the given Message Identifiers and Context from the statusbar\u0026rsquo;s stack.\nThe method pop removes the message highest in the stack with the given Context.\nThe following example creates a statusbar and two buttons, one for pushing items onto the statusbar, and one for popping the last item back off.\n(* file: statusbar.ml *) let count = ref 0 let push_item context () = incr count; context#push (Printf.sprintf \u0026#34;item %d\u0026#34; !count); () let pop_item context () = context#pop (); () let main () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Statusbar\u0026#34; () in (* Set a handler for destroy event that immediately exits GTK. *) window#connect#destroy ~callback:GMain.Main.quit; let vbox = GPack.vbox ~packing:window#add () in let statusbar = GMisc.statusbar ~packing:vbox#add () in let context = statusbar#new_context ~name:\u0026#34;Statusbar example\u0026#34; in let button = GButton.button ~label:\u0026#34;push item\u0026#34; ~packing:vbox#add () in button#connect#clicked ~callback:(push_item context); let button = GButton.button ~label:\u0026#34;pop last item\u0026#34; ~packing:vbox#add () in button#connect#clicked ~callback:(pop_item context); (* always display the window as the last step so it all splashes on * the screen at once. *) window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/adjustments/",
	"title": "Adjustments",
	"tags": [],
	"description": "GTK has various widgets that can be visually adjusted by the user using the mouse or the keyboard, such as the range widgets, described in the Range Widgets section.",
	"content": "GTK has various widgets that can be visually adjusted by the user using the mouse or the keyboard, such as the range widgets, described in the Range Widgets section. There are also a few widgets that display some adjustable portion of a larger area of data, such as the text widget and the viewport widget.\nObviously, an application needs to be able to react to changes the user makes in range widgets. One way to do this would be to have each widget emit its own type of signal when its adjustment changes, and either pass the new value to the signal handler, or require it to look inside the widget\u0026rsquo;s data structure in order to ascertain the value. But you may also want to connect the adjustments of several widgets together, so that adjusting one adjusts the others. The most obvious example of this is connecting a scrollbar to a panning viewport or a scrolling text area. If each widget has its own way of setting or getting the adjustment value, then the programmer may have to write their own signal handlers to translate between the output of one widget\u0026rsquo;s signal and the \u0026ldquo;input\u0026rdquo; of another\u0026rsquo;s adjustment setting function.\nGTK solves this problem using the Adjustment object, which is not a widget but a way for widgets to store and pass adjustment information in an abstract and flexible form. The most obvious use of Adjustment is to store the configuration parameters and values of range widgets, such as scrollbars and scale controls. However, since Adjustments are derived from Object, they have some special powers beyond those of normal data structures. Most importantly, they can emit signals, just like widgets, and these signals can be used not only to allow your program to react to user input on adjustable widgets, but also to propagate adjustment values transparently between adjustable widgets.\nYou will see how adjustments fit in when you see the other widgets that incorporate them: Progress Bars, Viewports, Scrolled Windows, and others.\n Creating an adjustment  For many constructor or method arguments, default values are provided.\n Using adjustments  Using adjustments\n Adjustment internals  Using adjustments\n "
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/debugging/",
	"title": "Debugging your parser",
	"tags": [],
	"description": "To debug the parser generated by ocamlyacc: ...",
	"content": "To debug the parser generated by ocamlyacc:\n Generate parsing infomation in the file grammar.output using -v option (like \u0026ldquo;ocamlyacc -v filneme.mly\u0026rdquo;): the information consists of the parsing table and a report on conflicts.\n Set p option of the OCAMLRUNPARAM environment variable: for example, execute \u0026ldquo;export OCAMLRUNPARAM=\u0026lsquo;p\u0026rsquo; \u0026rdquo; on bash shell.\n  The parser prints messages about its actions such as shifting a token, reducing a rule.\nYou can find rule numbers and state numbers mentioned in the messages at the file grammar.output.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/concepts/overalllayout/",
	"title": "Overall layout of grammar",
	"tags": [],
	"description": "The general form of a Ocamlyacc grammar file is as follows:",
	"content": "The input file for the Ocamlyacc utility is a Ocamlyacc grammar file. The general form of a Ocamlyacc grammar file is as follows:\n%{ Header (Ocaml code) %} Ocamlyacc declarations %% Grammar rules %% Trailer (Additional Ocaml code)\nThe %%, %{ and %} are punctuation that appears in every Ocamlyacc grammar file to separate the sections.\nThe header may define types, variables and functions used in the actions.\nThe Ocamlyacc declarations declare the names of the terminal and nonterminal symbols, and may also describe operator precedence and the data types of semantic values of various symbols.\nThe grammar rules define how to construct each nonterminal symbol from its parts.\nThe Trailer can contain any Ocaml code you want to use.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/textentry/",
	"title": "Text entry",
	"tags": [],
	"description": "The Entry widget allows text to be typed and displayed in a single line text box.",
	"content": "The Entry widget allows text to be typed and displayed in a single line text box. The text may be set with function calls that allow new text to replace, prepend or append the current contents of the Entry widget.\nCreate a new Entry widget with the function GEdit.entry.\nval GEdit.entry : ?text:string -\u0026gt; ?visibility:bool -\u0026gt; ?max_length:int -\u0026gt; ?activates_default:bool -\u0026gt; ?editable:bool -\u0026gt; ?has_frame:bool -\u0026gt; ?width_chars:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; entry The next method alters the text which is currently within the Entry widget.\nmethod set_text : string -\u0026gt; unit The set_text method sets the contents of the Entry widget, replacing the current contents. Note that the class Entry implements the Editable interface (yes, gobject supports Java-like interfaces) which contains some more functions for manipulating the contents.\nThe contents of the Entry can be retrieved by using a call to the following method. This is useful in the callback functions described below.\nmethod text : string If we don\u0026rsquo;t want the contents of the Entry to be changed by someone typing into it, we can change its editable state.\nmethod set_editable : bool -\u0026gt; unit The method above allows us to toggle the editable state of the Entry widget by passing in a true or false value as argument.\nIf we are using the Entry where we don\u0026rsquo;t want the text entered to be visible, for example when a password is being entered, we can use the following method, which also takes a boolean flag.\nmethod set_visibility : bool -\u0026gt; unit A region of the text may be set as selected by using the following method. This would most often be used after setting some default text in an Entry, making it easy for the user to remove it.\nmethod select_region : start:int -\u0026gt; stop:int -\u0026gt; unit If we want to catch when the user has entered text, we can connect to the activate or changed signal. Activate is raised when the user hits the enter key within the Entry widget. Changed is raised when the text changes at all, e.g., for every character entered or removed.\nThe following code is an example of using an Entry widget.\n(* file: entry.ml *) let enter_cb entry () = let text = entry#text in Printf.printf \u0026#34;Entry contents: %s\\n\u0026#34; text; flush stdout let toggle checkbutton f () = f checkbutton#active let main () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Entry\u0026#34; ~width:200 ~height:100 ~border_width:10 () in (* Set a handler for destroy event that immediately exits GTK. *) window#connect#destroy ~callback:GMain.Main.quit; let vbox = GPack.vbox ~packing:window#add () in let entry = GEdit.entry ~text:\u0026#34;hello\u0026#34; ~max_length:500 ~packing:vbox#add () in entry#connect#activate ~callback:(enter_cb entry); let tmp_pos = entry#text_length in entry#insert_text \u0026#34; world\u0026#34; tmp_pos; entry#select_region ~start:0 ~stop:entry#text_length; let hbox = GPack.hbox ~packing:vbox#add () in let check = GButton.check_button ~label:\u0026#34;Editable\u0026#34; ~active:true ~packing:hbox#add () in check#connect#toggled ~callback:(toggle check entry#set_editable); let check = GButton.check_button ~label:\u0026#34;Visible\u0026#34; ~active:true ~packing:hbox#add () in check#connect#toggled ~callback:(toggle check entry#set_visibility); let button = GButton.button ~stock:`CLOSE ~packing:vbox#add () in button#connect#clicked ~callback:window#destroy; button#misc#set_can_default true; button#misc#grab_default (); window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/viewports/",
	"title": "View ports",
	"tags": [],
	"description": "It is unlikely that you will ever need to use the Viewport widget directly. You are much more likely to use the Scrolled Window widget which itself uses the Viewport.",
	"content": "It is unlikely that you will ever need to use the Viewport widget directly. You are much more likely to use the Scrolled Window widget which itself uses the Viewport.\nA viewport widget allows you to place a larger widget within it such that you can view a part of it at a time. It uses Adjustments to define the area that is currently in view.\nA Viewport is created with the function GBin.viewport\nval GBin.viewport : ?hadjustment:GData.adjustment -\u0026gt; ?vadjustment:GData.adjustment -\u0026gt; ?shadow_type:Gtk.Tags.shadow_type -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; viewport As you can see you can specify the horizontal and vertical Adjustments that the widget is to use when you create the widget. It will create its own if you don\u0026rsquo;t pass the arguments.\nYou can get and set the adjustments after the widget has been created using the following four functions:\nmethod hadjustment : GData.adjustment method vadjustment : GData.adjustment method set_hadjustment : GData.adjustment -\u0026gt; unit method set_vadjustment : GData.adjustment -\u0026gt; unit The other viewport function is used to alter its appearance:\nmethod set_shadow_type : Gtk.Tags.shadow_type -\u0026gt; unit Possible values for the Gtk.Tags.shadow_type parameter are:\n`NONE, `IN, `OUT, `ETCHED_IN, `ETCHED_OUT"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/invokingocamlyacc/",
	"title": "Invoking Ocamlyacc",
	"tags": [],
	"description": "",
	"content": "The usual way to invoke Bison is as follows:\nocamlyacc filename.mly  Here filename.mly is the grammar file name. The parser file\u0026rsquo;s name is made by replacing the .mly with .ml. Thus, the \u0026ldquo;ocamlyacc foo.mly\u0026rdquo; yields foo.ml.\n Options  Ocamlyacc options\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/rangewidgets/",
	"title": "Range widgets",
	"tags": [],
	"description": "The category of range widgets includes the ubiquitous scrollbar widget and the less common scale widget.",
	"content": "The category of range widgets includes the ubiquitous scrollbar widget and the less common scale widget. Though these two types of widgets are generally used for different purposes, they are quite similar in function and implementation. All range widgets share a set of common graphic elements, each of which has its own X window and receives events. They all contain a \u0026ldquo;trough\u0026rdquo; and a \u0026ldquo;slider\u0026rdquo; (what is sometimes called a \u0026ldquo;thumbwheel\u0026rdquo; in other GUI environments). Dragging the slider with the pointer moves it back and forth within the trough, while clicking in the trough advances the slider towards the location of the click, either completely, or by a designated amount, depending on which mouse button is used.\nAs mentioned in Adjustments above, all range widgets are associated with an adjustment object, from which they calculate the length of the slider and its position within the trough. When the user manipulates the slider, the range widget will change the value of the adjustment.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/scrolledwindows/",
	"title": "Scrolled windows",
	"tags": [],
	"description": "Scrolled windows are used to create a scrollable area with another widget inside it.",
	"content": "Scrolled windows are used to create a scrollable area with another widget inside it. You may insert any type of widget into a scrolled window, and it will be accessible regardless of the size by using the scrollbars.\nThe function GBin.scrolled_window is used to create a new scrolled window.\nval GBin.scrolled_window : ?hadjustment:GData.adjustment -\u0026gt; ?vadjustment:GData.adjustment -\u0026gt; ?hpolicy:Gtk.Tags.policy_type -\u0026gt; ?vpolicy:Gtk.Tags.policy_type -\u0026gt; ?placement:Gtk.Tags.corner_type -\u0026gt; ?shadow_type:Gtk.Tags.shadow_type -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; scrolled_window Where the argument hadjustment is the adjustment for the horizontal direction, and vadjustment, the adjustment for the vertical direction. These are almost always not given.\nmethod set_hpolicy : Gtk.Tags.policy_type -\u0026gt; unit method set_vpolicy : Gtk.Tags.policy_type -\u0026gt; unit This sets the policy to be used with respect to the scrollbars. The set_hpolicy sets the policy for the horizontal scrollbar, and the set_vpolicy for the vertical scrollbar.\nThe policy may be one of `AUTOMATIC or `ALWAYS. `AUTOMATIC will automatically decide whether you need scrollbars, whereas `ALWAYS will always leave the scrollbars there.\nYou can then place your object into the scrolled window using the following function.\nmethod add_with_viewport : GObj.widget -\u0026gt; unit Here is a simple example that packs a table with 100 toggle buttons into a scrolled window. I\u0026rsquo;ve only commented on the parts that may be new to you.\n(* file: scrolledwin.ml *) let main () = (* Create a new dialog window for the scrolled window to be * packed into. *) let window = GWindow.dialog ~title:\u0026#34;ScrolledWindow example\u0026#34; ~width:300 ~height:300 ~border_width:0 () in window#connect#destroy ~callback:GMain.Main.quit; (* Create a new scrolled window *) let scrolled_window = GBin.scrolled_window ~border_width:10 ~hpolicy:`AUTOMATIC ~vpolicy:`AUTOMATIC ~packing:window#vbox#add () in (* Create a table of 10 by 10 squares. * Set the spacing to 10 on x and 10 on y *) let table = GPack.table ~rows:10 ~columns:10 ~row_spacings:10 ~col_spacings:10 ~packing:scrolled_window#add_with_viewport () in for i = 0 to 10 do for j=0 to 10 do GButton.toggle_button ~label:(\u0026#34;button (\u0026#34;^ string_of_int i ^\u0026#34;,\u0026#34;^ string_of_int j ^\u0026#34;)\\n\u0026#34;) ~packing:(table#attach ~left:i ~top:j ~expand:`BOTH) () done done; (* Add a \u0026#34;close\u0026#34; button to the bottom of the dialog *) let button = GButton.button ~label:\u0026#34;close\u0026#34; ~packing:window#action_area#add () in button#connect#clicked ~callback:(window#destroy); (* This grabs this button to be the default button. Simply hitting * the \u0026#34;Enter\u0026#34; key will cause this button to activate. *) button#grab_default (); window#show (); GMain.Main.main () let _ = Printexc.print main () Try playing with resizing the window. You\u0026rsquo;ll notice how the scrollbars react. You may also wish to use the #misc#set_size_request method call to set the default size of the window or other widgets.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/spinbutton/",
	"title": "Spin button",
	"tags": [],
	"description": "The Spin Button widget is generally used to allow the user to select a value from a range of numeric values.",
	"content": "The Spin Button widget is generally used to allow the user to select a value from a range of numeric values. It consists of a text entry box with up and down arrow buttons attached to the side. Selecting one of the buttons causes the value to \u0026ldquo;spin\u0026rdquo; up and down the range of possible values. The entry box may also be edited directly to enter a specific value.\nThe Spin Button allows the value to have zero or a number of decimal places and to be incremented/decremented in configurable steps. The action of holding down one of the buttons optionally results in an acceleration of change in the value according to how long it is depressed.\nThe Spin Button uses an Adjustment object to hold information about the range of values that the spin button can take. This makes for a powerful Spin Button widget.\nRecall that an adjustment widget is created with the function GData.adjustment, which illustrates the information that it holds:\nval GData.adjustment : ?value:float -\u0026gt; ?lower:float -\u0026gt; ?upper:float -\u0026gt; ?step_incr:float -\u0026gt; ?page_incr:float -\u0026gt; ?page_size:float -\u0026gt; unit -\u0026gt; adjustment lower : default value is 0. upper : default value is 100. step_incr : default value is 1. page_incr : default value is 10. page_size : default value is 10. These attributes of an Adjustment are used by the Spin Button in the following way:\n value: initial value for the Spin Button lower: lower range value upper: upper range value step_increment: value to increment/decrement when pressing mouse button 1 on a button page_increment: value to increment/decrement when pressing mouse button 2 on a button page_size: unused  Additionally, mouse button 3 can be used to jump directly to the upper or lower values when used to select one of the buttons. Lets look at how to create a Spin Button using GEdit.spin_button:\nval GEdit.spin_button : ?adjustment:GData.adjustment -\u0026gt; ?rate:float -\u0026gt; ?digits:int -\u0026gt; ?numeric:bool -\u0026gt; ?snap_to_ticks:bool -\u0026gt; ?update_policy:[ `ALWAYS | `IF_VALID ] -\u0026gt; ?value:float -\u0026gt; ?wrap:bool -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; spin_button The rate argument take a value between 0.0 and 1.0 and indicates the amount of acceleration that the Spin Button has. The digits argument specifies the number of decimal places to which the value will be displayed.\nA Spin Button can be reconfigured after creation using the following methods:\nmethod set_adjustment : GData.adjustment -\u0026gt; unit method set_rate : float -\u0026gt; unit method set_digits : int -\u0026gt; unit The adjustment can be retrieved using the following function:\nmethod adjustment : GData.adjustment The value that a Spin Button is currently displaying can be changed using the following function:\nmethod set_value : float -\u0026gt; unit The current value of a Spin Button can be retrieved as either a floating point or integer value with the following functions:\nmethod value : float method value_as_int : int If you want to alter the value of a Spin Button relative to its current value, then the following function can be used:\nmethod spin : Gtk.Tags.spin_type -\u0026gt; unit The argument can take one of the following values:\n`STEP_FORWARD `STEP_BACKWARD `PAGE_FORWARD `PAGE_BACKWARD `HOME `END `USER_DEFINED of float This function packs in quite a bit of functionality, which I will attempt to clearly explain. Many of these settings use values from the Adjustment object that is associated with a Spin Button.\n `STEP_FORWARD and `STEP_BACKWARD change the value of the Spin Button by the amount specified by increment, unless increment is equal to 0, in which case the value is changed by the value of step_increment in theAdjustment. `PAGE_FORWARD and `PAGE_BACKWARD simply alter the value of the Spin Button by increment. `HOME sets the value of the Spin Button to the bottom of the Adjustments range. `END sets the value of the Spin Button to the top of the Adjustments range. `USER_DEFINED simply alters the value of the Spin Button by the specified amount.  We move away from functions for setting and retreving the range attributes of the Spin Button now, and move onto functions that effect the appearance and behaviour of the Spin Button widget itself.\nThe first of these functions is used to constrain the text box of the Spin Button such that it may only contain a numeric value. This prevents a user from typing anything other than numeric values into the text box of a Spin Button:\nmethod set_numeric : bool -\u0026gt; unit You can set whether a Spin Button will wrap around between the upper and lower range values with the following function:\nmethod set_wrap : bool -\u0026gt; unit You can set a Spin Button to round the value to the nearest step_increment, which is set within the Adjustment object used with the Spin Button. This is accomplished with the following function:\nmethod set_snap_to_ticks : bool -\u0026gt; unit The update policy of a Spin Button can be changed with the following function:\nmethod set_update_policy : [ `ALWAYS | `IF_VALID ] -\u0026gt; unit The possible values of policy are either `ALWAYS or `IF_VALID.\nThese policies affect the behavior of a Spin Button when parsing inserted text and syncing its value with the values of the Adjustment.\nIn the case of `IF_VALID the Spin Button only value gets changed if the text input is a numeric value that is within the range specified by the Adjustment. Otherwise the text is reset to the current value.\nIn case of `ALWAYS we ignore errors while converting text into a numeric value.\nFinally, you can explicitly request that a Spin Button update itself:\nmethod update : unit It\u0026rsquo;s example time again.\n(* file: spinbutton.ml *) let toggle checkbutton f () = f checkbutton#active let get_value spinner label show_type () = let text = match show_type with | `INT -\u0026gt; Printf.sprintf \u0026#34;%d\u0026#34; spinner#value_as_int | _ -\u0026gt; Printf.sprintf \u0026#34;%0.*f\u0026#34; spinner#digits spinner#value in label#set_text text let main () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Spin Button\u0026#34; ~border_width:10 () in (* Set a handler for destroy event that immediately exits GTK. *) window#connect#destroy ~callback:GMain.Main.quit; let main_vbox = GPack.vbox ~border_width:10 ~packing:window#add () in let frame = GBin.frame ~label:\u0026#34;Not accelerated\u0026#34; ~packing:main_vbox#add () in let vbox = GPack.vbox ~border_width:5 ~packing:frame#add () in (* Day, month, year spinners *) let hbox = GPack.hbox ~packing:vbox#add () in let vbox2 = GPack.vbox ~packing:hbox#add () in let label = GMisc.label ~text:\u0026#34;Day :\u0026#34; ~xalign:0.0 ~yalign:0.5 ~packing:vbox2#add () in let adj = GData.adjustment ~value:1.0 ~lower:1.0 ~upper:31.0 ~step_incr:1.0 ~page_incr:5.0 ~page_size:0.0 () in let spinner = GEdit.spin_button ~adjustment:adj ~rate:0.0 ~digits:0 ~wrap:true ~packing:vbox2#add () in let vbox2 = GPack.vbox ~packing:hbox#add () in let label = GMisc.label ~text:\u0026#34;Month :\u0026#34; ~xalign:0.0 ~yalign:0.5 ~packing:vbox2#add () in let adj = GData.adjustment ~value:1.0 ~lower:1.0 ~upper:12.0 ~step_incr:1.0 ~page_incr:5.0 ~page_size:0.0 () in let spinner = GEdit.spin_button ~adjustment:adj ~rate:0.0 ~digits:0 ~wrap:true ~packing:vbox2#add () in let vbox2 = GPack.vbox ~packing:hbox#add () in let label = GMisc.label ~text:\u0026#34;Year :\u0026#34; ~xalign:0.0 ~yalign:0.5 ~packing:vbox2#add () in let adj = GData.adjustment ~value:1998.0 ~lower:0.0 ~upper:2100.0 ~step_incr:1.0 ~page_incr:100.0 ~page_size:0.0 () in let spinner = GEdit.spin_button ~adjustment:adj ~rate:0.0 ~digits:0 ~wrap:false ~width:55 ~packing:vbox2#add () in let frame = GBin.frame ~label:\u0026#34;Accelerated\u0026#34; ~packing:main_vbox#add () in let vbox = GPack.vbox ~border_width:5 ~packing:frame#add () in let hbox = GPack.hbox ~packing:vbox#add () in let vbox2 = GPack.vbox ~packing:hbox#add () in let label = GMisc.label ~text:\u0026#34;Value :\u0026#34; ~xalign:0.0 ~yalign:0.5 ~packing:vbox2#add () in let adj = GData.adjustment ~value:0.0 ~lower:(-10000.0) ~upper:10000.0 ~step_incr:0.5 ~page_incr:100.0 ~page_size:0.0 () in let spinner1 = GEdit.spin_button ~adjustment:adj ~rate:1.0 ~digits:2 ~width:100 ~packing:vbox2#add () in let vbox2 = GPack.vbox ~packing:hbox#add () in let label = GMisc.label ~text:\u0026#34;Digits :\u0026#34; ~xalign:0.0 ~yalign:0.5 ~packing:vbox2#add () in let adj = GData.adjustment ~value:2.0 ~lower:1.0 ~upper:5.0 ~step_incr:1.0 ~page_incr:1.0 ~page_size:0.0 () in let spinner2 = GEdit.spin_button ~adjustment:adj ~rate:0.0 ~digits:0 ~packing:vbox2#add () in adj#connect#value_changed ~callback:(fun () -\u0026gt; spinner1#set_digits spinner2#value_as_int); let button = GButton.check_button ~label:\u0026#34;Snap to 0.5-ticks\u0026#34; ~packing:vbox#add () in button#connect#clicked ~callback:(toggle button spinner1#set_snap_to_ticks); let button = GButton.check_button ~label:\u0026#34;Numeric only input mode\u0026#34; ~active:true ~packing:vbox#add () in button#connect#clicked ~callback:(toggle button spinner1#set_numeric); let hbox = GPack.hbox ~packing:vbox#add () in let val_label = GMisc.label ~text:\u0026#34;0\u0026#34; ~packing:vbox#add () in let button = GButton.button ~label:\u0026#34;Value as Int\u0026#34; ~packing:hbox#add () in button#connect#clicked ~callback:(get_value spinner1 val_label `INT); let button = GButton.button ~label:\u0026#34;Value as Float\u0026#34; ~packing:hbox#add () in button#connect#clicked ~callback:(get_value spinner1 val_label `FLOAT); let hbox = GPack.hbox ~packing:main_vbox#add () in let button = GButton.button ~label:\u0026#34;Close\u0026#34; ~packing:hbox#add () in button#connect#clicked ~callback:window#destroy; window#show (); (* Enter the event loop *) GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/buttonboxes/",
	"title": "Button boxes",
	"tags": [],
	"description": "Button Boxes are a convenient way to quickly layout a group of buttons.",
	"content": "Button Boxes are a convenient way to quickly layout a group of buttons. They come in both horizontal and vertical flavours. You create a new Button Box with the following function GPack.button_box , which create a horizontal or vertical box according to the given argument ;`HORIZONTAL or `VERTICAL:\nval GPack.button_box : Gtk.Tags.orientation -\u0026gt; ?spacing:int -\u0026gt; ?child_width:int -\u0026gt; ?child_height:int -\u0026gt; ?child_ipadx:int -\u0026gt; ?child_ipady:int -\u0026gt; ?layout:GtkPack.BBox.bbox_style -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; button_box Buttons are added to a Button Box using the usual function:\nmethod add : GObj.widget -\u0026gt; unit Here\u0026rsquo;s an example that illustrates all the different layout settings for Button Boxes.\n(* file: buttonbox.ml *) (* Create a Buttn Box with the specified parameters *) let create_bbox direction title spacing child_width child_height layout = let frame = GBin.frame ~label:title () in let bbox = GPack.button_box direction ~border_width:5 ~layout ~child_height ~child_width ~spacing ~packing:frame#add () in GButton.button ~stock:`OK ~packing:bbox#add (); GButton.button ~stock:`CANCEL ~packing:bbox#add (); GButton.button ~stock:`HELP ~packing:bbox#add (); frame#coerce let main () = let window = GWindow.window ~title:\u0026#34;Button Boxes\u0026#34; ~border_width:10 () in window #connect#destroy ~callback:GMain.Main.quit; let main_vbox = GPack.vbox ~packing:window#add () in let frame_horz = GBin.frame ~label:\u0026#34;Horizontal Button Boxes\u0026#34; ~packing:(main_vbox#pack ~expand:true ~fill:true ~padding:10) () in let vbox = GPack.vbox ~border_width:10 ~packing:frame_horz#add () in vbox#add (create_bbox `HORIZONTAL \u0026#34;Spread (spacing 40)\u0026#34; 40 85 20 `SPREAD); vbox#pack (create_bbox `HORIZONTAL \u0026#34;Edge (spacing 30)\u0026#34; 30 85 20 `EDGE) ~expand:true ~fill:true ~padding:5; vbox#pack (create_bbox `HORIZONTAL \u0026#34;Start (spacing 20)\u0026#34; 20 85 20 `START) ~expand:true ~fill:true ~padding:5; vbox#pack (create_bbox `HORIZONTAL \u0026#34;End (spacing 10)\u0026#34; 10 85 20 `END) ~expand:true ~fill:true ~padding:5; let frame_vert = GBin.frame ~label:\u0026#34;Vertical Button Boxes\u0026#34; ~packing:(main_vbox#pack ~expand:true ~fill:true ~padding:10) () in let hbox = GPack.hbox ~border_width:10 ~packing:frame_vert#add () in hbox#add (create_bbox `VERTICAL \u0026#34;Spread (spacing 5)\u0026#34; 5 85 20 `SPREAD); hbox#pack (create_bbox `VERTICAL \u0026#34;Edge (spacing 30)\u0026#34; 30 85 20 `EDGE) ~expand:true ~fill:true ~padding:5; hbox#pack (create_bbox `VERTICAL \u0026#34;Start (spacing 20)\u0026#34; 20 85 20 `START) ~expand:true ~fill:true ~padding:5; hbox#pack (create_bbox `VERTICAL \u0026#34;End (spacing 20)\u0026#34; 20 85 20 `END) ~expand:true ~fill:true ~padding:5; window#show (); (* Enter the event loop *) GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/combobox/",
	"title": "Combo box",
	"tags": [],
	"description": "The combo box is another fairly simple widget that is really just a collection of other widgets.",
	"content": "The combo box is another fairly simple widget that is really just a collection of other widgets. From the user\u0026rsquo;s point of view, the widget consists of a text entry box and a pull down menu from which the user can select one of a set of predefined entries. Alternatively, the user can type a different option directly into the text box.\nThe following extract child widgets from a Combo Box:\nmethod entry : entry method list : GList.liste As you can see, the Combo Box has two principal parts that you really care about: an entry and a list.\nFirst off, to create a combo box, use GEdit.combo:\nval GEdit.combo : ?popdown_strings:string list -\u0026gt; ?allow_empty:bool -\u0026gt; ?case_sensitive:bool -\u0026gt; ?enable_arrow_keys:bool -\u0026gt; ?value_in_list:bool -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; combo Now, if you want to set the string in the entry section of the combo box, this is done by manipulating the entry widget directly:\ncombo#entry#set_text \u0026#34;My String\u0026#34;; To set the values in the popdown list, one uses the function:\nmethod set_popdown_strings : string list -\u0026gt; unit At this point you have a working combo box that has been set up. There are a few aspects of its behavior that you can change. These are accomplished with the functions:\nmethod set_enable_arrow_keys : bool -\u0026gt; unit method set_case_sensitive : bool -\u0026gt; unit set_enable_arrow_keys method lets the user change the value in the entry using the up/down arrow keys. This doesn\u0026rsquo;t bring up the list, but rather replaces the current text in the entry with the next list entry (up or down, as your key choice indicates). It does this by searching in the list for the item corresponding to the current value in the entry and selecting the previous/next item accordingly. Usually in an entry the arrow keys are used to change focus (you can do that anyway using TAB). Note that when the current item is the last of the list and you press arrow-down it changes the focus (the same applies with the first item and arrow-up).\nIf the current value in the entry is not in the list, then the function of set_enable_arrow_keys is disabled.\nset_case_sensitive method toggles whether or not GTK searches for entries in a case sensitive manner. This is used when the Combo widget is asked to find a value from the list using the current entry in the text box. This completion can be performed in either a case sensitive or insensitive manner, depending upon the use of this function. The Combo widget can also simply complete the current entry if the user presses the key combination MOD-1 and \u0026ldquo;Tab\u0026rdquo;. MOD-1 is often mapped to the \u0026ldquo;Alt\u0026rdquo; key, by the xmodmap utility. Note, however that some window managers also use this key combination, which will override its use within GTK.\nNow that we have a combo box, tailored to look and act how we want it, all that remains is being able to get data from the combo box. This is relatively straightforward. The majority of the time, all you are going to care about getting data from is the entry. The entry is accessed simply by combo#entry. The two principal things that you are going to want to do with it are connect to the activate signal, which indicates that the user has pressed the Return or Enter key, and read the text. The first is accomplished using something like:\ncombo#entry#connect#activate ~callback:my_callback; Getting the text at any arbitrary time is accomplished by simply using the entry function such as:\nlet text = combo#entry#text in ... That\u0026rsquo;s about all there is to it. There is a function\nmethod disable_activate : unit -\u0026gt; unit that will disable the activate signal on the entry widget in the combo box. Personally, I can\u0026rsquo;t think of why you\u0026rsquo;d want to use it, but it does exist.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/ocamlyacc-tutorial/license/",
	"title": "License",
	"tags": [],
	"description": "",
	"content": "  Bison license  Bison License\n Copyright and permission  Copyright and Permission\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/",
	"title": "Miscellaneous widgets",
	"tags": [],
	"description": "Labels, arrows, tooltips, progress bars, dialog widgets, ...",
	"content": "  Labels  Labels are used a lot in GTK, and are relatively simple.\n Arrows  The Arrow widget draws an arrowhead, facing in a number of possible directions and having a number of possible styles.\n Tooltips object  The little text strings that pop up when you leave your pointer over a button or other widget for a few seconds.\n Progress bars  Progress bars are used to show the status of an operation.\n Dialog widgets  The Dialog widget is very simple, and is actually just a window with a few things pre-packed into it for you.\n Rulers  Ruler widgets are used to indicate the location of the mouse pointer in a given window.\n Statusbars  Statusbars are simple widgets used to display a text message.\n Text entry  The Entry widget allows text to be typed and displayed in a single line text box.\n Spin button  The Spin Button widget is generally used to allow the user to select a value from a range of numeric values.\n Combo box  The combo box is another fairly simple widget that is really just a collection of other widgets.\n Calendar  The Calendar widget is an effective way to display and retrieve monthly date related information.\n Color selection  The color selection widget is, not surprisingly, a widget for interactive selection of colors.\n File selection  The file selection widget is a quick and simple way to display a File dialog box.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/calendar/",
	"title": "Calendar",
	"tags": [],
	"description": "The Calendar widget is an effective way to display and retrieve monthly date related information.",
	"content": "The Calendar widget is an effective way to display and retrieve monthly date related information. It is a very simple widget to create and work with.\nCreating a GtkCalendar widget is a simple as: (see GMisc.calendar)\nval GMisc.calendar : ?options:Gtk.Tags.calendar_display_options list -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; calendar There might be times where you need to change a lot of information within this widget and the following functions allow you to make multiple change to a Calendar widget without the user seeing multiple on-screen updates.\nmethod freeze : unit -\u0026gt; unit method thaw : unit -\u0026gt; unit They work just like the freeze/thaw functions of every other widget.\nThe Calendar widget has a few options that allow you to change the way the widget both looks and operates by using the function\nmethod display_options : Gtk.Tags.calendar_display_options list -\u0026gt; unit The flags argument can be formed by combining either of the following five options:\n `SHOW_HEADING this option specifies that the month and year should be shown when drawing the calendar.\n `SHOW_DAY_NAMES this option specifies that the three letter descriptions should be displayed for each day (eg Mon,Tue, etc.).\n `NO_MONTH_CHANGE this option states that the user should not and can not change the currently displayed month. This can be good if you only need to display a particular month such as if you are displaying 12 calendar widgets for every month in a particular year.\n `SHOW_WEEK_NUMBERS this option specifies that the number for each week should be displayed down the left side of the calendar. (eg. Jan 1 = Week 1,Dec 31 = Week 52).\n `WEEK_START_MONDAY this option states that the calander week will start on Monday instead of Sunday which is the default. This only affects the order in which days are displayed from left to right.\n  The following functions are used to set the the currently displayed date:\nmethod select_month : month:int -\u0026gt; year:int -\u0026gt; unit method select_day : int -\u0026gt; unit With select_day() the specified day number is selected within the current month, if that is possible. A day value of 0 will deselect any current selection.\nIn addition to having a day selected, any number of days in the month may be \u0026ldquo;marked\u0026rdquo;. A marked day is highlighted within the calendar display. The following functions are provided to manipulate marked days:\nmethod mark_day : int -\u0026gt; unit method unmark_day : int -\u0026gt; unit method clear_marks : unit For example:\nlet calendar = GMisc.calendar in ... (* Is day 7 marked? *) if calendar#mark_day 7 then ( (* day is marked *) ) else ( ... ) Note that marks are persistent across month and year changes.\nThe final Calendar widget function is used to retrieve the currently selected date, month and/or year.\nmethod date : int * int * int The Calendar widget can generate a number of signals indicating date selection and change. The names of these signals are self explanatory, and are; see GMisc.calendar_signals:\n month_changed day_selected day_selected_double_click prev_month next_month prev_year next_year  That just leaves us with the need to put all of this together into example code.\n(* file: calendar.ml *) type signals = { mutable last_sig: GMisc.label; mutable prev_sig: GMisc.label; mutable prev2_sig: GMisc.label } let signals = let label = GMisc.label () in { last_sig = label; prev_sig = label; prev2_sig = label } let set_signal_strings string = signals.prev2_sig#set_text signals.prev_sig#text; signals.prev_sig#set_text signals.last_sig#text; signals.last_sig#set_text string let show_signal calendar msg () = let (y, m, d) = calendar#date in let str = Printf.sprintf \u0026#34;%s: %d/%d/%d\u0026#34; msg y m d in set_signal_strings str let toggle_flags calendar but_flags () = let rec loop bflags = match bflags with | [] -\u0026gt; [] | (but, flag)::rest -\u0026gt; if but#active then flag :: loop rest else loop rest in let flags = loop but_flags in calendar#display_options flags let font_selection_ok font_window calendar () = let font_name = font_window#selection#font_name in let font_desc = GPango.font_description font_name in calendar#misc#modify_font font_desc let select_font calendar () = let fwin = GWindow.font_selection_dialog ~title:\u0026#34;Font Selection Dialog\u0026#34; ~modal:true ~position:`MOUSE () in fwin#connect#destroy ~callback:fwin#destroy; fwin#ok_button#connect#clicked ~callback:(font_selection_ok fwin calendar); fwin#cancel_button#connect#clicked ~callback:fwin#destroy; fwin#show () let flags = [(\u0026#34;Show Heading\u0026#34;, true, `SHOW_HEADING); (\u0026#34;Show Day Names\u0026#34;, true, `SHOW_DAY_NAMES); (\u0026#34;No Month Change\u0026#34;, false, `NO_MONTH_CHANGE); (\u0026#34;Show Week Numbers\u0026#34;, false, `SHOW_WEEK_NUMBERS); (\u0026#34;Week Start Monday\u0026#34;, false, `WEEK_START_MONDAY)] let create_calendar () = (* Create a new window; set title and border width *) let window = GWindow.window ~title:\u0026#34;Calendar Example\u0026#34; ~resizable:false ~border_width:10 () in (* Set a handler for destroy event that immediately exits GTK. *) window#connect#destroy ~callback:GMain.Main.quit; let vbox = GPack.vbox ~border_width:10 ~packing:window#add () in (* The top part of the window, Calendar, flags and fontsel. *) let hbox = GPack.hbox ~packing:vbox#add () in let hbbox = GPack.button_box `HORIZONTAL ~layout:`SPREAD ~spacing:5 ~packing:hbox#add () in (* Calendar widget *) let frame = GBin.frame ~packing:hbbox#add () in let calendar = GMisc.calendar ~packing:frame#add () in calendar#mark_day 19; calendar#connect#month_changed ~callback:(show_signal calendar \u0026#34;month_changed\u0026#34;); calendar#connect#day_selected ~callback:(show_signal calendar \u0026#34;day_selected\u0026#34;); calendar#connect#day_selected_double_click ~callback:(show_signal calendar \u0026#34;day_selected_double_click\u0026#34;); calendar#connect#prev_month ~callback:(show_signal calendar \u0026#34;prev_month\u0026#34;); calendar#connect#next_month ~callback:(show_signal calendar \u0026#34;next_month\u0026#34;); calendar#connect#prev_year ~callback:(show_signal calendar \u0026#34;prev_year\u0026#34;); calendar#connect#next_year ~callback:(show_signal calendar \u0026#34;next_year\u0026#34;); let separator = GMisc.separator `VERTICAL ~packing:hbox#add () in let vbox2 = GPack.vbox ~packing:hbox#add () in (* Build the Right frame with the flags in *) let frame = GBin.frame ~label:\u0026#34;Flags\u0026#34; ~packing:vbox2#add () in let vbox3 = GPack.vbox ~packing:frame#add () in let toggle_button (label, active, flag) = (GButton.check_button ~label ~active ~packing:vbox3#add (), flag) in let flag_buttons = List.map toggle_button flags in let set_flag_cb (but, _) = but#connect#toggled ~callback:(toggle_flags calendar flag_buttons); () in List.iter set_flag_cb flag_buttons; (* Build the right font-button *) let button = GButton.button ~label:\u0026#34;Font...\u0026#34; ~packing:vbox2#add () in button#connect#clicked ~callback:(select_font calendar); (* Build the Signal-event part. *) let frame = GBin.frame ~label:\u0026#34;Signal events\u0026#34; ~packing:vbox#add () in let vbox2 = GPack.vbox ~packing:frame#add () in let hbox = GPack.hbox ~packing:vbox2#add () in let label = GMisc.label ~text:\u0026#34;Signal: \u0026#34; ~packing:hbox#add () in signals.last_sig \u0026lt;- GMisc.label ~packing:hbox#add (); let hbox = GPack.hbox ~packing:vbox2#add () in let label = GMisc.label ~text:\u0026#34;Previous signal: \u0026#34; ~packing:hbox#add () in signals.prev_sig \u0026lt;- GMisc.label ~packing:hbox#add (); let hbox = GPack.hbox ~packing:vbox2#add () in let label = GMisc.label ~text:\u0026#34;Second previous signal: \u0026#34; ~packing:hbox#add () in signals.prev2_sig \u0026lt;- GMisc.label ~packing:hbox#add (); let bbox = GPack.button_box `HORIZONTAL ~layout:`END ~packing:vbox#add () in let button = GButton.button ~label:\u0026#34;Close\u0026#34; ~packing:bbox#add () in button#connect#clicked ~callback:GMain.Main.quit; button#misc#set_can_default true; button#misc#grab_default (); window#show () let main () = create_calendar (); (* Enter the event loop *) GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/",
	"title": "Container widgets",
	"tags": [],
	"description": "EventBox, Alignment widget, fixed container, layout container, ...",
	"content": "  EventBox  At first glance, the EventBox widget might appear to be totally useless.\n Alignment widget  The alignment widget allows you to place a widget within its window at a position and size relative to the size of the Alignment widget itself.\n Fixed container  The Fixed container allows you to place widgets at a fixed position within it\u0026#39;s window, relative to it\u0026#39;s upper left hand corner.\n Layout container  The Layout container is similar to the Fixed container except that it implements an infinite (where infinity is less than 2^32) scrolling area.\n Frames  Frames can be used to enclose one or a group of widgets with a box which can optionally be labelled.\n Aspect frames  The aspect frame widget is like a frame widget, except that it also enforces the aspect ratio (that is, the ratio of the width to the height) of the child widget to have a certain value, adding extra space if necessary.\n Paned window widget  The aspect frame widget is like a frame widget, except that it also enforces the aspect ratio (that is, the ratio of the width to the height) of the child widget to have a certain value, adding extra space if necessary.\n View ports  It is unlikely that you will ever need to use the Viewport widget directly. You are much more likely to use the Scrolled Window widget which itself uses the Viewport.\n Scrolled windows  Scrolled windows are used to create a scrollable area with another widget inside it.\n Button boxes  Button Boxes are a convenient way to quickly layout a group of buttons.\n Toolbar  Toolbars are usually used to group some number of widgets in order to simplify customization of their look and layout.\n Notebooks  The NoteBook Widget is a collection of \u0026#34;pages\u0026#34; that overlap each other, each page contains different information with only one page visible at a time.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/toolbar/",
	"title": "Toolbar",
	"tags": [],
	"description": "Toolbars are usually used to group some number of widgets in order to simplify customization of their look and layout.",
	"content": "Toolbars are usually used to group some number of widgets in order to simplify customization of their look and layout. Typically a toolbar consists of buttons with icons, labels and tooltips, but any other widget can also be put inside a toolbar. Finally, items can be arranged horizontally or vertically and buttons can be displayed with icons, labels, or both.\nCreating a toolbar is (as one may already suspect) done with the function GButton.toolbar:\nval GButton.toolbar : ?orientation:Gtk.Tags.orientation -\u0026gt; ?style:Gtk.Tags.toolbar_style -\u0026gt; ?tooltips:bool -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; toolbar After creating a toolbar one can insert button, radio_button, toggle_button or any widget types into the toolbar. To describe an item we need a label text, a tooltip text, a private tooltip text, an icon for the button and a callback function for it. For example, to insert an item you may use the following functions:\nmethod insert_button : ?text:string -\u0026gt; ?tooltip:string -\u0026gt; ?tooltip_private:string -\u0026gt; ?icon:GObj.widget -\u0026gt; ?pos:int -\u0026gt; ?callback:(unit -\u0026gt; unit) -\u0026gt; unit -\u0026gt; button method insert_radio_button : ?text:string -\u0026gt; ?tooltip:string -\u0026gt; ?tooltip_private:string -\u0026gt; ?icon:GObj.widget -\u0026gt; ?pos:int -\u0026gt; ?callback:(unit -\u0026gt; unit) -\u0026gt; unit -\u0026gt; radio_button method insert_toggle_button : ?text:string -\u0026gt; ?tooltip:string -\u0026gt; ?tooltip_private:string -\u0026gt; ?icon:GObj.widget -\u0026gt; ?pos:int -\u0026gt; ?callback:(unit -\u0026gt; unit) -\u0026gt; unit -\u0026gt; toggle_button method insert_widget : ?tooltip:string -\u0026gt; ?tooltip_private:string -\u0026gt; ?pos:int -\u0026gt; GObj.widget -\u0026gt; unit pos: default value is (-1) If pos is 0 the item is prepended to the start of the toolbar. If pos is negative, the item is appended to the end of the toolbar. It\u0026rsquo;s default value is -1.\nTo simplify adding spaces between toolbar items, you may use the following function:\nmethod insert_space : ?pos:int -\u0026gt; unit -\u0026gt; unit If it\u0026rsquo;s required, the orientation of a toolbar and its style can be changed \u0026ldquo;on the fly\u0026rdquo; using the following functions:\nmethod set_orientation : Gtk.Tags.orientation -\u0026gt; unit method set_style : Gtk.Tags.toolbar_style -\u0026gt; unit method set_tooltips : bool -\u0026gt; unit Where orientation is one of `HORIZONTAL or `VERTICAL. The style is used to set appearance of the toolbar items by using one of `ICONS, `TEXT, or `BOTH.\nTo show some other things that can be done with a toolbar, let\u0026rsquo;s take the following program (we\u0026rsquo;ll interrupt the listing with some additional explanations):\n(* file: toolbar.ml *) (* that\u0026#39;s easy... when one of the buttons is toggled, * set the style of the toolbar accordingly *) let radio_event toolbar style () = toolbar#set_style style (* just check given toggle button and enable/disable * tooltips *) let toggle_event toolbar button () = toolbar#set_tooltips button#active The above are just two callback functions that will be called when one of the buttons on a toolbar is pressed. You should already be familiar with things like this if you\u0026rsquo;ve already used toggle buttons (and radio buttons).\nlet main () = (* Create a new window with a given title, and nice size *) let dialog = GWindow.dialog ~title:\u0026#34;Toolbar Tutorial\u0026#34; () in (* typically we quit if someone tries to close us *) dialog#connect#destroy ~callback:GMain.Main.quit; (* we neecd to realize the window because we use pixmaps for * items on the toolbar in the context of it *) dialog#misc#realize (); (* to make it nice we\u0026#39;ll put the toolbar into the handle box, * so that it can be detached from the main window *) let handlebox = GBin.handle_box ~packing:dialog#vbox#add () in The above should be similar to any other GTK application. Just initialization of GTK, creating the window, etc. There is only one thing that probably needs some explanation: a handle box. A handle box is just another box that can be used to pack widgets in to. The difference between it and typical boxes is that it can be detached from a parent window (or, in fact, the handle box remains in the parent, but it is reduced to a very small rectangle, while all of its contents are reparented to a new freely floating window). It is usually nice to have a detachable toolbar, so these two widgets occur together quite often.\n(* toolbar will be horizontal, with both icons and text, and * with 5pxl spaces between items and finally, * we\u0026#39;ll also put it into our handlebox *) let toolbar = GButton.toolbar ~orientation:`HORIZONTAL ~style:`BOTH ~border_width:5 (* ~space_size:5 *) ~packing:handlebox#add () in (* we need icon for toolbar buttons *) let icon () = let info = GDraw.pixmap_from_xpm ~file:\u0026#34;gtk.xpm\u0026#34; () in (GMisc.pixmap info ())#coerce in Well, what we do above is just a straightforward initialization of the toolbar widget.\n(* our first item is \u0026#34;close\u0026#34; button *) let button = toolbar#insert_button ~text:\u0026#34;Close\u0026#34; ~tooltip:\u0026#34;Close this app\u0026#34; ~tooltip_private:\u0026#34;Private\u0026#34; ~icon:(icon ()) ~callback:GMain.Main.quit () in toolbar#insert_space (); (* space after item *) In the above code you see the simplest case: adding a button to toolbar. Just before appending a new item, we have to construct an image widget to serve as an icon for this item; this step will have to be repeated for each new item. Just after the item we also add a space, so the following items will not touch each other. As you see toolbar#insert_button returns a our newly created button widget, so that we can work with it in the normal way.\n(* now, lets make our radio buttons group... *) let icon_button = toolbar#insert_radio_button ~text:\u0026#34;Icon\u0026#34; ~tooltip:\u0026#34;Only icons in toolbar\u0026#34; ~tooltip_private:\u0026#34;Private\u0026#34; ~icon:(icon ()) ~callback:(radio_event toolbar `ICONS) () in toolbar#insert_space (); Here we begin creating a radio buttons group. To do this we use toolbar#insert_radio_button. In the above case we start creating a radio group. In creating other radio buttons for this group the previous button in the group is required, so that a list of buttons can be easily constructed (see the section on Radio Buttons earlier in this tutorial).\n(* following radio buttons refer to previous ones *) let text_button = toolbar#insert_radio_button ~text:\u0026#34;Text\u0026#34; ~tooltip:\u0026#34;Only texts in toolbar\u0026#34; ~tooltip_private:\u0026#34;Private\u0026#34; ~icon:(icon ()) ~callback:(radio_event toolbar `TEXT) () in text_button#set_group icon_button#group; toolbar#insert_space (); let both_button = toolbar#insert_radio_button ~text:\u0026#34;Both\u0026#34; ~tooltip:\u0026#34;Icons and text in toolbar\u0026#34; ~tooltip_private:\u0026#34;Private\u0026#34; ~icon:(icon ()) ~callback:(radio_event toolbar `BOTH) () in both_button#set_group text_button#group; both_button#set_active true; toolbar#insert_space (); In the end we have to set the state of one of the buttons manually.\n(* here we have just a simple toggle button *) let tooltip_button = toolbar#insert_toggle_button ~text:\u0026#34;Tooltips\u0026#34; ~tooltip:\u0026#34;Toolbar with or without tips\u0026#34; ~tooltip_private:\u0026#34;Private\u0026#34; ~icon:(icon ()) () in tooltip_button#connect#clicked ~callback:(toggle_event toolbar tooltip_button); tooltip_button#set_active true; toolbar#insert_space (); A toggle button can be created in the obvious way (if one knows how to create radio buttons already).\n(* to pack a widget into toolbar, we only have to * create it and append it with appropriate tooltip *) let entry = GEdit.entry () in toolbar#insert_widget ~tooltip:\u0026#34;This is just an entry\u0026#34; ~tooltip_private:\u0026#34;Private\u0026#34; entry#coerce; As you see, adding any kind of widget to a toolbar is simple.\n(* that\u0026#39;s it! let\u0026#39;s show everything *) dialog#show (); (* rest in GMain.Main.main () and wait for the fun to begin! *) GMain.Main.main () let _ = Printexc.print main () So, here we are at the end of toolbar tutorial. Of course, to appreciate it in full you need also this nice XPM icon, so here it is:\n The following xpm file is c style but it\u0026rsquo;s ok in ocaml too.\n /* XPM */ static char * gtk_xpm[] = { \u0026#34;32 39 5 1\u0026#34;, \u0026#34;. c none\u0026#34;, \u0026#34;+ c black\u0026#34;, \u0026#34;@ c #3070E0\u0026#34;, \u0026#34;# c #F05050\u0026#34;, \u0026#34;$ c #35E035\u0026#34;, \u0026#34;................+...............\u0026#34;, \u0026#34;..............+++++.............\u0026#34;, \u0026#34;............+++++@@++...........\u0026#34;, \u0026#34;..........+++++@@@@@@++.........\u0026#34;, \u0026#34;........++++@@@@@@@@@@++........\u0026#34;, \u0026#34;......++++@@++++++++@@@++.......\u0026#34;, \u0026#34;.....+++@@@+++++++++++@@@++.....\u0026#34;, \u0026#34;...+++@@@@+++@@@@@@++++@@@@+....\u0026#34;, \u0026#34;..+++@@@@+++@@@@@@@@+++@@@@@++..\u0026#34;, \u0026#34;.++@@@@@@+++@@@@@@@@@@@@@@@@@@++\u0026#34;, \u0026#34;.+#+@@@@@@++@@@@+++@@@@@@@@@@@@+\u0026#34;, \u0026#34;.+##++@@@@+++@@@+++++@@@@@@@@$@.\u0026#34;, \u0026#34;.+###++@@@@+++@@@+++@@@@@++$$$@.\u0026#34;, \u0026#34;.+####+++@@@+++++++@@@@@+@$$$$@.\u0026#34;, \u0026#34;.+#####+++@@@@+++@@@@++@$$$$$$+.\u0026#34;, \u0026#34;.+######++++@@@@@@@++@$$$$$$$$+.\u0026#34;, \u0026#34;.+#######+##+@@@@+++$$$$$$@@$$+.\u0026#34;, \u0026#34;.+###+++##+##+@@++@$$$$$$++$$$+.\u0026#34;, \u0026#34;.+###++++##+##+@@$$$$$$$@+@$$@+.\u0026#34;, \u0026#34;.+###++++++#+++@$$@+@$$@++$$$@+.\u0026#34;, \u0026#34;.+####+++++++#++$$@+@$$++$$$$+..\u0026#34;, \u0026#34;.++####++++++#++$$@+@$++@$$$$+..\u0026#34;, \u0026#34;.+#####+++++##++$$++@+++$$$$$+..\u0026#34;, \u0026#34;.++####+++##+#++$$+++++@$$$$$+..\u0026#34;, \u0026#34;.++####+++####++$$++++++@$$$@+..\u0026#34;, \u0026#34;.+#####++#####++$$+++@++++@$@+..\u0026#34;, \u0026#34;.+#####++#####++$$++@$$@+++$@@..\u0026#34;, \u0026#34;.++####++#####++$$++$$$$$+@$@++.\u0026#34;, \u0026#34;.++####++#####++$$++$$$$$$$$+++.\u0026#34;, \u0026#34;.+++####+#####++$$++$$$$$$$@+++.\u0026#34;, \u0026#34;..+++#########+@$$+@$$$$$$+++...\u0026#34;, \u0026#34;...+++########+@$$$$$$$$@+++....\u0026#34;, \u0026#34;.....+++######+@$$$$$$$+++......\u0026#34;, \u0026#34;......+++#####+@$$$$$@++........\u0026#34;, \u0026#34;.......+++####+@$$$$+++.........\u0026#34;, \u0026#34;.........++###+$$$@++...........\u0026#34;, \u0026#34;..........++##+$@+++............\u0026#34;, \u0026#34;...........+++++++..............\u0026#34;, \u0026#34;.............++++...............\u0026#34;};"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/colorselection/",
	"title": "Color selection",
	"tags": [],
	"description": "The color selection widget is, not surprisingly, a widget for interactive selection of colors.",
	"content": "The color selection widget is, not surprisingly, a widget for interactive selection of colors. This composite widget lets the user select a color by manipulating RGB (Red, Green, Blue) and HSV (Hue, Saturation, Value) triples. This is done either by adjusting single values with sliders or entries, or by picking the desired color from a hue-saturation wheel/value bar. Optionally, the opacity of the color can also be set.\nLets have a look at what the color selection widget has to offer us. The widget comes in two flavours: GMisc.color_selection and GWindow.color_selection_dialog.\nval GMisc.color_selection : ?alpha:int -\u0026gt; ?color:Gdk.color -\u0026gt; ?has_opacity_control:bool -\u0026gt; ?has_palette:bool -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; color_selection You\u0026rsquo;ll probably not be using this constructor directly. It creates an orphan color_selection widget which you\u0026rsquo;ll have to parent yourself. The color_selection widget inherits from the VBox widget.\nval GWindow.color_selection_dialog : ?title:string -\u0026gt; ?parent:#window_skel -\u0026gt; ?destroy_with_parent:bool -\u0026gt; ?allow_grow:bool -\u0026gt; ?allow_shrink:bool -\u0026gt; ?icon:GdkPixbuf.pixbuf -\u0026gt; ?modal:bool -\u0026gt; ?screen:Gdk.screen -\u0026gt; ?type_hint:Gdk.Tags.window_type_hint -\u0026gt; ?position:Gtk.Tags.window_position -\u0026gt; ?wm_name:string -\u0026gt; ?wm_class:string -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; color_selection_dialog This is the most common color selection constructor. It creates a color_selection_dialog. It consists of a Frame containing a color_selection widget, an HSeparator and an HBox with three buttons, \u0026ldquo;Ok\u0026rdquo;, \u0026ldquo;Cancel\u0026rdquo; and \u0026ldquo;Help\u0026rdquo;. You can reach these buttons by accessing the \u0026ldquo;ok_button\u0026rdquo;, \u0026ldquo;cancel_button\u0026rdquo; and \u0026ldquo;help_button\u0026rdquo; methods in the color_selection_dialog object, (i.e., color_sel_dialog#ok_button).\nmethod set_has_opacity_control : bool -\u0026gt; unit The color selection widget supports adjusting the opacity of a color (also known as the alpha channel). This is disabled by default. Calling this function with has_opacity set to true enables opacity. Likewise, has_opacity set to false will disable opacity.\nmethod set_color : Gdk.color -\u0026gt; unit method set_alpha : int -\u0026gt; unit You can set the current color explicitly by calling set_color method with a GdkColor. Setting the opacity (alpha channel) is done with set_alpha method. The alpha value should be between 0 (fully transparent) and 65636 (fully opaque).\nmethod color : Gdk.color method alpha : int Here\u0026rsquo;s a simple example demonstrating the use of the color_selection_dialog. The program displays a window containing a drawing area. Clicking on it opens a color selection dialog, and changing the color in the color selection dialog changes the background color.\n(* file: colorsel.ml *) let dialog_ref = ref None let color = ref (`RGB (0, 65535, 0)) (* GDraw.color ref type *) (* \u0026#34;color_changed\u0026#34; event does not exist in lablgtk2!!! *) (* let color_changed_cb colorsel drawingarea () = let ncolor = colorsel#color in drawingarea#misc#modify_bg [(`NORMAL, `COLOR ncolor)] *) let response dlg drawingarea resp = let colorsel = dlg#colorsel in begin match resp with | `OK -\u0026gt; color := `COLOR colorsel#color | _ -\u0026gt; () end; drawingarea#misc#modify_bg [(`NORMAL, !color)]; dlg#misc#hide () (* Drawingarea button_press event handler *) let button_pressed drawingarea ev = (* Create color selection dialog *) let colordlg = match !dialog_ref with | None -\u0026gt; let dlg = GWindow.color_selection_dialog ~title:\u0026#34;Select background color\u0026#34; () in dialog_ref := Some dlg; dlg | Some dlg -\u0026gt; dlg in (* Get the ColorSelection widget *) let colorsel = colordlg#colorsel in (* set_prev_color does not exist in lablgtk2!!! *) (* colorsel#set_prev_color (GDraw.color !color); *) colorsel#set_color (GDraw.color !color); (* requires Gdk.color type *) colorsel#set_has_palette true; (* Connect to the \u0026#34;color_changed\u0026#34; signal *) (* This event does not exist in lablgtk2!!! *) (* Need confirm to lablgtk2 team. *) (* colorsel#connect#color_changed ~callback:(color_changed_cb colorsel drawingarea); *) colordlg#connect#response ~callback:(response colordlg drawingarea); (* Show the dialog *) colordlg#run (); true let main () = (* Create toplevel window, set title and policies (allow_grow, allow_shrink) *) let window = GWindow.window ~title:\u0026#34;Color selection test\u0026#34; ~border_width:10 ~allow_grow:true ~allow_shrink:true () in (* Attach \u0026#34;destroy\u0026#34; events so we can exit *) window#connect#destroy ~callback:GMain.Main.quit; (* Create drawingarea, set size and catch button events *) let drawingarea = GMisc.drawing_area ~width:200 ~height:200 ~packing:window#add () in drawingarea#misc#modify_bg [(`NORMAL, !color)]; drawingarea#event#add [`BUTTON_PRESS]; drawingarea#event#connect#button_press ~callback:(button_pressed drawingarea); window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/menuwidgets/",
	"title": "Menu widgets",
	"tags": [],
	"description": "There are two ways to create menus: there&#39;s the easy way, and there&#39;s the hard way. Both have their uses, but you can usually use the Itemfactory (the easy way).",
	"content": "There are two ways to create menus: there\u0026rsquo;s the easy way, and there\u0026rsquo;s the hard way. Both have their uses, but you can usually use the Itemfactory (the easy way). The \u0026ldquo;hard\u0026rdquo; way is to create all the menus using the calls directly. The easy way is to use the gtk_item_factory calls. This is much simpler, but there are advantages and disadvantages to each approach.\nThe Itemfactory is much easier to use, and to add new menus to, although writing a few wrapper functions to create menus using the manual method could go a long way towards usability. With the Itemfactory, it is not possible to add images or the character \u0026lsquo;/\u0026rsquo; to the menus.\n Manual menu createion  At first glance, the EventBox widget might appear to be totally useless.\n Manual menu example  Manual menu example\n Automatic menu generation  You can generate menu automatically using GToolbox.build_menu.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/containerwidgets/notebooks/",
	"title": "Notebooks",
	"tags": [],
	"description": "The NoteBook Widget is a collection of &#34;pages&#34; that overlap each other, each page contains different information with only one page visible at a time.",
	"content": "The NoteBook Widget is a collection of \u0026ldquo;pages\u0026rdquo; that overlap each other, each page contains different information with only one page visible at a time. This widget has become more common lately in GUI programming, and it is a good way to show blocks of similar information that warrant separation in their display.\nThe first function call you will need to know, as you can probably guess by now, is used to create a new notebook widget: see GPack.notebook.\nval GPack.notebook : ?enable_popup:bool -\u0026gt; ?homogeneous_tabs:bool -\u0026gt; ?scrollable:bool -\u0026gt; ?show_border:bool -\u0026gt; ?show_tabs:bool -\u0026gt; ?tab_border:int -\u0026gt; ?tab_pos:Gtk.Tags.position -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?packing:(GObj.widget -\u0026gt; unit) -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; notebook Once the notebook has been created, there are a number of functions that operate on the notebook widget. Let\u0026rsquo;s look at them individually.\nThe first one we will look at is how to position the page indicators. These page indicators or \u0026ldquo;tabs\u0026rdquo; as they are referred to, can be positioned in four ways: top, bottom, left, or right.\nmethod set_tab_pos : Gtk.Tags.position -\u0026gt; unit Gtk.Tags.position will be one of the following, which are pretty self explanatory:\n`LEFT `RIGHT `TOP `BOTTOM `TOP is the default.\nNext we will look at how to add pages to the notebook. There are three ways to add pages to the NoteBook. Let\u0026rsquo;s look at the first two together as they are quite similar.\nmethod append_page : ?tab_label:GObj.widget -\u0026gt; ?menu_label:GObj.widget -\u0026gt; GObj.widget -\u0026gt; unit method prepend_page : ?tab_label:GObj.widget -\u0026gt; ?menu_label:GObj.widget -\u0026gt; GObj.widget -\u0026gt; unit These functions add pages to the notebook by inserting them from the back of the notebook (append), or the front of the notebook (prepend). The given widget is placed within the notebook page, and tab_label is the label for the page being added. The given widget must be created separately, and is typically a set of options setup within one of the other container widgets, such as a table.\nThe final function for adding a page to the notebook contains all of the properties of the previous two, but it allows you to specify what position you want the page to be in the notebook.\nmethod insert_page : ?tab_label:GObj.widget -\u0026gt; ?menu_label:GObj.widget -\u0026gt; pos:int -\u0026gt; GObj.widget -\u0026gt; unit The parameters are the same as append and prepend except it contains an extra parameter, pos. This parameter is used to specify what place this page will be inserted into the first page having position zero.\nNow that we know how to add a page, lets see how we can remove a page from the notebook.\nmethod remove_page : int -\u0026gt; unit This function takes the page number of int type and removes it from the notebook.\nTo find out what the current page is in a notebook use the function:\nmethod current_page : int These next two functions are simple calls to move the notebook page forward or backward. Simply provide the respective function call with the notebook widget you wish to operate on. Note: When the NoteBook is currently on the last page, and next_page() is called, the notebook will wrap back to the first page. Likewise, if the NoteBook is on the first page, and prev_page() is called, the notebook will wrap to the last page.\nmethod next_page : unit -\u0026gt; unit method previous_page : unit -\u0026gt; unit This next function sets the \u0026ldquo;active\u0026rdquo; page. If you wish the notebook to be opened to page 5 for example, you would use this function. Without using this function, the notebook defaults to the first page.\nmethod goto_page : int -\u0026gt; unit The next two functions add or remove the notebook page tabs and the notebook border respectively.\nmethod set_show_tabs : bool -\u0026gt; unit method set_show_border : bool -\u0026gt; unit The next function is useful when the you have a large number of pages, and the tabs don\u0026rsquo;t fit on the page. It allows the tabs to be scrolled through using two arrow buttons.\nmethod set_scrollable : bool -\u0026gt; unit show_tabs, show_border and scrollable methods can be either true or false.\nNow let\u0026rsquo;s look at an example, it is expanded from the testgtk.c code that comes with the GTK distribution. This small program creates a window with a notebook and six buttons. The notebook contains 11 pages, added in three different ways, appended, inserted, and prepended. The buttons allow you rotate the tab positions, add/remove the tabs and border, remove a page, change pages in both a forward and backward manner, and exit the program.\n(* file: notebook.ml *) (* This function rotates the position of the tabs *) let rotate_book notebook () = notebook#set_tab_pos (match notebook#tab_pos with | `BOTTOM -\u0026gt; `LEFT | `LEFT -\u0026gt; `TOP | `TOP -\u0026gt; `RIGHT | `RIGHT -\u0026gt; `BOTTOM ) (* Add/Remove the page tabs and the borders *) let tabsborder_book notebook () = notebook#set_show_tabs (not notebook#show_tabs); notebook#set_show_border (not notebook#show_border) (* Remove a page from the notebook *) let remove_book notebook () = notebook#remove_page notebook#current_page; () let main () = let window = GWindow.window ~title:\u0026#34;Notebook demo\u0026#34; ~border_width:10 ()in window#connect#destroy ~callback:GMain.Main.quit; let table = GPack.table ~rows:3 ~columns:6 ~packing:window#add () in (* Create a new notebook, place the position of the tabs *) let notebook = GPack.notebook ~tab_pos:`TOP ~packing:(table#attach ~left:0 ~right:6 ~top:0) () in for i = 1 to 5 do let text = \u0026#34;Append Frame \u0026#34; ^ string_of_int i in let label = GMisc.label ~text:(\u0026#34;Page \u0026#34; ^ string_of_int i) () in let frame = GBin.frame ~label:text ~width:100 ~height:75 ~border_width:10 ~packing:(notebook#append_page ~tab_label:label#coerce) () in let label = GMisc.label ~text ~packing:frame#add () in () done; (* Now let\u0026#39;s add a page to a specified spot *) let label = GMisc.label ~text:\u0026#34;Add page\u0026#34; () in let checkbutton = GButton.check_button ~label:\u0026#34;Check me please!\u0026#34; ~packing:(notebook#insert_page ~tab_label:label#coerce ~pos:2) () in checkbutton#misc#set_size_request ~width:100 ~height:75 (); (* Now finaly let\u0026#39;s prepend pages to the notebook *) for i = 1 to 5 do let text = \u0026#34;Prepend Frame \u0026#34; ^ string_of_int i in let label = GMisc.label ~text:(\u0026#34;PPage \u0026#34; ^ string_of_int i) () in let frame = GBin.frame ~label:text ~width:100 ~height:75 ~border_width:10 ~packing:(notebook#prepend_page ~tab_label:label#coerce) () in let label = GMisc.label ~text ~packing:frame#add () in () done; (* Set what page to start at (page 4) *) notebook#goto_page 3; (* Create a bunch of buttons *) let button = GButton.button ~label:\u0026#34;close\u0026#34; ~packing:(table#attach ~left:0 ~top:1) () in button#connect#clicked ~callback:GMain.Main.quit; let button = GButton.button ~label:\u0026#34;next page\u0026#34; ~packing:(table#attach ~left:1 ~top:1) () in button#connect#clicked ~callback:notebook#next_page; let button = GButton.button ~label:\u0026#34;prev page\u0026#34; ~packing:(table#attach ~left:2 ~top:1) () in button#connect#clicked ~callback:notebook#previous_page; let button = GButton.button ~label:\u0026#34;tab position\u0026#34; ~packing:(table#attach ~left:3 ~top:1) () in button#connect#clicked ~callback:(rotate_book notebook); let button = GButton.button ~label:\u0026#34;tabs/border on/off\u0026#34; ~packing:(table#attach ~left:4 ~top:1) () in button#connect#clicked ~callback:(tabsborder_book notebook); let button = GButton.button ~label:\u0026#34;remove page\u0026#34; ~packing:(table#attach ~left:5 ~top:1) () in button#connect#clicked ~callback:(remove_book notebook); window#show (); GMain.Main.main () let _ = Printexc.print main () I hope this helps you on your way with creating notebooks for your GTK applications.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/miscwidgets/fileselection/",
	"title": "File selection",
	"tags": [],
	"description": "The file selection widget is a quick and simple way to display a File dialog box.",
	"content": "The file selection widget is a quick and simple way to display a File dialog box. It comes complete with Ok, Cancel, and Help buttons, a great way to cut down on programming time.\nTo create a new file selection box use GWindow.file_selection:\nval GWindow.file_selection : ?title:string -\u0026gt; ?show_fileops:bool -\u0026gt; ?filename:string -\u0026gt; ?select_multiple:bool -\u0026gt; ?parent:#window_skel -\u0026gt; ?destroy_with_parent:bool -\u0026gt; ?allow_grow:bool -\u0026gt; ?allow_shrink:bool -\u0026gt; ?icon:GdkPixbuf.pixbuf -\u0026gt; ?modal:bool -\u0026gt; ?resizable:bool -\u0026gt; ?screen:Gdk.screen -\u0026gt; ?type_hint:Gdk.Tags.window_type_hint -\u0026gt; ?position:Gtk.Tags.window_position -\u0026gt; ?wm_name:string -\u0026gt; ?wm_class:string -\u0026gt; ?border_width:int -\u0026gt; ?width:int -\u0026gt; ?height:int -\u0026gt; ?show:bool -\u0026gt; unit -\u0026gt; file_selection To set the filename, for example to bring up a specific directory, or give a default filename, use filename argument or this function:\nmethod set_filename : string -\u0026gt; unit To grab the text that the user has entered or clicked on, use this function:\nmethod filename : string There are also pointers to the widgets contained within the file selection widget. These are:\nmethod dir_list : string GList.clist method file_list : string GList.clist method get_selections : string list method ok_button : GButton.button method cancel_button : GButton.button method help_button : GButton.button Most likely you will want to use the ok_button, cancel_button, and help_button methods in signaling their use.\nIncluded example is nothing much to creating a file selection widget. While in this example the Help button appears on the screen, it does nothing as there is not a signal attached to it.\n(* file: filesel.ml *) (* Get the selected filename and print it to the console *) let file_ok_sel filew () = print_endline filew#filename; flush stdout let main () = (* Create a new file selection widget; set default filename *) let filew = GWindow.file_selection ~title:\u0026#34;File selection\u0026#34; ~border_width:10 ~filename:\u0026#34;penguin.png\u0026#34; () in (* Set a handler for destroy event that immediately exits GTK. *) filew#connect#destroy ~callback:GMain.Main.quit; (* Connect the ok_button to file_ok_sel function *) filew#ok_button#connect#clicked ~callback:(file_ok_sel filew); (* Connect the cancel_button to destroy the widget *) filew#cancel_button#connect#clicked ~callback:filew#destroy; filew#show (); (* Rest in main and wait for the fun to begin! *) GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/undocumentedwidgets/",
	"title": "Undocumented widgets",
	"tags": [],
	"description": "These all require authors! :) Please consider contributing to our tutorial.",
	"content": "These all require authors! :) Please consider contributing to our tutorial.\nIf you must use one of these widgets that are undocumented, I strongly suggest you take a look at their respective header files in the GTK distribution. GTK\u0026rsquo;s function names are very descriptive. Once you have an understanding of how things work, it\u0026rsquo;s not difficult to figure out how to use a widget simply by looking at its function declarations. This, along with a few examples from others\u0026rsquo; code, and it should be no problem.\nWhen you do come to understand all the functions of a new undocumented widget, please consider writing a tutorial on it so others may benefit from your time.\n Accel Label Option Menu Menu Items  Check Menu Item Radio Menu Item Separator Menu Item Tearoff Menu Item  Curves Drawing Area Font Selectiono Dialog Message Dialog Gamma Curve mages Plugs and Sockets Tree View Text View  "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/settingwidgetattributes/",
	"title": "Setting widget attributes",
	"tags": [],
	"description": "This describes the functions used to operate on widgets. These can be used to set style, padding, size, etc.",
	"content": "This describes the functions used to operate on widgets. These can be used to set style, padding, size, etc. You can get access these method through misc method, for example, button#misc#hide ().\nFor full descriptions, see GObj.misc_ops.\n(Maybe I should make a whole section on accelerators.)\nmethod activate : unit -\u0026gt; bool method set_name : string -\u0026gt; unit method name : string method set_sensitive : bool -\u0026gt; unit method set_style : style -\u0026gt; unit method style : style method set_size_request : ?width:int -\u0026gt; ?height:int -\u0026gt; unit -\u0026gt; unit method set_can_focus : bool -\u0026gt; unit method grab_focus : unit -\u0026gt; unit method realize : unit -\u0026gt; unit method show : unit -\u0026gt; unit method hide : unit -\u0026gt; unit"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/timeouts/",
	"title": "Timeouts and idle functions",
	"tags": [],
	"description": "Timeouts and idle functions",
	"content": "  Timeouts  Using the following function you can create a timeout function that will be called every _interval_ milliseconds.\n Idle functions  What if you have a function which you want to be called when nothing else is happening?\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/advancedevent/",
	"title": "Advanced event and signal handling",
	"tags": [],
	"description": "Advanced event and signal handling",
	"content": " Signal Functions Connecting and Disconnecting Signal Handlers let handler_id = [widget]#connect#[signal name] ~callback:... in let handler_id = [widget]#event#connect#[event signal name] ~callback:... in let handler_id = [widget]#event#connect#after#[event signal name] ~callback:... in [widget]#misc#disconnect [handler_id]; Blocking and Unblocking Signal Handlers [widget]#misc#handler_block [handler_id]; [widget]#misc#handler_unblock [handler_id]; Signal Emission and Propagation Signal emission is the process whereby GTK runs all handlers for a specific object and signal.\nFirst, note that the return value from a signal emission is the return value of the last handler executed. Since event signals are all of type GTK_RUN_LAST, this will be the default (GTK supplied) handler, unless you connect with event#connect#after.\nThe way an event (say \u0026ldquo;button_press event\u0026rdquo;) is handled, is:\n Start with the widget where the event occured.\n Emit the generic \u0026ldquo;event\u0026rdquo; signal. If that signal handler returns a value of TRUE, stop all processing.\n Otherwise, emit a specific, \u0026ldquo;button_press event\u0026rdquo; signal. If that returns TRUE, stop all processing.\n Otherwise, go to the widget\u0026rsquo;s parent, and repeat the above two steps.\n Continue until some signal handler returns TRUE, or until the top-level widget is reached.\n  Some consequences of the above are:\n Your handler\u0026rsquo;s return value will have no effect if there is a default handler, unless you connect with #event#connect#after.\n To prevent the default handler from being run, you need to connect with #event#connect and use GtkSignal.emit_stop_by_name - the return value only affects whether the signal is propagated, not the current emission.\n  "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/clipboard/",
	"title": "Clipboard",
	"tags": [],
	"description": "Text copy and paste is a good example of clipboard widget. You can do inter-processor communication throuth the widget.",
	"content": "  There is the \u0026ldquo;Managing Selections\u0026rdquo; chapter in the original C version tutorial. Even thought LablGtk supports \u0026ldquo;selection\u0026rdquo; widget too, \u0026ldquo;clipboard\u0026rdquo; widget is simpler so we will make document only for this widget for the time being.\n Text copy and paste is a good example of clipboard widget. You can do inter-processor communication throuth the widget.\nBefore copy or paste, you have the access point to the clipboard: see Gdk.Atom and GData.clipboard\nval GData.clipboard : Gdk.atom -\u0026gt; clipboard After that, you can do clear clipboard, set data and get data: see GData.clipboard class\nmethod clear : unit -\u0026gt; unit method set_text : string -\u0026gt; unit method text : string option Clipboard Example The following code is the program that copy and paste the buttons\u0026rsquo; state from one application to the other.\nPlease launch two instance of the same program and select buttons and click \u0026ldquo;Copy\u0026rdquo; button in one application. You can view that the button state are changing to the same when you click \u0026ldquo;Paste\u0026rdquo; button in the another instance of the program.\n(* file: clipboard.ml *) (* Translate string to char list *) let explode str = let len = String.length str in let rec loop clist i = if i \u0026gt;= len then List.rev clist else loop (str.[i] :: clist) (i+1) in loop [] 0 (* Put the status of the buttons to clipboard *) let put_data buttons clipboard () = let append_active str but = if but#active then str ^ \u0026#34;1\u0026#34; else str ^ \u0026#34;0\u0026#34; in clipboard#set_text (List.fold_left append_active \u0026#34;\u0026#34; buttons) (* Get the status of the buttons from clipboard and apply them *) let get_data buttons clipboard () = match clipboard#text with | Some txt -\u0026gt; if String.length txt = 4 then ( let to_bool c = if c = \u0026#39;1\u0026#39; then true else false in let active = List.map to_bool (explode txt) in let button_status = List.combine buttons active in List.iter (fun (but, b) -\u0026gt; but#set_active b) button_status ) else failwith \u0026#34;String length mismatch\u0026#34; | None -\u0026gt; () let main () = (* Create the toplevel window *) let window = GWindow.window ~title:\u0026#34;Clipboard Example\u0026#34; ~border_width:10 () in window#connect#destroy ~callback:GMain.Main.quit; let vbox = GPack.vbox ~packing:window#add () in let table = GPack.table ~columns:2 ~rows:2 ~row_spacings:5 ~col_spacings:5 ~border_width:10 ~packing:vbox#add () in let make_button (left, top, label) = GButton.toggle_button ~label ~packing:(table#attach ~left ~top) () in let buttons = List.map make_button [(0, 0, \u0026#34;Hello World\u0026#34;); (1, 0, \u0026#34;Launch two of this program\u0026#34;); (0, 1, \u0026#34;On one process, select buttons and copy\u0026#34;); (1, 1, \u0026#34;On the other process, paste\u0026#34;);] in (* Clipboard *) let clipboard = GData.clipboard Gdk.Atom.clipboard in let box = GPack.button_box `HORIZONTAL ~spacing:5 ~layout:`END ~border_width:10 ~packing:vbox#add () in (* \u0026#34;Copy\u0026#34; button *) let button = GButton.button ~stock:`COPY ~packing:box#add () in button#connect#clicked ~callback:(put_data buttons clipboard); (* \u0026#34;Paste\u0026#34; button *) let button = GButton.button ~stock:`PASTE ~packing:box#add () in button#connect#clicked ~callback:(get_data buttons clipboard); window#show (); GMain.Main.main () let _ = Printexc.print main ()"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/dnd/",
	"title": "Drag-and-drop",
	"tags": [],
	"description": "GTK+ has a high level set of functions for doing inter-process communication via the drag-and-drop system. GTK+ can perform drag-and-drop on top of the low level Xdnd and Motif drag-and-drop protocols.",
	"content": " GTK+ has a high level set of functions for doing inter-process communication via the drag-and-drop system. GTK+ can perform drag-and-drop on top of the low level Xdnd and Motif drag-and-drop protocols.\nOverview An application capable of GTK+ drag-and-drop first defines and sets up the GTK+ widget(s) for drag-and-drop. Each widget can be a source and/or destination for drag-and-drop.\nSource widgets can send out drag data, thus allowing the user to drag things off of them, while destination widgets can receive drag data. Drag-and-drop destinations can limit who they accept drag data from, e.g. the same application or any application (including itself).\nSending and receiving drop data makes use of GTK+ signals. Dropping an item to a destination widget requires both a data request (for the source widget) and data received signal handler (for the target widget). Additional signal handers can be connected if you want to know when a drag begins (at the very instant it starts), to when a drop is made, and when the entire drag-and-drop procedure has ended (successfully or not).\nYour application will need to provide data for source widgets when requested, that involves having a drag data request signal handler. For destination widgets they will need a drop data received signal handler.\nSo a typical drag-and-drop cycle would look as follows:\n Drag begins.\n Drag data request (when a drop occurs).\n Drop data received (may be on same or different application).\n Drag data delete (if the drag was a move).\n Drag-and-drop procedure done.\n  There are a few minor steps that go in between here and there, but we will get into detail about that later.\nProperties Drag data has the following properties:\n Drag action type (ie `COPY, `MOVE).\n Client specified arbitrary drag-and-drop type (a name and number pair).\n Sent and received data format type.\n  Drag actions are quite obvious, they specify if the widget can drag with the specified action(s), e.g. `COPY and/or `MOVE. A `COPY would be a typical drag-and-drop without the source data being deleted while `MOVE would be just like `COPY but the source data will be \u0026lsquo;suggested\u0026rsquo; to be deleted after the received signal handler is called. There are additional drag actions including `LINK which you may want to look into when you get to more advanced levels of drag-and-drop.\nThe client specified arbitrary drag-and-drop type is much more flexible, because your application will be defining and checking for that specifically. You will need to set up your destination widgets to receive certain drag-and-drop types by specifying a name and/or number. It would be more reliable to use a name since another application may just happen to use the same number for an entirely different meaning.\nFunctions You can find the full DragAndDrop specification in GObj.drag_ops. And you can use these functions(methods) and events like this:\n[widget]#drag#[method name] [widget]#drag#connect#[event name] Setting up the source widget The method drag#source_set specifies a set of target types for a drag operation on a widget.\nmethod source_set : ?modi:Gdk.Tags.modifier list -\u0026gt; ?actions:Gdk.Tags.drag_action list -\u0026gt; Gtk.target_entry list -\u0026gt; unit The parameters signify the following:\n modi specifies a list of buttons that can start the drag (e.g. `BUTTON1): see Gdk.Tags.modifier\n Gtk.target_entry list specifies a table of target data types the drag will support\n actions specifies a list of possible actions for a drag from this window\n  The Gtk.target_entry type is the following structure:\ntype target_entry = { target : string; flags : Tags.target_flags list; info : int; } type target_flags = [ `SAME_APP | `SAME_WIDGET ]  The fields specify a string representing the drag type, optional flags and application assigned integer identifier.\nIf a widget is no longer required to act as a source for drag-and-drop operations, the method drag#source_unset can be used to remove a set of drag-and-drop target types.\nmethod source_unset : unit -\u0026gt; unit Signals on the source widget: The source widget is sent the following signals during a drag-and-drop operation.\nTable 1. Source widget signals\n         drag_begin method beginning : callback:(drag_context -\u0026gt; unit) -\u0026gt; GtkSignal.id   drag_motion method motion : callback:(drag_context -\u0026gt; x:int -\u0026gt; y:int -\u0026gt; time:int32 -\u0026gt; bool) -\u0026gt; GtkSignal.id   drag_data_get method data_get : callback:(drag_context -\u0026gt; selection_context -\u0026gt; info:int -\u0026gt; time:int32 -\u0026gt; unit) -\u0026gt; GtkSignal.id   drag_data_delete method data_delete : callback:(drag_context -\u0026gt; unit) -\u0026gt; GtkSignal.id   drag_drop method drop : callback:(drag_context -\u0026gt; x:int -\u0026gt; y:int -\u0026gt; time:int32 -\u0026gt; bool) -\u0026gt; GtkSignal.id   drag_end method ending : callback:(drag_context -\u0026gt; unit) -\u0026gt; GtkSignal.id    Setting up a destination widget: drag#dest_set specifies that this widget can receive drops and specifies what types of drops it can receive.\ndrag#dest_unset specifies that the widget can no longer receive drops.\nmethod dest_set : ?flags:Gtk.Tags.dest_defaults list -\u0026gt; ?actions:Gdk.Tags.drag_action list -\u0026gt; Gtk.target_entry list -\u0026gt; unit method dest_unset : unit -\u0026gt; unit Signals on the destination widget: The destination widget is sent the following signals during a drag-and-drop operation.\nTable 2. Destination widget signals\n         drag_data_received method data_received : callback:(drag_context -\u0026gt; x:int -\u0026gt; y:int -\u0026gt; selection_data -\u0026gt; info:int -\u0026gt; time:int32 -\u0026gt; unit) -\u0026gt; GtkSignal.id    "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/gtkrcfiles/",
	"title": "GTK&#39;s rc files",
	"tags": [],
	"description": "GTK has its own way of dealing with application defaults, by using rc files. These can be used to set the colors of just about any widget, and can also be used to tile pixmaps onto the background of some widgets.",
	"content": "GTK has its own way of dealing with application defaults, by using rc files. These can be used to set the colors of just about any widget, and can also be used to tile pixmaps onto the background of some widgets.\n Functions for rc files  When your application starts, it reads the default RC files.\n GTK\u0026#39;s rc file format  What if you have a function which you want to be called when nothing else is happening?\n Example rc file  Example rc file\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/scribble/",
	"title": "Scribble, drawing program",
	"tags": [],
	"description": "In this section, we will build a simple drawing program. In the process, we will examine how to handle mouse events, how to draw in a window, and how to do drawing better by using a backing pixmap.",
	"content": "In this section, we will build a simple drawing program. In the process, we will examine how to handle mouse events, how to draw in a window, and how to do drawing better by using a backing pixmap. After creating the simple drawing program, we will extend it by adding support for XInput devices, such as drawing tablets. GTK provides support routines which makes getting extended information, such as pressure and tilt, from such devices quite easy.\n Event handling  The GTK signals we have already discussed are for high-level actions, such as a menu item being selected. However, sometimes it is useful to learn about lower-level occurrences, such as the mouse being moved, or a key being pressed.\n Drawing  We now turn to the process of drawing on the screen.\n "
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/contributing/",
	"title": "Contributing",
	"tags": [],
	"description": "This document, like so much other great software out there, was created for free by volunteers. If you are at all knowledgeable about any aspect of GTK that does not already have documentation, please consider contributing to this document.",
	"content": " This document, like so much other great software out there, was created for free by volunteers. If you are at all knowledgeable about any aspect of GTK that does not already have documentation, please consider contributing to this document.\nIf you do decide to contribute, please mail your text to Tony Gale, gale@gtk.org. Also, be aware that the entirety of this document is free, and any addition by you provide must also be free. That is, people may use any portion of your examples in their programs, and copies of this document may be distributed at will, etc.\nThank you.\nOcaml Version Contributing This document, like so much other great software out there, was created for free by volunteers. If you are at all knowledgeable about any aspect of GTK that does not already have documentation, please consider contributing to this document.\nIf you do decide to contribute, please mail your text to me. Also, be aware that the entirety of this document is free, and any addition by you provide must also be free. That is, people may use any portion of your examples in their programs, and copies of this document may be distributed at will, etc.\nThank you.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/credits/",
	"title": "Credits",
	"tags": [],
	"description": "We would like to thank the following for their contributions to this text.",
	"content": " We would like to thank the following for their contributions to this text.\n Bawer Dagdeviren, chamele0n@geocities.com for the menus tutorial.\n Raph Levien, raph@acm.org for hello world ala GTK, widget packing, and general all around wisdom. He\u0026rsquo;s also generously donated a home for this tutorial.\n Peter Mattis, petm@xcf.berkeley.edu for the simplest GTK program.. and the ability to make it :)\n Werner Koch werner.koch@guug.de for converting the original plain text to SGML, and the widget class hierarchy.\n Mark Crichton crichton@expert.cc.purdue.edu for the menu factory code, and the table packing tutorial.\n Owen Taylor owt1@cornell.edu for the EventBox widget section (and the patch to the distro). He\u0026rsquo;s also responsible for the selections code and tutorial, as well as the sections on writing your own GTK widgets, and the example application. Thanks a lot Owen for all you help!\n Mark VanderBoom mvboom42@calvin.edu for his wonderful work on the Notebook, Progress Bar, Dialogs, and File selection widgets. Thanks a lot Mark! You\u0026rsquo;ve been a great help.\n Tim Janik timj@gtk.org for his great job on the Lists Widget. His excellent work on automatically extracting the widget tree and signal information from GTK. Thanks Tim :)\n Rajat Datta rajat@ix.netcom.com for the excellent job on the Pixmap tutorial.\n Michael K. Johnson johnsonm@redhat.com for info and code for popup menus.\n David Huggins-Daines bn711@freenet.carleton.ca for the Range Widgets and Tree Widget sections.\n Stefan Mars mars@lysator.liu.se for the CList section.\n David A. Wheeler dwheeler@ida.org for portions of the text on GLib and various tutorial fixups and improvements. The GLib text was in turn based on material developed by Damon Chaplin DAChaplin@msn.com\n David King for style checking the entire document.\n  And to all of you who commented on and helped refine this document.\nThanks.\nOcaml Version Credits Thanks.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/lablgtk2-tutorial/copyright/",
	"title": "Tutorial copyright and permissions notice",
	"tags": [],
	"description": " ",
	"content": " The GTK Tutorial is Copyright \u0026copy; 1997 Ian Main.\nCopyright \u0026copy; 1998-2002 Tony Gale.\nPermission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.\nPermission is granted to copy and distribute modified versions of this document under the conditions for verbatim copying, provided that this copyright notice is included exactly as in the original, and that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.\nPermission is granted to copy and distribute translations of this document into another language, under the above conditions for modified versions.\nIf you are intending to incorporate this document into a published work, please contact the maintainer, and we will make an effort to ensure that you have the most up to date information available.\nThere is no guarantee that this document lives up to its intended purpose. This is simply provided as a free resource. As such, the authors and maintainers of the information provided within can not make any guarantee that the information is even accurate.\nOcaml Version Tutorial Copyright and Permissions Notice Copyright \u0026copy; 2004, 2019 SooHyoung Oh.\nPermission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.\nPermission is granted to copy and distribute modified versions of this document under the conditions for verbatim copying, provided that this copyright notice is included exactly as in the original, and that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.\nPermission is granted to copy and distribute translations of this document into another language, under the above conditions for modified versions.\nIf you are intending to incorporate this document into a published work, please contact the maintainer, and we will make an effort to ensure that you have the most up to date information available.\nThere is no guarantee that this document lives up to its intended purpose. This is simply provided as a free resource. As such, the authors and maintainers of the information provided within can not make any guarantee that the information is even accurate.\n"
},
{
	"uri": "https://ohama.github.io/ocaml/readme/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ohama.github.io/ocaml/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ohama.github.io/ocaml/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]