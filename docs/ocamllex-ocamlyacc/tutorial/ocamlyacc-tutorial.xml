<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
    "/usr/share/sgml/docbook/xml-dtd-4.2-1.0-22.1/docbookx.dtd" [
]>

<book id="ocamlyacc-tutorial">

<bookinfo>
    <date>2019-05-05</date>
    <title>Ocamlyacc Tutorial</title>
    <authorgroup>
      <author>
        <firstname>Ocamlyacc Adaptation: SooHyoung</firstname>
        <surname>Oh</surname>
      </author>
    </authorgroup>
    <abstract>
      <para>
      This is a tutorial on how to use <literal>ocamlyacc</literal>
      which is distributed with
      <ulink url="http://ocaml.org">Ocaml language</ulink>.
      </para>
      <para>
      Lots of part of this document are borrowed from the
      <ulink url="https://www.gnu.org/software/bison/">bison</ulink> manual.
      </para>

      <para>
      All license term in this document is NOT related with ocamlyacc; it is ONLY for this document.
      </para>

      <para>
            Please mail all comments and suggestions to <email>ohama100 at gmail dot com</email>
      </para>
      <para>
            The latest version can
            be found at <ulink url="https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/index.html">
            https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/index.html</ulink>.
      </para>

      <para>
      The companion tutorial for <literal>ocamllex</literal> is available
      at <ulink url="https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamllex-tutorial/index.html">
      https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamllex-tutorial/index.html</ulink>.
      </para>

      <para>
	You can find the source of this document in
	<ulink url="https://ohama.github.io/ocaml/ocamllex-ocamlyacc/tutorial">tutorial</ulink> directory.
	For who wants the other form,
	<ulink url="https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial.pdf">pdf</ulink> for printing.
      </para>

      <para>
	The source of the examples used in this document can be found
	<ulink url="https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamlyacc-examples">ocamlyacc-examples</ulink> directory.
      </para>

      <para>
<emphasis>
This document is just a re-formatting of the old one. There have been many improvements since then in Ocaml programming language but those are not reflected in this document.
</emphasis>
      </para>

      <para>
            First release: 2004-11-16
      </para>
      <para>
            Last updated: 2019-05-05
      </para>
    </abstract>
  </bookinfo>

<toc></toc>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-introduction">
<title>Introduction</title>

<para>
<literal>Ocamlyacc</literal> is a general-purpose parser generator that converts a
grammar description for an LALR(1) context-free grammar into a Ocaml
program to parse that grammar.  Once you are proficient with Ocamlyacc,
you may use it to develop a wide range of language parsers, from those
used in simple desk calculators to complex programming languages.
</para>

<para>
Ocamlyacc is very close to the well-known yacc (or bison) commands
that can be found in most C programming environments.
Anyone familiar with Yacc
should be able to use Ocamlyacc with little trouble.  You need to be fluent in
Ocaml programming in order to use Ocamlyacc or to understand this manual.
</para>

<para>
We begin with tutorial chapters that explain the basic concepts of using
Ocamlyacc and show three explained examples, each building on the last.  If you
don't know Ocamlyacc or Yacc, start by reading these chapters.  Reference
chapters follow which describe specific aspects of Ocamlyacc in detail.
</para>

<!--
<para>
Bison was written primarily by Robert Corbett; Richard Stallman made it
Yacc-compatible.  Wilfred Hansen of Carnegie Mellon University added
multi-character string literals and other features.
</para>
-->

<!--
<para>
This edition corresponds to version 3.08 of Ocaml (Ocamlyacc).
</para>
-->

<para>
Some explanation is not suitable for the earlier version than 3.08 of Ocaml (Ocamlyacc),
in that case, there will be comments like "<emphasis>(Since Ocaml 3.08)</emphasis>".
</para>

<remark>
All license term in this document is NOT
related with ocamlyacc; it is ONLY for this document.
</remark>

</chapter>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-concepts-of-ocamlyacc">
<title>The Concepts of Ocamlyacc</title>

<para>
This chapter introduces many of the basic concepts without which the
details of Ocamlyacc will not make sense.  If you do not already know how to
use Ocamlyacc, we suggest you start by reading this chapter carefully.
</para>

<!-- ************************************************************** -->
<sect1 id="sec-language-and-grammar">
<title>Languages and Context-Free Grammars</title>

<para>
In order for Ocamlyacc to parse a language, it must be described by a
<emphasis>context-free grammar</emphasis>.  This means that you specify one or more
<emphasis>syntactic groupings</emphasis> and give rules for constructing them from their
parts.  For example, in the C language, one kind of grouping is called an
`expression'.  One rule for making an expression might be, ``An expression
can be made of a minus sign and another expression''.  Another would be,
``An expression can be an integer''.  As you can see, rules are often
recursive, but there must be at least one rule which leads out of the
recursion.
</para>

<para>
The most common formal system for presenting such rules for humans to read
is <emphasis>Backus-Naur Form</emphasis> or ``BNF'', which was developed in order to
specify the language Algol 60.  Any grammar expressed in BNF is a
context-free grammar.  The input to Ocamlyacc is essentially machine-readable
BNF.
</para>

<para>
Not all context-free languages can be handled by Ocamlyacc, only those
that are LALR(1).  In brief, this means that it must be possible to
tell how to parse any portion of an input string with just a single
token of look-ahead.  Strictly speaking, that is a description of an
LR(1) grammar, and LALR(1) involves additional restrictions that are
hard to explain simply; but it is rare in actual practice to find an
LR(1) grammar that fails to be LALR(1).
See <link linkend="sec-mysterious-reduce-reduce-conflicts">Mysterious
Reduce/Reduce Conflicts</link>,
for more information on this.
</para>

<para>
In the formal grammatical rules for a language, each kind of syntactic unit
or grouping is named by a <emphasis>symbol</emphasis>.  Those which are built by grouping
smaller constructs according to grammatical rules are called
<emphasis>nonterminal symbols</emphasis>; those which can't be subdivided are called
<emphasis>terminal symbols</emphasis> or <emphasis>token types</emphasis>.  We call a piece of input
corresponding to a single terminal symbol a <literal>token</literal>, and a piece
corresponding to a single nonterminal symbol a <emphasis>grouping</emphasis>.
</para>

<para>
We can use the C language as an example of what symbols, terminal and
nonterminal, mean.  The tokens of C are identifiers, constants (numeric and
string), and the various keywords, arithmetic operators and punctuation
marks.  So the terminal symbols of a grammar for C include `identifier',
`number', `string', plus one symbol for each keyword, operator or
punctuation mark: `if', `return', `const', `static', `int', `char',
`plus-sign', `open-brace', `close-brace', `comma' and many more.  (These
tokens can be subdivided into characters, but that is a matter of
lexicography, not grammar.)
</para>

<para>
Here is a simple C function subdivided into tokens:
</para>

<programlisting role="C">
int             /* keyword `int' */
square (int x)  /* identifier, open-paren, identifier, identifier, close-paren */
{               /* open-brace */
  return x * x; /* keyword `return', identifier, asterisk, identifier, semicolon */
}               /* close-brace */
</programlisting>

<para>
The syntactic groupings of C include the expression, the statement, the
declaration, and the function definition.  These are represented in the
grammar of C by nonterminal symbols `expression', `statement',
`declaration' and `function definition'.  The full grammar uses dozens of
additional language constructs, each with its own nonterminal symbol, in
order to express the meanings of these four.  The example above is a
function definition; it contains one declaration, and one statement.  In
the statement, each <literal>x</literal> is an expression and so is <literal>x * x</literal>.
</para>

<para>
Each nonterminal symbol must have grammatical rules showing how it is made
out of simpler constructs.  For example, one kind of C statement is the
<literal>return</literal> statement; this would be described with a grammar rule which
reads informally as follows:
</para>

<programlisting role="C">
	A `statement' can be made of a `return' keyword, an `expression' and a `semicolon'.
</programlisting>

<para>
There would be many other rules for `statement', one for each kind of
statement in C.
</para>

<para>
One nonterminal symbol must be distinguished as the special one which
defines a complete utterance in the language.  It is called the <emphasis>start
symbol</emphasis>.
In a compiler, this means a complete input program.  In the C
language, the nonterminal symbol `sequence of definitions and declarations'
plays this role.
</para>

<para>
For example, <literal>1 + 2</literal> is a valid C expression---a valid part of a C
program---but it is not valid as an <emphasis>entire</emphasis> C program.  In the
context-free grammar of C, this follows from the fact that `expression' is
not the start symbol.
</para>

<para>
The Ocamlyacc parser reads a sequence of tokens as its input, and groups the
tokens using the grammar rules.  If the input is valid, the end result is
that the entire token sequence reduces to a single grouping whose symbol is
the grammar's start symbol.  If we use a grammar for C, the entire input
must be a `sequence of definitions and declarations'.  If not, the parser
reports a syntax error.
</para>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-from-formal-rules-to-ocamlyacc-input">
<title>From Formal Rules to Ocamlyacc Input</title>

<para>
A formal grammar is a mathematical construct.  To define the language
for Ocamlyacc, you must write a file expressing the grammar in Ocamlyacc syntax:
a <emphasis>Ocamlyacc grammar</emphasis> file.
See <link linkend="chap-grammar-files">Ocamlyacc Grammar Files</link>
</para>

<para>
A nonterminal symbol in the formal grammar is represented in Ocamlyacc input
as an identifier, like an identifier in Ocaml.
It is like regular Caml symbol, except that it cannot end with ' (single quote).
It should start
in lower case, such as <literal>expr</literal>, <literal>stmt</literal> or <literal>declaration</literal>.
</para>

<para>
The Ocamlyacc representation for a terminal symbol is also called a
<emphasis>token types</emphasis>.
Token typess should be declared in Ocamlyacc Declaration Section
and they are added as constructors for the token concrete type.
As constructors, they should start with upper case:
for example, <literal>Integer</literal>, <literal>Identifier</literal>, <literal>IF</literal> or
<literal>RETURN</literal>.
<!--
A terminal symbol that stands for a particular keyword in
the language should be named after that keyword converted to upper case.
-->
The terminal symbol <literal>error</literal> is reserved for error recovery.
See <link linkend="sec-symbols-terminal-nonterminal">Symbols</link>.
</para>

<!--
<para>
A terminal symbol can also be represented as a character literal, just like
a Ocaml character constant.  You should do this whenever a token is just a
single character (parenthesis, plus-sign, etc.): use that same character in
a literal as the terminal symbol for that token.
</para>

<para>
A third way to represent a terminal symbol is with a Ocaml string constant
containing several characters. 
See <link linkend="sec-symbols-terminal-nonterminal">Symbols</link>,
for more information.
</para>
-->

<para>
The grammar rules also have an expression in Ocamlyacc syntax.  For example,
here is the Ocamlyacc rule for a C <literal>return</literal> statement.
<!--
The semicolon in
quotes is a literal character token, representing part of the Ocaml syntax for
the statement; the naked semicolon, and the colon, are Ocamlyacc punctuation
used in every rule.
-->
</para>

<programlisting role="C">
stmt:   RETURN expr SEMICOLON
        ;
</programlisting>

<para>
See <link linkend="sec-syntax-of-grammar-rules">Syntax of Grammar Rules</link>.
</para>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-semantic-values">
<title>Semantic Values</title>

<para>
A formal grammar selects tokens only by their classifications: for example,
if a rule mentions the terminal symbol `integer constant', it means that
<emphasis>any</emphasis> integer constant is grammatically valid in that position.  The
precise value of the constant is irrelevant to how to parse the input: if
<literal>x+4</literal> is grammatical then <literal>x+1</literal> or <literal>x+3989</literal> is equally
grammatical.
</para>

<para>
But the precise value is very important for what the input means once it is
parsed.  A compiler is useless if it fails to distinguish between 4, 1 and
3989 as constants in the program!  Therefore, each token in a Ocamlyacc grammar
has both a token type and a <emphasis>semantic value</emphasis>.
See <link linkend="sec-defining-language-semantics">Defining Language Semantics</link>,
for details.
</para>

<para>
The token type is a terminal symbol defined in the grammar, such as
<literal>INTEGER</literal>, <literal>IDENTIFIER</literal> or <literal>SEMICOLON</literal>.  It tells everything
you need to know to decide where the token may validly appear and how to
group it with other tokens.  The grammar rules know nothing about tokens
except their types.
</para>

<para>
The semantic value has all the rest of the information about the
meaning of the token, such as the value of an integer, or the name of an
identifier.  (A token such as <literal>SEMICOLON</literal> which is just punctuation doesn't
need to have any semantic value.)
</para>

<para>
For example, an input token might be classified as token type
<literal>INTEGER</literal> and have the semantic value 4.  Another input token might
have the same token type <literal>INTEGER</literal> but value 3989.  When a grammar
rule says that <literal>INTEGER</literal> is allowed, either of these tokens is
acceptable because each is an <literal>INTEGER</literal>.  When the parser accepts the
token, it keeps track of the token's semantic value.
</para>

<para>
Each grouping can also have a semantic value as well as its nonterminal
symbol.  For example, in a calculator, an expression typically has a
semantic value that is a number.  In a compiler for a programming
language, an expression typically has a semantic value that is a tree
structure describing the meaning of the expression.
</para>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-semantic-actions">
<title>Semantic Actions</title>

<para>
In order to be useful, a program must do more than parse input; it must
also produce some output based on the input.  In a Ocamlyacc grammar, a grammar
rule can have an <emphasis>action</emphasis> made up of Ocaml statements.  Each time the
parser recognizes a match for that rule, the action is executed.
See <link linkend="sec-actions">Actions</link>,
</para>

<para>
Most of the time, the purpose of an action is to compute the semantic value
of the whole construct from the semantic values of its parts.  For example,
suppose we have a rule which says an expression can be the sum of two
expressions.  When the parser recognizes such a sum, each of the
subexpressions has a semantic value which describes how it was built up.
The action for this rule should create a similar sort of value for the
newly recognized larger expression.
</para>

<para>
For example, here is a rule that says an expression can be the sum of
two subexpressions:
</para>

<programlisting role="C">
expr: expr PLUS expr   { $1 + $3 }
        ;
</programlisting>

<para>
The action says how to produce the semantic value of the sum expression
from the values of the two subexpressions.
</para>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-locations">
<title>Locations</title>

<para>
Many applications, like interpreters or compilers, have to produce verbose
and useful error messages. To achieve this, one must be able to keep track of
the <emphasis>textual position</emphasis>, or <emphasis>location</emphasis>, of each syntactic construct.
Ocamlyacc provides a mechanism for handling these locations.
</para>

<para>
Each token has a semantic value. In a similar fashion, each token has an
associated location, but the type of locations is the same for all tokens and
groupings. Moreover, the output parser is equipped with a data
structure for storing locations
(see <link linkend="sec-tracking-locations">Locations</link>, for more details).
</para>

<para>
Like semantic values, locations can be reached in actions
using functions of the Parsing module.
</para>

<!--
<para>
Like semantic values, locations can be reached in actions using a dedicated
set of constructs. In the example above, the location of the whole grouping
is <literal>@$</literal>, while the locations of the subexpressions are <literal>@1</literal> and
<literal>@3</literal>.
</para>
-->

<!--
<para>
When a rule is matched, an action is used to compute the semantic value
of its left hand side
(see <link linkend="sec-actions">Actions</link>).
In the same way, another
action is used for locations.
However, the action for locations is general
enough for most cases, meaning there is usually no need to describe for each
rule how <literal>@$</literal> should be formed.
When building a new location for a given
grouping, the behavior of the output parser is to take the beginning
of the first symbol, and the end of the last symbol.
</para>
-->

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-ocamlyacc-output">
<title>Ocamlyacc Output: the Parser File</title>

<para>
When you run Ocamlyacc, you give it a Ocamlyacc grammar file as input.  The output
is a Ocaml source file that parses the language described by the grammar.
This file is called a <emphasis>Ocamlyacc parser</emphasis>.  Keep in mind that the Ocamlyacc
utility and the Ocamlyacc parser are two distinct programs: the Ocamlyacc utility
is a program whose output is the Ocamlyacc parser that becomes part of your
program.
</para>

<para>
The job of the Ocamlyacc parser is to group tokens into groupings according to
the grammar rules---for example, to build identifiers and operators into
expressions.  As it does this, it runs the actions for the grammar rules it
uses.
</para>

<para>
The tokens come from a function called the <emphasis>lexical analyzer</emphasis> that you
must supply in some fashion.  The Ocamlyacc parser
calls the lexical analyzer each time it wants a new token.  It doesn't know
what is ``inside'' the tokens (though their semantic values may reflect
this).  Typically the lexical analyzer makes the tokens by parsing
characters of text, but Ocamlyacc does not depend on this.
See <link linkend="sec-lexical-analyzer-function">The Lexical Analyzer Function</link>.
</para>

<para>
The Ocamlyacc parser file is Ocaml code which defines functions
which implements that grammar.
Entry functions of the generated Ocaml code are named after
the start symbols in grammar file.
These functions do not make
a complete Ocaml program: you must supply some additional functions.
One is the lexical analyzer
which should be given as an argument of the parser entry function.
Another is an error-reporting function which the
parser calls to report an error.
In addition, a complete Ocaml program must has to call one (or more) of
the generated entry functions or the parser will never run.
See <link linkend="chap-parser-interface">Parser Interface</link>.
</para>

<!--
<para>
Aside from the token type names and the symbols in the actions you
write, all symbols defined in the Ocamlyacc parser file itself
begin with <literal>yy</literal> or <literal>YY</literal>.  This includes interface functions
such as the lexical analyzer function <literal>yylex</literal>, the error reporting
function <literal>yyerror</literal> and the parser function <literal>yyparse</literal> itself.
This also includes numerous identifiers used for internal purposes.
Therefore, you should avoid using Ocaml identifiers starting with <literal>yy</literal>
or <literal>YY</literal> in the Ocamlyacc grammar file except for the ones defined in
this manual.
</para>
-->

<!--
<para>
In some cases the Ocamlyacc parser file includes system headers, and in
those cases your code should respect the identifiers reserved by those
headers.  On some non-@sc{gnu} hosts, <literal>alloca.h</literal>,
<literal>stddef.h</literal>, and <literal>stdlib.h</literal> are included as needed to
declare memory allocators and related types.
Other system headers may be included if you define <literal>YYDEBUG</literal>
to a nonzero value
(see <link linkend="chap-introduction">Debugging Your Parser [TBD]</link>).
</para>
-->

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-stages-in-using-ocamlyacc">
<title>Stages in Using Ocamlyacc</title>

<para>
The actual language-design process using Ocamlyacc, from grammar specification
to a working compiler or interpreter, has these parts:
</para>

<itemizedlist>
<listitem>
  <simpara>
  Formally specify the grammar in a form recognized by Ocamlyacc
  (see <link linkend="chap-grammar-files">Ocamlyacc Grammar Files</link>).
  For each grammatical rule in the language,
  describe the action that is to be taken when an instance of that rule
  is recognized.  The action is described by a sequence of Ocaml statements.
  </simpara>
</listitem>

<listitem>
  <simpara>
  Write a lexical analyzer to process input and pass tokens to the
  parser.  The lexical analyzer may be written by hand in Ocaml
  (see <link linkend="sec-lexical-analyzer-function">The Lexical Analyzer Function</link>).
  It could also be produced using <literal>ocamllex</literal>, but the use
  of <literal>ocamllex</literal> is not discussed in this manual.
  </simpara>
</listitem>

<listitem>
  <simpara>
  Write a controlling function that calls the Ocamlyacc-produced parser.
  </simpara>
</listitem>

<listitem>
  <simpara>
  Write error-reporting routines.
  </simpara>
</listitem>

</itemizedlist>

<para>
To turn this source code as written into a runnable program, you
must follow these steps:
</para>

<itemizedlist>
<listitem>
  <simpara>
  Run Ocamlyacc on the grammar to produce the parser.
  </simpara>
</listitem>

<listitem>
  <simpara>
  Compile the code output by Ocamlyacc, as well as any other source files.
  </simpara>
</listitem>

<listitem>
  <simpara>
  Link the object files to produce the finished product.
  </simpara>
</listitem>
</itemizedlist>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-overall-layout-of-a-ocamlyacc-grammar">
<title>The Overall Layout of a Ocamlyacc Grammar</title>

<para>
The input file for the Ocamlyacc utility is a <literal>Ocamlyacc grammar file</literal>.  The
general form of a Ocamlyacc grammar file is as follows:
</para>

<programlisting role="C">
%{
    <emphasis>Header</emphasis> (Ocaml code)
%}
    <emphasis>Ocamlyacc declarations</emphasis>
%%
    <emphasis>Grammar rules</emphasis>
%%
    <emphasis>Trailer</emphasis> (Additional Ocaml code)
</programlisting>

<para>
The <literal>%%</literal>, <literal>%{</literal> and <literal>%}</literal> are punctuation that appears
in every Ocamlyacc grammar file to separate the sections.
</para>

<para>
The <emphasis>header</emphasis> may define types, variables and functions used in the actions.
<!--
You can also use preprocessor commands to define macros used there, and use
<literal>#include</literal> to include header files that do any of these things.
-->
</para>

<para>
The <emphasis>Ocamlyacc declarations</emphasis> declare the names of the terminal and nonterminal
symbols, and may also describe operator precedence and the data types of
semantic values of various symbols.
</para>

<para>
The <emphasis>grammar rules</emphasis> define how to construct each nonterminal symbol from its
parts.
</para>

<para>
The <emphasis>Trailer</emphasis> can contain any Ocaml code you want to use.
<!--
Often the
definition of the lexical analyzer <literal>yylex</literal> goes here, plus subroutines
called by the actions in the grammar rules.  In a simple program, all the
rest of the program can go here.
-->
</para>

</sect1>

</chapter>


<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-examples">
<title>Examples</title>

<para>
Now we show and explain three sample programs written using Ocamlyacc: a
reverse polish notation calculator, an algebraic (infix) notation
calculator, and a multi-function calculator.
<!--
All three have been tested
under BSD Unix 4.3; each produces a usable, though limited, interactive
desk-top calculator.
-->
These examples are simple, but Ocamlyacc grammars for real programming
languages are written the same way.
</para>

<!-- ************************************************************** -->
<sect1 id="sec-reverse-polish-notation-calculator">
<title>Reverse Polish Notation Calculator</title>

<para>
The first example is that of a simple double-precision <emphasis>reverse polish
notation</emphasis> calculator (a calculator using postfix operators).  This example
provides a good starting point, since operator precedence is not an issue.
The second example will illustrate how operator precedence is handled.
</para>

<para>
The source code for this calculator is named <literal>rpcalc.mly</literal>.  The
<literal>.mly</literal> extension is a convention used for Ocamlyacc input files.

</para>

<!-- ************************************************************** -->
<sect2 id="sec-declarations-for-rpcalc">
<title>Declarations for "rpcalc"</title>

<para>
Here are the Ocaml and Ocamlyacc declarations for the reverse polish notation
calculator.
By default, comments are enclosed between /* and */ (as in C) except
in Ocaml code.
</para>

<programlisting role="C">
/* file: rpcalc.mly */
/* Reverse polish notation calculator. */

%{
open Printf
%}

%token &lt;float&gt; NUM
%token PLUS MINUS MULTIPLY DIVIDE CARET UMINUS
%token NEWLINE

%start input
%type &lt;unit&gt; input

%% /* Grammar rules and actions follow */
</programlisting>

<para>
The header section
(see <link linkend="sec-header-section">The Header Section</link>)
has a code of openning "Printf" module.
</para>

<para>
The second section, Ocamlyacc declarations, provides information to Ocamlyacc
about the token types
(see <link linkend="sec-ocamlyacc-declaration-section">The Ocamlyacc Declarations Section</link>).
Each terminal must be declared here.
The first terminal symbol is the token type for numeric constants which has a value of <literal>float</literal>
The possible arithmetic operators are
<literal>PLUS, MINUS, MULTIPLY, DIVIDE</literal>,
<literal>CARET</literal> for exponetiation
and <literal>UMINUS</literal> for unary minus.
These operator terminals don't have any value with it.
The last terminal is <literal>NEWLINE</literal>,
a token type for the newline character.
</para>

<para>
You must give the names of the start symbols and their types, too.
In this examples, there is one start symbol named <literal>input</literal>
which has type of <literal>unit</literal>.
For each start symbol, the parser function with the same name is
generated.
</para>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-grammar-rules-for-rpcalc">
<title>Grammar Rules for rpcalc</title>

<para>

Here are the grammar rules for the reverse polish notation calculator.
</para>

<programlisting role="C">
input:    /* empty */		{ }
        | input line		{ }
;

line:     NEWLINE		{ }
        | exp NEWLINE		{ printf "\t%.10g\n" $1; flush stdout }
;

exp:      NUM			{ $1 }
        | exp exp PLUS		{ $1 +. $2 }
        | exp exp MINUS		{ $1 -. $2 }
        | exp exp MULTIPLY		{ $1 *. $2 }
        | exp exp DIVIDE		{ $1 /. $2 }
      	/* Exponentiation */
        | exp exp CARET		{ $1 ** $2 }
      	/* Unary minus    */
        | exp UMINUS		{ -. $1 }
;
%%
</programlisting>

<para>
The groupings of the rpcalc ``language'' defined here are the expression
(given the name <literal>exp</literal>), the line of input (<literal>line</literal>), and the
complete input transcript (<literal>input</literal>).  Each of these nonterminal
symbols has several alternate rules, joined by the <literal>|</literal> punctuator
which is read as ``or''.  The following sections explain what these rules
mean.
</para>

<para>
The semantics of the language is determined by the actions taken when a
grouping is recognized.  The actions are the Ocaml code that appears inside
braces.
See <link linkend="sec-actions">Actions</link>.
</para>

<para>
You must specify these actions in Ocaml, but Ocamlyacc provides the means for
passing semantic values between the rules.
In each action, the semantic value for the grouping
that the rule is going to construct should be given.
The semantic values of the components of the
rule are referred to as <literal>$1</literal>, <literal>$2</literal>, and so on.
</para>

<!-- ************************************************************** -->
<sect3 id="sec-rpcalc-input">
<title>Explanation of input</title>

<para>
Consider the definition of <literal>input</literal>:
</para>

<programlisting role="C">
input:    /* empty */
        | input line
;
</programlisting>

<para>
This definition reads as follows: ``A complete input is either an empty
string, or a complete input followed by an input line''.  Notice that
``complete input'' is defined in terms of itself.  This definition is said
to be <emphasis>left recursive</emphasis> since <literal>input</literal> appears always as the
leftmost symbol in the sequence.
See <link linkend="sec-recursive-rules">Recursive Rules</link>.
</para>

<para>
The first alternative is empty because there are no symbols between the
colon and the first <literal>|</literal>; this means that <literal>input</literal> can match an
empty string of input (no tokens).  We write the rules this way because it
is legitimate to type <literal>Ctrl-d</literal> right after you start the calculator.
It's conventional to put an empty alternative first and write the comment
<literal>/* empty */</literal> in it.
</para>

<para>
The second alternate rule (<literal>input line</literal>) handles all nontrivial input.
It means, ``After reading any number of lines, read one more line if
possible.''  The left recursion makes this rule into a loop.  Since the
first alternative matches empty input, the loop can be executed zero or
more times.
</para>

<para>
The parser function <literal>input</literal> continues to process input until a
grammatical error is seen or the lexical analyzer says there are no more
input tokens; we will arrange for the latter to happen at end of file.
</para>

</sect3>

<!-- ************************************************************** -->
<sect3 id="sec-explanation-of-line">
<title>Explanation of line</title>

<para>
Now consider the definition of <literal>line</literal>:
</para>

<programlisting role="C">

line:     NEWLINE      { }
        | exp NEWLINE  { printf "\t%.10g\n" $1; flush stdout }
;

</programlisting>

<para>
The first alternative is a token which is a newline character; this means
that rpcalc accepts a blank line (and ignores it, since there is no
action).  The second alternative is an expression followed by a newline.
This is the alternative that makes rpcalc useful.  The semantic value of
the <literal>exp</literal> grouping is the value of <literal>$1</literal> because the <literal>exp</literal> in
question is the first symbol in the alternative.  The action prints this
value, which is the result of the computation the user asked for.
</para>

<para>
As you can see, the semantic value associated with the <literal>line</literal>
is <literal>unit</literal>.
</para>

</sect3>

<!-- ************************************************************** -->
<sect3 id="sec-explanation-of-expr">
<title>Explanation of expr</title>

<para>
The <literal>exp</literal> grouping has several rules, one for each kind of expression.
The first rule handles the simplest expressions: those that are just numbers.
The second handles an addition-expression, which looks like two expressions
followed by a plus-sign.  The third handles subtraction, and so on.
</para>

<programlisting role="C">
exp:	  NUM		{ $1 }
	| exp exp PLUS	{ $1 +. $2 }
	| exp exp MINUS	{ $1 -. $2 }
	...
	;
</programlisting>

<para>
We have used <literal>|</literal> to join all the rules for <literal>exp</literal>, but we could
equally well have written them separately:
</para>

<programlisting role="C">
exp:	NUM		{ $1 };
exp:	exp exp PLUS	{ $1 +. $2 };
exp:	exp exp MINUS	{ $1 -. $2 };
	...
</programlisting>

<para>
All of the rules have actions that compute the value of the expression in
terms of the value of its parts.  For example, in the rule for addition,
<literal>$1</literal> refers to the first component <literal>exp</literal> and <literal>$2</literal> refers to
the second one.  The third component, <literal>PLUS</literal>, has no meaningful
associated semantic value, but if it had one you could refer to it as
<literal>$3</literal>.
When the parser function recognizes a sum expression using this
rule, the sum of the two subexpressions' values is produced as the value of
the entire expression.
See <link linkend="sec-actions">Actions</link>.
</para>

<!--
<para>
You don't have to give an action for every rule.  When a rule has no
action, Ocamlyacc by default copies the value of <literal>$1</literal> into <literal>$$</literal>.
This is what happens in the first rule (the one that uses <literal>NUM</literal>).
</para>
-->

<para>
The formatting shown here is the recommended convention, but Ocamlyacc does
not require it.  You can add or change whitespace as much as you wish.
For example, this:
</para>

<programlisting role="C">
exp:	NUM { $1 } | exp exp PLUS { $1 +. $2 } | ...
</programlisting>

<para>
means the same thing as this:
</para>

<programlisting role="C">
exp:      NUM		{ $1 }
        | exp exp PLUS	{ $1 + $2 }
        | ...
</programlisting>

<para>
The latter, however, is much more readable.
</para>

</sect3>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-rpcalc-lexical-analyzer">
<title>The rpcalc Lexical Analyzer</title>

<para>
The lexical analyzer's job is low-level parsing: converting characters or
sequences of characters into tokens.  The Ocamlyacc parser gets its tokens by
calling the lexical analyzer.
See <link linkend="sec-lexical-analyzer-function">The Lexical Analyzer Function</link>.
</para>

<para>
Only a simple lexical analyzer is needed for the RPN calculator.  This
lexical analyzer reads in numbers as
<literal>float</literal> and returns them as <literal>NUM</literal> tokens.
It recognizes '+', '-', '*', '/', '^', 'n' as operators
and returns the corresponding token:
ADD, MINUS, MULTIPLY, DIVIDE, CARET and UMINUS.
When it meets '\n', the returning token is NEWLINE.
Spaces and unknown characers are skipped.
</para>

<para>
The return value of the lexical analyzer function is a value of the concrete token type.
The same text used in Ocamlyacc rules to stand for this token type
is also a Ocaml expression for the value for the type.
Token type is defined by Ocamlyacc as a constructor of the concrete token type.
In this example, therefore, <literal>NUM</literal>, <literal>PLUS</literal>, <literal>...</literal> become values for the lexer function to use.
</para>

<para>
The semantic value of the token (if it has one) is returned with it.
In this example, only <literal>NUM</literal> has a semantic value.
</para>

<para>
Here is the code for the lexical analyzer:
</para>

<programlisting role="C">
(* file: lexer.mll *)
(* Lexical analyzer returns one of the tokens:
   the token NUM of a floating point number,
   operators (PLUS, MINUS, MULTIPLY, DIVIDE, CARET, UMINUS),
   or NEWLINE.  It skips all blanks and tabs, unknown characters
   and raises End_of_file on EOF. *)
{
  open Rtcalc (* Assumes the parser file is "rtcalc.mly". *)
}
let digit = ['0'-'9']
rule token = parse
  | [' ' '\t']	{ token lexbuf }
  | '\n'	{ NEWLINE }
  | digit+
  | "." digit+
  | digit+ "." digit* as num
		{ NUM (float_of_string num) }
  | '+'		{ PLUS }
  | '-'		{ MINUS }
  | '*'		{ MULTIPLY }
  | '/'		{ DIVIDE }
  | '^'		{ CARET }
  | 'n'		{ UMINUS }
  | _		{ token lexbuf }
  | eof		{ raise End_of_file }
</programlisting>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-controlling-function">
<title>The Controlling Function</title>

<para>
In keeping with the spirit of this example, the controlling function is
kept to the bare minimum.
To start the process of parsings,
the only requirement is that it call
parser function <literal>Parser.input</literal> with two argumenst:
lexical analyzer function <literal>Lexer.token</literal>
and <literal>lexbuf</literal> of <literal>Lexing.lexbuf</literal> type.
</para>

<programlisting role="C">
(* file: main.ml *)
(* Assumes the parser file is "rtcalc.mly" and the lexer file is "lexer.mll". *)
let main () =
  try
    let lexbuf = Lexing.from_channel stdin in
    while true do
      Rtcalc.input Lexer.token lexbuf
    done
  with End_of_file -> exit 0
      
let _ = Printexc.print main ()
</programlisting>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-error-reporting-routine">
<title>The Error Reporting Routine</title>

<para>
When ther parser function detects a syntax error,
it calls a function named <literal>parse_error</literal>
with the string "syntax error" as argument.
The default <literal>parse_error</literal> function does nothing and returns,
thus initiating error recovery
(see <link linkend="chap-error-recovery">Error Recovery</link>).
The user can define a customized <literal>parse_error</literal> function
in the header section of the grammar file such as:
</para>

<programlisting role="C">
let parse_error s = (* Called by the parser function on error *)
  print_endline s;
  flush stdout
</programlisting>

<para>
After <literal>parse_error</literal> returns,
the Ocamlyacc parser may recover from the error
and continue parsing if the grammar contains a suitable error rule
(see <link linkend="chap-error-recovery">Error Recovery</link>).
Otherwise, the parser aborts by raising the
<literal>Parsing.Parse_error</literal> exception.
We have not written any error rules in this example, so any invalid input will
cause the calculator program to raise exception.
This is not clean behavior for a
real calculator, but it is adequate for the first example.
</para>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-running-ocamlyacc">
<title>Running Ocamlyacc to Make the Parser</title>

<para>
Before running Ocamlyacc to produce a parser, we need to decide how to
arrange all the source code in source files.
For our example, we make three files:
<literal>rpcalc.mly</literal> for Ocamlyacc grammar file,
<literal>lexer.mll</literal> for Ocamllex input file,
<literal>main.ml</literal> which contains main function which calls our
parser function.
</para>

<para>
You can use the following command to
convert the parser grammar file into a parser file:
</para>

<programlisting role="C">
ocamlyacc <emphasis>file_name</emphasis>.mly
</programlisting>

<para>
In this example the file was called <literal>rpcalc.mly</literal>
(for ``Reverse Polish CALCulator'').
Ocamlyacc produces a file named <emphasis>file_name</emphasis><literal>.ml</literal>.
The file output by
Ocamlyacc contains the source code for parser function <literal>input</literal>.
The additional functions in the input file (<literal>parse_error</literal>)
are copied verbatim to the output.
</para>
</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-compiling">
<title>Compiling the Parser File</title>

<para>
Here is how to compile and run the parser file and lexer file:
</para>

<programlisting role="C">
# List files in current directory.
$ ls
.depend  Makefile  lexer.mll  main.ml  rpcalc.mly

# Compile the Ocamlyacc parser.
$ make
ocamlyacc rpcalc.mly
ocamlc -c rpcalc.mli
ocamllex lexer.mll
15 states, 304 transitions, table size 1306 bytes
ocamlc -c lexer.ml
ocamlc -c rpcalc.ml
ocamlc -c main.ml
ocamlc -o rpcalc lexer.cmo rpcalc.cmo main.cmo
rm rpcalc.mli lexer.ml rpcalc.ml

# List files again.
$ ls
./   .depend   lexer.cmo  main.cmi   main.ml   rpcalc.cmi  rpcalc.mly
../  Makefile  lexer.cmi  lexer.mll  main.cmo  rpcalc*	   rpcalc.cmo
</programlisting>

<para>
The file <literal>rpcalc</literal> now contains the executable code.  Here is an
example session using <literal>rpcalc</literal>.
</para>

<programlisting role="C">
$ rpcalc
4 9 +
	13
3 7 + 3 4 5 *+-
	-13
3 7 + 3 4 5 * + - n	Note the unary minus, <literal>n</literal>
	13
5 6 / 4 n +
	-3.166666667
3 4 ^			Exponentiation
	81
^D			End-of-file indicator
$

</programlisting>

</sect2>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-infix-notation-calculator">
<title>Infix Notation Calculator: calc</title>

<para>
We now modify rpcalc to handle infix operators instead of postfix.  Infix
notation involves the concept of operator precedence and the need for
parentheses nested to arbitrary depth.  Here is the Ocamlyacc code for
<literal>calc.mly</literal>, an infix desk-top calculator.
</para>

<programlisting role="C">
/* file: calc.mly */
/* Infix notatoin calculator -- calc */
%{
  open Printf
%}

/* Ocamlyacc Declarations */
%token NEWLINE
%token LPAREN RPAREN
%token &lt;float&gt; NUM
%token PLUS MINUS MULTIPLY DIVIDE CARET

%left PLUS MINUS
%left MULTIPLY DIVIDE
%left NEG		/* negation -- unary minus */
%right CARET	/* exponentiation */

%start input
%type &lt;unit&gt; input

/* Grammar follows */
%%
input:	/* empty */	{ }
	| input line	{ }
;
line:	NEWLINE		{ }
	| exp NEWLINE	{ printf "\t%.10g\n" $1; flush stdout }
;
exp:	NUM			{ $1 }
	| exp PLUS exp		{ $1 +. $3 }
	| exp MINUS exp		{ $1 -. $3 }
	| exp MULTIPLY exp		{ $1 *. $3 }
	| exp DIVIDE exp		{ $1 /. $3 }
	| MINUS exp %prec NEG	{ -. $2 }
	| exp CARET exp		{ $1 ** $3 }
	| LPAREN exp RPAREN	{ $2 }
;

%%
</programlisting>

<para>
There are two important new features shown in this code.
</para>

<para>
In the second section (Ocamlyacc declarations), <literal>%left</literal> 
says they are left-associative operators.  The declarations
<literal>%left</literal> and <literal>%right</literal> (right associativity)
is used for the declaration of associativity.
</para>

<para>
Operator precedence is determined by the line ordering of the
declarations; the higher the line number of the declaration (lower on
the page or screen), the higher the precedence.  Hence, exponentiation
has the highest precedence, unary minus (<literal>NEG</literal>) is next, followed
by <literal>MULTIPLY</literal> and <literal>DIVIDE</literal>, and so on.
See <link linkend="sec-operator-precedence">Operator Precedence</link>.
</para>

<para>
The other important new feature is the <literal>%prec</literal> in the grammar section
for the unary minus operator.  The <literal>%prec</literal> simply instructs Ocamlyacc that
the rule <literal>| MINUS exp</literal> has the same precedence as <literal>NEG</literal>---in this
case the next-to-highest.
See <link linkend="sec-context-dependent-precedence">Context-Dependent Precedence</link>.
</para>

<para>
Here is a sample run of <literal>calc.mly</literal>:
</para>

<programlisting role="C">
$ calc
4 + 4.5 - (34/(8*3+-3))
	6.880952381
-56 + 2
	-54
3 ^ 2
	9
</programlisting>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-simple-error-recovery">
<title>Simple Error Recovery</title>

<para>
Up to this point, this manual has not addressed the issue of
<emphasis>error recovery</emphasis>---how to continue parsing after the parser detects a syntax
error.  All we have handled is error reporting with <literal>parse_error</literal>.
Recall that by default, the parser function raises exception after calling
<literal>parse_error</literal>.
This means that an erroneous input line causes the
calculator program to raise exception and exit.
Now we show how to rectify this deficiency.
</para>

<para>
The Ocamlyacc language itself includes the reserved word <literal>error</literal>, which
may be included in the grammar rules.  In the example below it has
been added to one of the alternatives for <literal>line</literal>:
</para>

<programlisting role="C">
line:     NEWLINE
        | exp NEWLINE		{ printf "\t%.10g\n" $1; flush stdout }
        | error NEWLINE		{ }
;
</programlisting>

<para>
This addition to the grammar allows for simple error recovery in the
event of a parse error.  If an expression that cannot be evaluated is
read, the error will be recognized by the third rule for <literal>line</literal>,
and parsing will continue.  (The <literal>parse_error</literal> function is still called.)
The action executes the statement and continues to parse.
</para>

<para>
This form of error recovery deals with syntax errors.  There are other
kinds of errors; for example, division by zero, which raises an exception
that is normally fatal.  A real calculator program must handle this
exception and resume parsing
input lines; it would also have to discard the rest of the current line of
input.  We won't discuss this issue further because it is not specific to
Ocamlyacc programs.
</para>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-location-tracking-calculator">
<title>Location Tracking Calculator: ltcalc</title>

<para>
This example extends the infix notation calculator with location
tracking.  This feature will be used to improve the error messages.  For
the sake of clarity, this example is a simple integer calculator, since
most of the work needed to use locations will be done in the lexical
analyser.

</para>

<!-- ************************************************************** -->
<sect2 id="sec-declarations-for-ltcalc">
<title>Declarations for ltcalc</title>

<para>
The Ocaml and Ocamlyacc declarations for the location tracking calculator are
the same as the declarations for the infix notation calculator
except <literal>open Lexing</literal>.
</para>

<programlisting role="C">
/* file: ltcalc.mly */
/* Location tracking calculator. */
%{
open Printf
open Lexing
%}

/* Ocamlyacc Declarations */
%token NEWLINE
%token LPAREN RPAREN
%token &lt;float&gt; NUM
%token PLUS MINUS MULTIPLY DIVIDE CARET

%left PLUS MINUS
%left MULTIPLY DIVIDE
%left NEG	/* negation -- unary minus */
%right CARET	/* exponentiation */

%start input
%type &lt;unit&gt; input

/* Grammar follows */
%%
</programlisting>

<para>
Note there are no declarations specific to locations.  Defining a data
type for storing locations is not needed: we will use the type provided
by default
(see <link linkend="sec-data-type-of-locations">Data Type of Locations</link>),
which is a
four member structure with the following fields:
</para>

<programlisting role="C">
type Lexing.position = {
  pos_fname : string; 
  pos_lnum : int; 
  pos_bol : int; 
  pos_cnum : int; 
} 
</programlisting>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-grammar-rules-for-ltcalc">
<title>Grammar Rules for ltcalc</title>

<para>
Whether handling locations or not has no effect on the syntax of your
language.  Therefore, grammar rules for this example will be very close
to those of the previous example: we will only modify them to benefit
from the new information.
</para>

<para>
Here, we will use locations to report divisions by zero, and locate the
wrong expressions or subexpressions.
</para>

<programlisting role="C">
input:	/* empty */	{ }
	| input line	{ }
;
line:	NEWLINE		{ }
	| exp NEWLINE	{ Printf.printf "\t%.10g\n" $1; flush stdout }
;
exp:	NUM			{ $1 }
	| exp PLUS exp		{ $1 +. $3 }
	| exp MINUS exp		{ $1 -. $3 }
	| exp MULTIPLY exp		{ $1 *. $3 }
	| exp DIVIDE exp		{ if $3 &lt;&gt; 0.0 then $1 /. $3
				  else (
				    let start_pos = Parsing.rhs_start_pos 3 in
				    let end_pos = Parsing.rhs_end_pos 3 in
				    printf "%d.%d-%d.%d: division by zero"
				      start_pos.pos_lnum (start_pos.pos_cnum - start_pos.pos_bol)
				      end_pos.pos_lnum (end_pos.pos_cnum - end_pos.pos_bol);
				    1.0
				  )
				}
	| MINUS exp %prec NEG	{ -. $2 }
	| exp CARET exp		{ $1 ** $3 }
	| LPAREN exp RPAREN	{ $2 }
;

</programlisting>

<para>
This code shows how to reach locations inside of semantic actions.
For rule components, use the following functions,
</para>

<programlisting role="C">
val Parsing.rhs_start_pos : int -> Lexing.position
val Parsing.rhs_end_pos : int -> Lexing.position
</programlisting>

<para>
where the integer parameter says the position of the components on
the right-hand side of the rule.
It is 1 for the leftmost component.
</para>

<para>
For groupings, use the following functions.
</para>

<programlisting role="C">
val Parsing.symbol_start_pos : unit -> Lexing.position
val Parsing.symbol_end_pos : unit -> Lexing.position
</programlisting>

<para>
We don't need to calculate the values of the position: the output parser does it
automatically.
<literal>symbol_start_pos</literal> is set to the beginning of
the leftmost component,
and <literal>symbol_end_pos</literal> to the end of the rightmost component.
</para>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-ltcalc-lexical-analyzer">
<title>The "ltcalc" Lexical Analyzer</title>

<para>
Until now, we relied on Ocamlyacc's defaults to enable location
tracking. The next step is to rewrite the lexical analyser, and make it
able to feed the parser with the token locations, as it already does for
semantic values.
</para>

<para>
To this end, we must take into account every single character of the
input text, to avoid the computed locations of being fuzzy or wrong.
<literal>lexbuf.lex_curr_p.pos_cnum</literal> is updated automatically
for scanning a character by the lexer engine, so you have to update
only <literal>lexbuf.lex_curr_p.pos_lnum</literal> and
<literal>lexbuf.lex_curr_p.pos_bol</literal>.
</para>

<programlisting role="C">
(* file: lexer.mll *)
(* Lexical analyzer returns one of the tokens:
   the token NUM of a floating point number,
   operators (PLUS, MINUS, MULTIPLY, DIVIDE, CARET, UMINUS),
   or NEWLINE.  It skips all blanks and tabs, and unknown characters
   and raises End_of_file on EOF. *)

{
  open Ltcalc
  open Lexing
  let incr_lineno lexbuf =
    let pos = lexbuf.lex_curr_p in
    lexbuf.lex_curr_p &lt;- { pos with
      pos_lnum = pos.pos_lnum + 1;
      pos_bol = pos.pos_cnum;
    }
}
let digit = ['0'-'9']
rule token = parse
  | [' ' '\t']	{ token lexbuf }
  | '\n'		{ incr_lineno lexbuf; NEWLINE }
  | digit+
  | "." digit+
  | digit+ "." digit* as num
		{ NUM (float_of_string num) }
  | '+'		{ PLUS }
  | '-'		{ MINUS }
  | '*'		{ MULTIPLY }
  | '/'		{ DIVIDE }
  | '^'		{ CARET }
  | '('		{ LPAREN }
  | ')'		{ RPAREN }
  | _		{ token lexbuf }
  | eof		{ raise End_of_file }
</programlisting>

<para>
Basically, the lexical analyzer performs the same processing as before:
it skips blanks and tabs, and reads numbers, operators or delimiters.
In addition, it updates <literal>lexbuf.lex_curr_p</literal>
containing the token's location.
</para>

<para>
Now, each time this function returns a token, the parser has its number
as well as its semantic value, and its location in the text.
</para>

<para>
Remember that computing locations is not a matter of syntax.  Every
character must be associated to a location update, whether it is in
valid input, in comments, in literal strings, and so on.
</para>

</sect2>


</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-multi-function-calculator">
<title>Multi-Function Calculator: mfcalc</title>

<para>
Now that the basics of Ocamlyacc have been discussed, it is time to move on to
a more advanced problem.  The above calculators provided only five
functions, <literal>+</literal>, <literal>-</literal>, <literal>*</literal>, <literal>/</literal> and <literal>^</literal>.  It would
be nice to have a calculator that provides other mathematical functions such
as <literal>sin</literal>, <literal>cos</literal>, etc.
</para>

<para>
In this example,
we will show how to implement built-in functions whose syntax has this form:
</para>

<programlisting role="C">
<emphasis>function_name</emphasis> (<emphasis>argument</emphasis>)
</programlisting>

<para>
At the same time, we will add memory to the calculator, by allowing you
to create named variables, store values in them, and use them later.
Here is a sample session with the multi-function calculator:
</para>

<programlisting role="C">
$ mfcalc
pi = 3.14159265
        3.1415927
sin(pi/2)
        1
alpha = beta1 = 2.3
        2.3
alpha
        2.3
log(alpha)
        0.83290912
exp(log(beta1))
        2.3
^D
$
</programlisting>

<para>
Note that multiple assignment and nested function calls are permitted.
</para>

<!-- ************************************************************** -->
<sect2 id="sec-declarations-for-mfcalc">
<title>Declarations for mfcalc</title>

<para>
Here are the Ocaml and Ocamlyacc declarations for the multi-function calculator.
</para>

<programlisting role="C">
/* file: mfcalc.mly */
%{

open Printf
open Lexing

let var_table = Hashtbl.create 16

%}

/* Ocamlyacc Declarations */
%token NEWLINE
%token LPAREN RPAREN EQ
%token &lt;float&gt; NUM
%token PLUS MINUS MULTIPLY DIVIDE CARET
%token &lt;string&gt; VAR
%token &lt;float-&gt;float&gt; FNCT

%left PLUS MINUS
%left MULTIPLY DIVIDE
%left NEG	/* negation -- unary minus */
%right CARET	/* exponentiation */

%start input
%type &lt;unit&gt; input

/* Grammar follows */
%%
</programlisting>

<!--
<para>
The above grammar introduces only two new features of the Ocamlyacc language.
These features allow semantic values to have various data types
(see <link linkend="sec-more-than-one-value-type">More Than One Value Type</link>).
</para>
-->

<para>
Since values can have various types, it is necessary to associate a
type with each grammar symbol whose semantic value is used.  These symbols
are <literal>NUM</literal>, <literal>VAR</literal>, <literal>FNCT</literal>, and <literal>exp</literal>.
The declarations of terminals are augmented with information
about their data type (placed between angle brackets).
</para>

<para>
The data type of non-terminal, <literal>exp</literal>, is nomally declared
implicitly by the action.
</para>

<para>
In header section, a hash table called <literal>var_table</literal>
is created for storing variable's name and value.
This will be used in the semantic action part.
See <link linkend="sec-mfcalc-symbol-table">The mfcalc Symbol Table</link>.
</para>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-grammar-rules-for-mfcalc">
<title>Grammar Rules for mfcalc</title>

<para>
Here are the grammar rules for the multi-function calculator.
Most of them are copied directly from <literal>calc</literal>; three rules,
those which mention <literal>VAR</literal> or <literal>FNCT</literal>, are new.
</para>

<programlisting role="C">
input:	/* empty */	{ }
	| input line	{ }
;
line:	NEWLINE		{ }
	| exp NEWLINE	{ printf "\t%.10g\n" $1; flush stdout }
	| error NEWLINE	{ }
;
exp:	NUM			{ $1 }
	| VAR			{ try Hashtbl.find var_table $1
				  with Not_found ->
				    printf "no such variable '%s'\n" $1;
				    0.0
				}
	| VAR EQ exp		{ Hashtbl.replace var_table $1 $3;
				  $3
				}
	| FNCT LPAREN exp RPAREN	{ $1 $3 }
	| exp PLUS exp		{ $1 +. $3 }
	| exp MINUS exp		{ $1 -. $3 }
	| exp MULTIPLY exp	{ $1 *. $3 }
	| exp DIVIDE exp	{ $1 /. $3 }
	| MINUS exp %prec NEG	{ -. $2 }
	| exp CARET exp		{ $1 ** $3 }
	| LPAREN exp RPAREN	{ $2 }
;

%%
</programlisting>

<para>
For the meaning of the semantic actions related with <literal>VAR</literal>,
see <link linkend="sec-mfcalc-symbol-table">The mfcalc Symbol Table</link>.
</para>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-mfcalc-symbol-table">
<title>The mfcalc Symbol Table</title>

<para>
The multi-function calculator requires a symbol table to keep track of the
names and meanings of variables and functions.  This doesn't affect the
grammar rules (except for the actions) or the Ocamlyacc declarations, but it
requires some additional Ocaml functions for support.
</para>

<para>
In this example, we use two symbol tables: one for variables and
one for functions. The variable symbol table is defined and used in
parser and the function symbol table is defined and used in
lexer.
</para>

<para>
The variable symbol table itself is implemented using the hash table.
It has a key of <literal>string</literal> type and
a value of <literal>float</literal> type.
</para>

<para>
It is a simple job to modify this code to install predefined
variables such as <literal>pi</literal> or <literal>e</literal> as well.
</para>

<para>
Two important functions allow look-up and installation of symbols in the
symbol table.
The function <literal>Hashtbl.replace</literal> is passed a name and
the value of the variable to be installed.
The function <literal>Hashtbl.find</literal> is passed the name of the symbol
to look up.
If found, the value of that symbol is returned; otherwise zero is returned.
</para>

<para>
The lexical analyzer function must now recognize variables, numeric values, and
the arithmetic operators.  Strings of alphanumeric
characters with a leading non-digit are recognized as either variables or
functions depending on what the symbol table says about them.
</para>

<para>
The string is used for look up in the function symbol table.
If the name appears in the table, the corresponding function is returned to
the parser function as the value of <literal>FNCT</literal>.
If it is not, <literal>VAR</literal> with the string is returned.
</para>

<para>
No change is needed in the handling of numeric values and arithmetic
operators in the lexical analyzer function.
</para>

<programlisting role="C">
(* file: lexer.mll *)

{
  open Mfcalc
  open Lexing

  let create_hashtable size init =
    let tbl = Hashtbl.create size in
    List.iter (fun (key, data) -&gt; Hashtbl.add tbl key data) init;
    tbl

  let fun_table = create_hashtable 16 [
    ("sin", sin);
    ("cos", cos);
    ("tan", tan);
    ("asin", asin);
    ("acos", acos);
    ("atan", atan);
    ("log", log);
    ("exp", exp);
    ("sqrt", sqrt);
  ]
}

let digit = ['0'-'9']
let ident = ['a'-'z' 'A'-'Z']
let ident_num = ['a'-'z' 'A'-'Z' '0'-'9']
rule token = parse
  | [' ' '\t']	{ token lexbuf }
  | '\n'	{ NEWLINE }
  | digit+
  | "." digit+
  | digit+ "." digit* as num
		{ NUM (float_of_string num) }
  | '+'		{ PLUS }
  | '-'		{ MINUS }
  | '*'		{ MULTIPLY }
  | '/'		{ DIVIDE }
  | '^'		{ CARET }
  | '('		{ LPAREN }
  | ')'		{ RPAREN }
  | '='		{ EQ }
  | ident ident_num* as word
  		{ try
		    let f = Hashtbl.find fun_table word in
		    FNCT f
		  with Not_found -> VAR word
  		}
  | _		{ token lexbuf }
  | eof		{ raise End_of_file }
</programlisting>

<para>
A hash table named <literal>fun_table</literal> is used
for storing a function name and a value, that is, a function definition.
It is initialized in the header part of the lexer file.
</para>

<para>
This program is both powerful and flexible. You may easily add new
functions.
</para>

</sect2>

</sect1>

<!-- ************************************************************** -->
<!--
<sect1 id="sec-exercises">
<title>Exercises</title>

<para>
@enumerate
@item
Add some new functions from <literal>math.h</literal> to the initialization list.

@item
Add another array that contains constants and their values.  Then
modify <literal>init_table</literal> to add these constants to the symbol table.
It will be easiest to give the constants type <literal>VAR</literal>.

@item
Make the program report an error if the user refers to an
uninitialized variable in any way except to store a value in it.
@end enumerate


</para>
</sect1>
-->

</chapter>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-grammar-files">
<title>Ocamlyacc Grammar Files</title>

<para>
Ocamlyacc takes as input a context-free grammar specification and produces a
Ocaml-language function that recognizes correct instances of the grammar.

The Ocamlyacc grammar input file conventionally has a name ending in <literal>.yml</literal>.
See <link linkend="chap-invoking-ocamlyacc">Invoking Ocamlyacc</link>.
</para>

<!-- ************************************************************** -->
<sect1 id="sec-outline">
<title>Outline of a Ocamlyacc Grammar</title>

<para>
A Ocamlyacc grammar file has four main sections, shown here with the
appropriate delimiters:
</para>

<programlisting role="C">
%{
	<emphasis>Header</emphasis> - Ocaml declarations (Ocaml code)
%}
	<emphasis>Ocamlyacc declarations</emphasis>
%%
	<emphasis>Grammar rules</emphasis>
%%
	<emphasis>Trailer</emphasis> - Additional Ocaml code (Ocaml code)
</programlisting>

<para>
By default, comments are enclosed between /* and */ (as in C) except
in Ocaml code. So use /* and */ in the
<emphasis>declarations</emphasis> and <emphasis>rules</emphasis> sections,
(* and *) in <emphasis>header</emphasis>
and <emphasis>trailer</emphasis> sections.
</para>

<!-- ************************************************************** -->
<sect2 id="sec-header-section">
<title>The Header Section</title>

<para>
The <emphasis>header</emphasis> section contains 
declarations of functions and variables that are used in the actions in the
grammar rules.  These are copied to the beginning of the parser file so
that they precede the definition of the <emphasis>parser function</emphasis>.
You can open the other module in this area.
If you don't
need any Ocaml declarations, you may omit the <literal>%{</literal> and
<literal>%}</literal>
delimiters that bracket this section.
</para>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-ocamlyacc-declaration-section">
<title>The Ocamlyacc Declarations Section</title>

<para>
The <emphasis>ocamlyacc declarations</emphasis> section contains declarations that define
terminal and nonterminal symbols, specify precedence, and so on.
At least, there must be one <literal>%start</literal> and
the corresponding <literal>%type</literal> directives.
See <link linkend="sec-ocamlyacc-declarations">Ocamlyacc declarations</link>.
</para>
</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-grammar-rules-section">
<title>The Grammar Rules Section</title>

<para>
The <literal>grammar rules</literal> section contains one or more Ocamlyacc grammar
rules, and nothing else.
See <link linkend="sec-syntax-of-grammar-rules">Syntax of Grammar Rules</link>.
</para>

<para>
There must always be at least one grammar rule, and the first
<literal>%%</literal> (which precedes the grammar rules) may never be omitted even
if it is the first thing in the file.
</para>
</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-trailer-section">
<title>The Trailer Section</title>

<para>
The <emphasis>trailer</emphasis> section is copied verbatim to the end of the
parser file, just as the <emphasis>header</emphasis> section is copied to the
beginning.  This is the most convenient place to put anything that you
want to have in the parser file but which need not come before the
definition of the <emphasis>parse function</emphasis>.
See <link linkend="chap-parser-interface">Parser Interface</link>.
</para>

<para>
If the last section is empty, you may omit the <literal>%%</literal> that separates it
from the grammar rules.
</para>

</sect2>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-symbols-terminal-nonterminal">
<title>Symbols, Terminal and Nonterminal</title>

<para>
<emphasis>Symbols</emphasis> in Ocamlyacc grammars represent the grammatical classifications
of the language.
</para>

<para>
A <emphasis>terminal symbol</emphasis> (also known as a <emphasis>token type</emphasis>) represents a
class of syntactically equivalent tokens.  You use the symbol in grammar
rules to mean that a token in that class is allowed.  The symbol is
represented in the Ocamlyacc parser by a value of variant type,
and the <emphasis>lexer function</emphasis>
function returns a token type to indicate what kind of token has been
read. 
</para>

<para>
A <emphasis>nonterminal symbol</emphasis> stands for a class of syntactically equivalent
groupings.  The symbol name is used in writing grammar rules. 
It should start with lower case.
</para>

<para>
Symbol names can contain letters, digits (not at the beginning),
underscores.
</para>

<para>
The terminal symbols in the grammar is a <emphasis>token type</emphasis>
which is a value of variable type in Ocaml.
So it should be start with upper case.
Each such name must be defined with a Ocamlyacc declaration with
<literal>%token</literal>.
See <link linkend="sec-token-type-names">Token Type Names</link>.
</para>

<para>
The value returned by the <emphasis>lexer function</emphasis>
is always one of the terminal symbols.
Each token type becomes a Ocaml value of variant type in
the parser file, so <emphasis>lexer function</emphasis> can return one.
</para>

<para>
Because the <emphasis>lexer function</emphasis> is defined in a separate file,
you need to arrange for the token-type definitions to be available there.
After invoking "<literal>ocamlyacc</literal> <emphasis>filename</emphasis><literal>.mly</literal>",
the file
<emphasis>filename</emphasis><literal>.mli</literal> is generated
which contains token-type definitions.
It is used in <emphasis>lexer function</emphasis>.
</para>

<para>
The symbol <literal>error</literal> is a terminal symbol reserved for error recovery
(see <link linkend="chap-error-recovery">Error Recovery</link>);
you shouldn't use it for any other purpose.
</para>
</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-syntax-of-grammar-rules">
<title>Syntax of Grammar Rules</title>

<para>
A Ocamlyacc grammar rule has the following general form:
</para>

<programlisting role="C">
<emphasis>result</emphasis>:
	  <emphasis>symbol</emphasis> ... <emphasis>symbol</emphasis> { <emphasis>semantic-action</emphasis> }
	| ...
	| <emphasis>symbol</emphasis> ... <emphasis>symbol</emphasis> { <emphasis>semantic-action</emphasis> }
	;
</programlisting>

<para>
where <emphasis>result</emphasis> is the nonterminal symbol that this rule describes,
and <emphasis>symbol</emphasis> are various terminal and nonterminal symbols that
are put together by this rule
(see <link linkend="sec-symbols-terminal-nonterminal">Symbols</link>).
</para>

<para>
For example,
</para>

<programlisting role="C">
exp:      exp PLUS exp		{}
        ;
</programlisting>

<para>
says that two groupings of type <literal>exp</literal>, with a <literal>PLUS</literal> token in between,
can be combined into a larger grouping of type <literal>exp</literal>.
</para>

<para>
Whitespace in rules is significant only to separate symbols.  You can add
extra whitespace as you wish.
</para>

<para>
At the end of the components there must be one <emphasis>action</emphasis>
that determine the semantics of the rule.  An action looks like this:
</para>

<programlisting role="C">
{<emphasis>Ocaml code</emphasis>}
</programlisting>

<para>
See <link linkend="sec-actions">Actions</link> for detail description.
</para>

<para>
Multiple rules for the same <emphasis>result</emphasis> can be written
separately or can
be joined with the vertical-bar character <literal>|</literal> as follows:
</para>

<programlisting role="C">
<emphasis>result</emphasis>:
	  <emphasis>rule1-symbol</emphasis> ... <emphasis>rule1-symbol</emphasis> { <emphasis>rule1-semantic-action</emphasis> }
	| <emphasis>rule2-symbol</emphasis> ... <emphasis>rule2-symbol</emphasis> { <emphasis>rule2-semantic-action</emphasis> }
	| ...
	;
</programlisting>

<para>
They are still considered distinct rules even when joined in this way.
</para>

<para>
If <emphasis>components</emphasis> in a rule is empty,
it means that <emphasis>result</emphasis> can
match the empty string.  For example, here is how to define a
comma-separated sequence of zero or more <literal>exp</literal> groupings:
</para>

<programlisting role="C">
expseq:   /* empty */	{}
        | expseq1		{}
        ;

expseq1:  exp			{}
        | expseq1 COMMA exp		{}
        ;
</programlisting>

<para>
It is customary to write a comment <literal>/* empty */</literal> in each rule
with no components.
</para>
</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-recursive-rules">
<title>Recursive Rules</title>

<para>
A rule is called <literal>recursive</literal> when its <emphasis>result</emphasis> nonterminal appears
also on its right hand side.  Nearly all Ocamlyacc grammars need to use
recursion, because that is the only way to define a sequence of any number
of a particular thing.  Consider this recursive definition of a
comma-separated sequence of one or more expressions:
</para>

<programlisting role="C">
expseq1:  exp			{}
        | expseq1 COMMA exp		{}
        ;

</programlisting>

<para>
Since the recursive use of <literal>expseq1</literal> is the leftmost symbol
in the right hand side, we call this <literal>left recursion</literal>.
By contrast, here
the same construct is defined using <literal>right recursion</literal>:
</para>

<programlisting role="C">
expseq1:  exp			{}
        | exp COMMA expseq1		{}
        ;
</programlisting>

<para>
Any kind of sequence can be defined using either left recursion or
right recursion, but you should always use left recursion, because it
can parse a sequence of any number of elements with bounded stack
space.  Right recursion uses up space on the Ocamlyacc stack in proportion
to the number of elements in the sequence, because all the elements
must be shifted onto the stack before the rule can be applied even
once.
See <link linkend="chap-parser-algorithm">The Ocamyacc Parser Algorithm</link>,
for further explanation of this.
</para>

<para>
<literal>Indirect</literal> or <literal>mutual</literal> recursion occurs when the result of the
rule does not appear directly on its right hand side, but does appear
in rules for other nonterminals which do appear on its right hand
side.
</para>

<para>
For example:
</para>

<programlisting role="C">
expr:     primary			{}
        | primary PLUS primary	{}
        ;

primary:  constant			{}
        | LPAREN expr RPAREN	{}
        ;
</programlisting>

<para>
defines two mutually-recursive nonterminals, since each refers to the
other.
</para>
</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-defining-language-semantics">
<title>Defining Language Semantics</title>

<para>
The grammar rules for a language determine only the syntax.  The semantics
are determined by the semantic values associated with various tokens and
groupings, and by the actions taken when various groupings are recognized.
</para>

<para>
For example, the calculator calculates properly because the value
associated with each expression is the proper number; it adds properly
because the action for the grouping <literal>x + y</literal> is to add
the numbers associated with <emphasis>x</emphasis> and <emphasis>y</emphasis>.
</para>

<!-- ************************************************************** -->
<sect2 id="sec-data-types-of-semantic-values">
<title>Data Types of Semantic Values</title>

<para>
In a simple program it may be sufficient to use the same data type for
the semantic values of all language constructs.
But in most programs, you will need different data types for different kinds
of tokens and groupings.
For example, a numeric constant may need type
<literal>int</literal> or <literal>float</literal>, while a string constant
or an identifier might need type <literal>string</literal>.
</para>

<para>
To use more than one data type for semantic values in one parser, Ocamlyacc
requires you to do:
Choose one of those types for each symbol (terminal or nonterminal) for
which semantic values are used.  This is done for tokens with the
<literal>%token</literal> Ocamlyacc declaration
(see <link linkend="sec-token-type-names">Token Type Names</link>)
and for groupings with the <literal>%type</literal> Ocamlyacc declaration
(see <link linkend="sec-nonterminal-symbols">Nonterminal Symbols</link>).
</para>

<!--
<para>
To use more than one data type for semantic values in one parser, Ocamlyacc
requires you to do two things:
</para>

<para>
@itemize @bullet
@item
Specify the entire collection of possible data types, with the
<literal>%union</literal> Ocamlyacc declaration (@pxref{Union Decl, ,The Collection of Value Types}).

@item
Choose one of those types for each symbol (terminal or nonterminal) for
which semantic values are used.  This is done for tokens with the
<literal>%token</literal> Ocamlyacc declaration
(see <link linkend="sec-token-type-names">Token Type Names</link>)
and for groupings with the <literal>%type</literal> Ocamlyacc declaration
(see <link linkend="sec-nonterminal-symbols">Nonterminal Symbols</link>).
@end itemize
</para>
-->

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-actions">
<title>Actions</title>

<para>
An action accompanies a syntactic rule and contains Ocaml code to be executed
each time an instance of that rule is recognized.  The task of most actions
is to compute a semantic value for the grouping built by the rule from the
semantic values associated with tokens or smaller groupings.
</para>

<para>
An action consists of Ocaml statements surrounded by braces.
All rules have just one action at the end
of the rule, following all the components.
</para>

<para>
The Ocaml code in an action can refer to the semantic values of the components
matched by the rule with the construct <literal>$n</literal>, which stands for
the value of the <emphasis>n</emphasis>th component.
The value of the evaluation of the action is the value for the grouping being
constructed.
</para>

<para>
Here is a typical example:
</para>

<programlisting role="C">
exp:    ...
        | exp PLUS exp { $1 +. $3 }
</programlisting>

<para>

This rule constructs an <literal>exp</literal> from two smaller <literal>exp</literal> groupings
connected by a plus-sign token.  In the action, <literal>$1</literal> and <literal>$3</literal>
refer to the semantic values of the two component <literal>exp</literal> groupings,
which are the first and third symbols on the right hand side of the rule.
The sum is returned so that it becomes the semantic value of
the addition-expression just recognized by the rule.
If there were a
useful semantic value associated with the <literal>PLUS</literal> token,
it could be referred to as <literal>$2</literal>.
</para>

<!--
<para>
If you don't specify an action for a rule, Ocamlyacc supplies a default:
@w{<literal>$$ = $1</literal>.}  Thus, the value of the first symbol in the rule becomes
the value of the whole rule.  Of course, the default rule is valid only
if the two data types match.  There is no meaningful default action for
an empty rule; every empty rule must have an explicit action unless the
rule's value does not matter.
</para>
-->

<!--
<para>
<literal>$n</literal> with <emphasis>n</emphasis> zero or negative is allowed for reference
to tokens and groupings on the stack <emphasis>before</emphasis> those that match the
current rule.  This is a very risky practice, and to use it reliably
you must be certain of the context in which the rule is applied.  Here
is a case in which you can use this reliably:
</para>

<programlisting role="C">
foo:      expr bar '+' expr  { ... }
        | expr bar '-' expr  { ... }
        ;
bar:      /* empty */
        { previous_expr = $0; }
        ;
</programlisting>

<para>
As long as <literal>bar</literal> is used only in the fashion shown here, <literal>$0</literal>
always refers to the <literal>expr</literal> which precedes <literal>bar</literal> in the
definition of <literal>foo</literal>.
</para>

-->

</sect2>

<!-- ************************************************************** -->
<!--
<sect2 id="sec-data-types-values-in-actions">
<title>Data Types of Values in Actions</title>

<para>
If you have chosen a single data type for semantic values, the <literal>$$</literal>
and <literal>$n</literal> constructs always have that data type.
</para>

<para>
If you have used <literal>%union</literal> to specify a variety of data types, then you
must declare a choice among these types for each terminal or nonterminal
symbol that can have a semantic value.  Then each time you use <literal>$$</literal> or
<literal>$n</literal>, its data type is determined by which symbol it refers to
in the rule.  In this example,
</para>

<programlisting role="C">


exp:    ...
        | exp '+' exp
            { $$ = $1 + $3; }


</programlisting>

<para>

<literal>$1</literal> and <literal>$3</literal> refer to instances of <literal>exp</literal>, so they all
have the data type declared for the nonterminal symbol <literal>exp</literal>.  If
<literal>$2</literal> were used, it would have the data type declared for the
terminal symbol <literal>'+'</literal>, whatever that might be.
</para>

<para>
Alternatively, you can specify the data type when you refer to the value,
by inserting <literal>"type"</literal> after the <literal>$</literal> at the beginning of the
reference.  For example, if you have defined types as shown here:
</para>

<programlisting role="C">


%union {
  int itype;
  double dtype;
}


</programlisting>

<para>

then you can write <literal>"$itype"1</literal> to refer to the first subunit of the
rule as an integer, or <literal>"$dtype"1</literal> to refer to it as a double.
</para>
</sect2>
-->

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-tracking-locations">
<title>Tracking Locations</title>

<para>
Though grammar rules and semantic actions are enough to write a fully
functional parser, it can be useful to process some additionnal informations,
especially symbol locations.
</para>

<para>
The way locations are handled is defined by providing a data type, and actions
to take when rules are matched.
</para>

<!-- ************************************************************** -->
<sect2 id="sec-data-type-of-locations">
<title>Data Type of Locations</title>

<remark>
This content of this section is valid since Ocaml 3.08.
</remark>

<para>
The data type for locations has the following type:
</para>

<programlisting role="C">
  type position = {
     pos_fname : string;	(* file name *)
     pos_lnum : int;		(* line number *)
     pos_bol : int;		(* the offset of the beginning of the line *)
     pos_cnum : int;		(* the offset of the position *)
  } 
</programlisting>

<para>
The value of <literal>pos_bol</literal> field is the number of characters between the beginning of the file and the beginning of the line
while the value of <literal>pos_cnum</literal> field is the number of characters between the beginning of the file and the position.
</para>

<para>
The lexing engine manages only the <literal>pos_cnum</literal> field of
<literal>lexbuf.lex_curr_p</literal> with the number of characters read
from the start of <literal>lexbuf</literal>. So you are reponsible for the other fields to be accurate.
Before using the location in the parser,
you have to set <literal>Lexing.lexbuf.lex_curr_p</literal> correctly in lexer,
using such a function like this:
</para>

<programlisting role="C">
  let incr_linenum lexbuf =
    let pos = lexbuf.Lexing.lex_curr_p in
    lexbuf.Lexing.lex_curr_p &lt;- { pos with
      Lexing.pos_lnum = pos.Lexing.pos_lnum + 1;
      Lexing.pos_bol = pos.Lexing.pos_cnum;
    }
  ;;
</programlisting>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-actions-and-locations">
<title>Actions and Locations</title>

<para>
Actions are not only useful for defining language semantics, but also for
describing the behavior of the output parser with locations.

The most obvious way for building locations of syntactic groupings is very
similar to the way semantic values are computed. In a given rule, several
constructs can be used to access the locations of the elements being matched.
The location of the <emphasis>n</emphasis>th component of the right hand side can be
obtained with:
</para>

<programlisting role="C">
val Parsing.rhs_start : int -> int
val Parsing.rhs_end : int -> int
</programlisting>

<para>
<literal>Parsing.rhs_start n</literal>
returns the offset of the first character 
of the <emphasis>n</emphasis>th item on the right-hand side of the rule,
while
<literal>Parsing.rhs_end n</literal>
returns the offset after the last character of the item.
are to be called in the action part of a grammar rule only.
<emphasis>n</emphasis> is 1 for the leftmost item
and the first character in a file is at offset 0.
</para>

<para>
Or you can use the following functions:
</para>

<programlisting role="C">
val Parsing.rhs_start_pos : int -> Lexing.position
val Parsing.rhs_end_pos : int -> Lexing.position
</programlisting>

<para>
(Since Ocaml 3.08) These functions return a position instead of an offset
(see <link linkend="sec-data-type-of-locations">Data Type of Locations</link>).
</para>

<para>
The location of the left hand side grouping can be referred by 
</para>

<programlisting role="C">
val Parsing.symbol_start : unit -> int
val Parsing.symbol_end : unit -> int
</programlisting>

<para>
The <literal>symbol_start ()</literal> returns the offset of
the first character of the left-hand side of the rule
while <literal>symbol_end ()</literal> returns the offset after the last
character.
</para>

<para>
(Since Ocaml 3.08) The following functions are same as
<literal>symbol_start</literal> and
<literal>symbol_end</literal>, except returning a position instead of
an offset
(see <link linkend="sec-data-type-of-locations">Data Type of Locations</link>).
</para>

<programlisting role="C">
val Parsing.symbol_start_pos : unit -> Lexing.position
val Parsing.symbol_end_pos : unit -> Lexing.position
</programlisting>

<para>
Here is a basic example using the default data type for locations:
</para>

<programlisting role="C">
exp:	...
	| exp DIVIDE exp
		{ if $3 &lt;&gt; 0.0 then $1 /. $3
		  else (
		    let start_pos = Parsing.rhs_start_pos 3 in
		    let end_pos = Parsing.rhs_end_pos 3 in
		    printf "%d.%d-%d.%d: division by zero"
		      start_pos.pos_lnum (start_pos.pos_cnum - start_pos.pos_bol)
		      end_pos.pos_lnum (end_pos.pos_cnum - end_pos.pos_bol);
		    1.0
		  )
		}
</programlisting>
</sect2>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-ocamlyacc-declarations">
<title>Ocamlyacc Declarations</title>

<para>
The <literal>Ocamlyacc declarations</literal> section of a Ocamlyacc grammar defines the symbols
used in formulating the grammar and the data types of semantic values.
See <link linkend="sec-symbols-terminal-nonterminal">Symbols</link>.
</para>

<para>
All token type must be declared.  Nonterminal symbols must be
declared if you need to specify which data type to use for the semantic
value
(see <link linkend="sec-data-types-of-semantic-values">Data Types of Semantic Values</link>).
</para>

<para>
The first rule in the file also specifies the start symbol, by default.
If you want some other symbol to be the start symbol, you must declare
it explicitly
(see <link linkend="sec-language-and-grammar">Languages and Context-Free Grammars</link>).
</para>

<!-- ************************************************************** -->
<sect2 id="sec-token-type-names">
<title>Token Type Names</title>

<para>
The basic way to declare a token type name (terminal symbol) is as follows:
</para>

<programlisting role="C">
%token <emphasis>name</emphasis> ... <emphasis>name</emphasis>
%token &lt;type&gt; <emphasis>name</emphasis> ... <emphasis>name</emphasis>
</programlisting>

<para>
Ocamlyacc will convert this into a token type in
the parser, so that the lexer function
can use the name <emphasis>name</emphasis> to stand for this token type's code.
</para>

<para>
In the event that the token has a value, you must augment the
<literal>%token</literal> declaration to include the data type
alternative delimited by angle-brackets
(see <link linkend="sec-data-types-of-semantic-values">Data Types of Semantic Values</link>).
</para>

<para>
For example:
</para>

<programlisting role="C">
%token &lt;float&gt; NUM	/* define toke NUM and its type */
</programlisting>

<para>
The <emphasis>type</emphasis> part is an arbitrary Caml type expression,
</para>

<remark>
Because only the &lt;type&gt; part is copied
to the <literal>.mli</literal> output file,
all type constructor names must be fully qualified
(e.g. <literal>Module_name.type_name</literal>) for all types
except standard built-in types.
</remark>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-operator-precedence-decl">
<title>Operator Precedence</title>

<para>
Use the <literal>%left</literal>, <literal>%right</literal> or <literal>%nonassoc</literal> declaration to
 specify token's precedence and associativity, all at
once.
These are called <literal>precedence declarations</literal>.
See <link linkend="sec-operator-precedence">Operator Precedence</link>,
for general information on operator precedence.
</para>

<para>
The syntax of a precedence declaration is
</para>

<programlisting role="C">
%left <emphasis>symbols</emphasis> ...<emphasis>symbols</emphasis>
%right <emphasis>symbols</emphasis> ...<emphasis>symbols</emphasis>
%nonassoc <emphasis>symbols</emphasis> ...<emphasis>symbols</emphasis>
</programlisting>

<para>
They specify the associativity and relative precedence for
all the <emphasis>symbols</emphasis>:
</para>

<itemizedlist>
<listitem>
  <simpara>
The associativity of an operator <emphasis>op</emphasis> determines how repeated uses
of the operator nest: whether <emphasis>x op y op z</emphasis>
is parsed by grouping <emphasis>x</emphasis> with <emphasis>y</emphasis> first or by
grouping <emphasis>y</emphasis> with <emphasis>z</emphasis> first.
<literal>%left</literal> specifies
left-associativity (grouping <emphasis>x</emphasis> with
<emphasis>y</emphasis> first) and
<literal>%right</literal> specifies right-associativity
(grouping <emphasis>y</emphasis> with
<emphasis>z</emphasis> first).
<literal>%nonassoc</literal> specifies no associativity, which
means that <emphasis>x op y op z</emphasis> is
considered a syntax error.
  </simpara>
</listitem>

<listitem>
  <simpara>
The precedence of an operator determines how it nests with other operators.
All the tokens declared in a single precedence declaration have equal
precedence and nest together according to their associativity.
When two tokens declared in different precedence declarations associate,
the one declared later has the higher precedence and is grouped first.
  </simpara>
</listitem>
</itemizedlist>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-nonterminal-symbols">
<title>Nonterminal Symbols</title>

<para>
You can declare the value type of each nonterminal symbol
for which values are
used.  This is done with a <literal>%type</literal> declaration, like this:
</para>

<programlisting role="C">
%type &lt;type&gt; <emphasis>nonterminal</emphasis> ... <emphasis>nonterminal</emphasis>
</programlisting>

<para>
Here <emphasis>nonterminal</emphasis> is the name of a nonterminal
symbol, and <emphasis>type</emphasis>
is the name of the type that you want.
You can give any number of start nonterminal symbols in
the same <literal>%type</literal> declaration,
if they have the same value type. 
Use spaces to separate the symbol names.
</para>

<para>
This is necessary for start symbols.
For the <emphasis>type</emphasis> part,
see <link linkend="sec-token-type-names">Token Type Names</link>.
</para>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-start-symbol">
<title>The Start-Symbol</title>

<para>
You have to declare the start symbols using
<literal>%start</literal> declaration as follows:
</para>

<programlisting role="C">
%start <emphasis>symbol</emphasis> ... <emphasis>symbol</emphasis>
</programlisting>

<para>
Each start symbol has a parsing function with the same name in the output file
so you can use it as an entry point for the grammar.
As noted eariler, type should be assinged to each start symbol
using <literal>%type</literal> directive
(see <link linkend="sec-nonterminal-symbols">Nonterminal Symbols</link>).
</para>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-ocamlyacc-declaration-summary">
<title>Ocamlyacc Declaration Summary</title>

<para>
Here is a summary of the declarations used to define a grammar:
</para>

<itemizedlist>
<listitem>
  <simpara><literal>%token</literal>
    Declare a terminal symbol (token type name) with no precedence
    or associativity specified
    (see <link linkend="sec-token-type-names">Token Type Names</link>).
  </simpara>
</listitem>

<listitem>
  <simpara><literal>%right</literal>
    Declare a terminal symbol (token type name) that is right-associative
    (see <link linkend="sec-operator-precedence-decl">Operator Precedence</link>).
  </simpara>
</listitem>

<listitem>
  <simpara><literal>%left</literal>
    Declare a terminal symbol (token type name) that is left-associative
    (see <link linkend="sec-operator-precedence-decl">Operator Precedence</link>).
  </simpara>
</listitem>

<listitem>
  <simpara><literal>%nonassoc</literal>
    Declare a terminal symbol (token type name) that is nonassociative
    (using it in a way that would be associative is a syntax error)
    (see <link linkend="sec-operator-precedence-decl">Operator Precedence</link>).
  </simpara>
</listitem>

<listitem>
  <simpara><literal>%type</literal>
    Declare the type of semantic values for a nonterminal symbol
    (see <link linkend="sec-nonterminal-symbols">Nonterminal Symbols</link>).
  </simpara>
</listitem>

<listitem>
  <simpara><literal>%start</literal>
    Specify the grammar's start symbol
    (see <link linkend="sec-start-symbol">The Start-Symbol</link>).
  </simpara>
</listitem>
</itemizedlist>

<!--
<para>
In order to change the behavior of @command{ocamlyacc}, use the following
directives:
</para>

<para>
@table @code
@item %debug
In the parser file, define the macro <literal>YYDEBUG</literal> to 1 if it is not
already defined, so that the debugging facilities are compiled.
@xref{Debugging, ,Debugging Your Parser}.

@item %defines
Write an extra output file containing macro definitions for the token
type names defined in the grammar and the semantic value type
<literal>YYSTYPE</literal>, as well as a few <literal>extern</literal> variable declarations.

If the parser output file is named <emphasis>name</emphasis><literal>.c</literal> then this file
is named <emphasis>name</emphasis><literal>.h</literal>.

This output file is essential if you wish to put the definition of
<literal>yylex</literal> in a separate source file, because <literal>yylex</literal> needs to
be able to refer to token type codes and the variable
<literal>yylval</literal>.  @xref{Token Values, ,Semantic Values of Tokens}.

@item %file-prefix="<emphasis>prefix</emphasis>"
Specify a prefix to use for all Ocamlyacc output file names.  The names are
chosen as if the input file were named <emphasis>prefix</emphasis><literal>.y</literal>.

@c @item %header_extension
@c Specify the extension of the parser header file generated when
@c <literal>%define</literal> or <literal>-d</literal> are used.
@c
@c For example, a grammar file named <literal>foo.ypp</literal> and containing a
@c <literal>%header_extension .hh</literal> directive will produce a header file
@c named <literal>foo.tab.hh</literal>

@item %locations
Generate the code processing the locations
(see <link linkend="sec-special-features-for-use-in-actions">Special Features for Use in Actions</link>).
This mode is enabled as soon as
the grammar uses the special <literal>@n</literal> tokens, but if your
grammar does not use it, using <literal>%locations</literal> allows for more
accurate parse error messages.

@item %name-prefix="<emphasis>prefix</emphasis>"
Rename the external symbols used in the parser so that they start with
<emphasis>prefix</emphasis> instead of <literal>yy</literal>.  The precise list of symbols renamed
is <literal>yyparse</literal>, <literal>yylex</literal>, <literal>yyerror</literal>, <literal>yynerrs</literal>,
<literal>yylval</literal>, <literal>yychar</literal> and <literal>yydebug</literal>.  For example, if you
use <literal>%name-prefix="c_"</literal>, the names become <literal>c_parse</literal>,
<literal>c_lex</literal>, and so on.  @xref{Multiple Parsers, ,Multiple Parsers in
the Same Program}.

@item %no-parser
Do not include any Ocaml code in the parser file; generate tables only.  The
parser file contains just <literal>#define</literal> directives and static variable
declarations.

This option also tells Ocamlyacc to write the Ocaml code for the grammar actions
into a file named <emphasis>filename</emphasis><literal>.act</literal>, in the form of a
brace-surrounded body fit for a <literal>switch</literal> statement.

@item %no-lines
Don't generate any <literal>#line</literal> preprocessor commands in the parser
file.  Ordinarily Ocamlyacc writes these commands in the parser file so that
the Ocaml compiler and debuggers will associate errors and object code with
your source file (the grammar file).  This directive causes them to
associate errors with the parser file, treating it an independent source
file in its own right.

@item %output="<emphasis>filename</emphasis>"
Specify the <emphasis>filename</emphasis> for the parser file.

@item %pure-parser
Request a pure (reentrant) parser program (@pxref{Pure Decl, ,A Pure
(Reentrant) Parser}).

@c @item %source_extension
@c Specify the extension of the parser output file.
@c
@c For example, a grammar file named <literal>foo.yy</literal> and containing a
@c <literal>%source_extension .cpp</literal> directive will produce a parser file
@c named <literal>foo.tab.cpp</literal>

@item %token_table
Generate an array of token names in the parser file.  The name of the
array is <literal>yytname</literal>; <literal>yytname[i]</literal> is the name of the
token whose internal Ocamlyacc token code number is <emphasis>i</emphasis>.  The first three
elements of <literal>yytname</literal> are always <literal>"$"</literal>, <literal>"error"</literal>, and
<literal>"$illegal"</literal>; after these come the symbols defined in the grammar
file.

For single-character literal tokens and literal string tokens, the name
in the table includes the single-quote or double-quote characters: for
example, <literal>"'+'"</literal> is a single-character literal and <literal>"\"==\""</literal>
is a literal string token.  All the characters of the literal string
token appear verbatim in the string found in the table; even
double-quote characters are not escaped.  For example, if the token
consists of three characters <literal>*"*</literal>, its string in <literal>yytname</literal>
contains <literal>"*"*"</literal>.  (In C, that would be written as
<literal>"\"*\"*\""</literal>).

When you specify <literal>%token_table</literal>, Ocamlyacc also generates macro
definitions for macros <literal>YYNTOKENS</literal>, <literal>YYNNTS</literal>, and
<literal>YYNRULES</literal>, and <literal>YYNSTATES</literal>:

@table @code
@item YYNTOKENS
The highest token number, plus one.
@item YYNNTS
The number of nonterminal symbols.
@item YYNRULES
The number of grammar rules,
@item YYNSTATES
The number of parser states (@pxref{Parser States}).
@end table

@item %verbose
Write an extra output file containing verbose descriptions of the
parser states and what is done for each type of look-ahead token in
that state.

This file also describes all the conflicts, both those resolved by
operator precedence and the unresolved ones.

The file's name is made by removing <literal>.tab.c</literal> or <literal>.c</literal> from
the parser output file name, and adding <literal>.output</literal> instead.

Therefore, if the input file is <literal>foo.y</literal>, then the parser file is
called <literal>foo.tab.c</literal> by default.  As a consequence, the verbose
output file is called <literal>foo.output</literal>.

@item %yacc
@itemx %fixed-output-files
Pretend the option @option{-yacc} was given, i.e., imitate Yacc,
including its naming conventions.  @xref{Ocamlyacc Options}, for more.
@end table
</para>
-->

</sect2>

</sect1>

<!-- ************************************************************** -->
<!--
<sect1 id="sec-multiple-parsers">
<title>Multiple Parsers in the Same Program</title>

<para>
Most programs that use Ocamlyacc parse only one language and therefore contain
only one Ocamlyacc parser.  But what if you want to parse more than one
language with the same program?  Then you need to avoid a name conflict
between different definitions of <literal>yyparse</literal>, <literal>yylval</literal>, and so on.
</para>

<para>
The easy way to do this is to use the option <literal>-p prefix</literal>
(see <link linkend="chap-invoking-ocamlyacc">Invoking Ocamlyacc</link>).
This renames the interface functions and
variables of the Ocamlyacc parser to start with <emphasis>prefix</emphasis> instead of
<literal>yy</literal>.  You can use this to give each parser distinct names that do
not conflict.
</para>

<para>
The precise list of symbols renamed is <literal>yyparse</literal>, <literal>yylex</literal>,
<literal>yyerror</literal>, <literal>yynerrs</literal>, <literal>yylval</literal>, <literal>yychar</literal> and
<literal>yydebug</literal>.  For example, if you use <literal>-p c</literal>, the names become
<literal>cparse</literal>, <literal>clex</literal>, and so on.
</para>

<para>
@strong{All the other variables and macros associated with Ocamlyacc are not
renamed.} These others are not global; there is no conflict if the same
name is used in different parsers.  For example, <literal>YYSTYPE</literal> is not
renamed, but defining this in different ways in different parsers causes
no trouble
(see <link linkend="sec-data-types-of-semantic-values">Data Types of Semantic Values</link>).
</para>

<para>
The <literal>-p</literal> option works by adding macro definitions to the beginning
of the parser source file, defining <literal>yyparse</literal> as
<literal>prefix parse</literal>, and so on.  This effectively substitutes one
name for the other in the entire parser file.
</para>
</sect1>
-->

</chapter>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-parser-interface">
<title>Parser Interface</title>

<para>
The Ocamlyacc parser is actually Ocaml functions named
after <emphasis>start symbols</emphasis>
(see <link linkend="sec-start-symbol">The Start-Symbol</link>).
Here we
describe the interface conventions of <emphasis>parser functions</emphasis>
and the other
functions that it needs to use.
</para>

<!--
<para>
Keep in mind that the parser uses many Ocaml identifiers starting with
<literal>yy</literal> and <literal>YY</literal> for internal purposes.  If you use such an
identifier (aside from those in this manual) in an action or in additional
C code in the grammar file, you are likely to run into trouble.
</para>
-->

<!-- ************************************************************** -->
<sect1 id="sec-parser-function">
<title>The Parser Function</title>

<para>
To cause parsing to occur, you call the <emphasis>parser function</emphasis>
with two parameters.
The first parameter is the lexical analyzer function of type
</para>

<programlisting role="C">
	Lexing.lexbuf -> token
</programlisting>

<para>
and the second is a value of <literal>Lexing.lexbuf</literal> type.
</para>

<para>
If the start symbol is <literal>parse</literal>
in the file <literal>parser.mly</literal> and
the lexer function is is <literal>token</literal> of the file
<literal>lexer.mll</literal>,
the typical usage is:
</para>

<programlisting role="C">
	let lexbuf = Lexing.from_channel stdin in
	...
	let result = Parser.parse Lexer.token lexbuf in
	...
</programlisting>

<para>
This parser
function reads tokens, executes actions, and ultimately returns when it
encounters end-of-input or an unrecoverable syntax error.
<!--
You can also
write an action which directs <emphasis>parser function</emphasis>
to return immediately without reading further.
-->
</para>

<!--
<para>
The value returned by <literal>yyparse</literal> is 0 if parsing was successful (return
is due to end-of-input).
</para>

<para>
The value is 1 if parsing failed (return is due to a syntax error).
</para>

<para>
In an action, you can cause immediate return from <literal>yyparse</literal> by using
these macros:
</para>

<para>
@table @code
@item YYACCEPT
@findex YYACCEPT
Return immediately with value 0 (to report success).

@item YYABORT
@findex YYABORT
Return immediately with value 1 (to report failure).
@end table
</para>
-->

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-lexical-analyzer-function">
<title>The Lexical Analyzer Function</title>

<para>
The <emphasis>lexical analyzer</emphasis> function,
named after rule declarations, recognizes tokens from
the input stream and returns them to the parser.
 Ocamlyacc does not create
this function automatically; you must write it
so that <emphasis>parser function</emphasis> can
call it.  The function is sometimes referred to as a lexical scanner.
</para>

<!--
<para>
In simple programs, <literal>yylex</literal> is often defined at the end of the Ocamlyacc
grammar file.  If <literal>yylex</literal> is defined in a separate source file, you
need to arrange for the token-type macro definitions to be available there.
To do this, use the <literal>-d</literal> option when you run Ocamlyacc, so that it will
write these macro definitions into a separate header file
<emphasis>name</emphasis><literal>.tab.h</literal> which you can include in the other source files
that need it.
See <link linkend="chap-invoking-ocamlyacc">Invoking Ocamlyacc</link>.
</para>
-->

<para>
This function is usually generated by <literal>ocamllex</literal>.
See <ulink url="http://caml.inria.fr/ocaml/htmlman/manual026.html">Chapter 12 Lexer and parser generators (ocamllex, ocamlyacc)</ulink>.
</para>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-error-reporting-function">
<title>The Error Reporting Function</title>

<para>
The Ocamlyacc parser detects a <literal>parse error</literal> or <literal>syntax error</literal>
whenever it reads a token which cannot satisfy any syntax rule.  An
action in the grammar can also explicitly proclaim an error, using the
<literal>raise Parsing.Parse_error</literal>.
</para>

<para>
The Ocamlyacc parser expects to report the error by calling an error
reporting function named <literal>parse_error</literal>, which is optional.
The default <literal>parse_error</literal> function does nothing and returns.
It is called by the parser function whenever a syntax error is found, and it
receives one argument.  For a parse error, the string is normally
<literal>"syntax error"</literal>.
</para>

<!--
<para>
The parser can detect one other kind of error: stack overflow.  This
happens when the input contains constructions that are very deeply
nested.  It isn't likely you will encounter this, since the Ocamlyacc
parser extends its stack automatically up to a very large limit.  But
if overflow happens, <literal>yyparse</literal> calls <literal>yyerror</literal> in the usual
fashion, except that the argument string is @w{@code{"parser stack
overflow"}}.
</para>
-->

<para>
The following definition suffices in simple programs:
</para>

<programlisting role="C">
let parse_error s = print_endline s
</programlisting>

<para>
After <literal>parse_error</literal> returns to
the <emphasis>parse function</emphasis>, the latter will attempt
error recovery if you have written suitable error recovery grammar rules
(see <link linkend="chap-error-recovery">Error Recovery</link>).
If recovery is impossible, the <emphasis>parse function</emphasis> will
raise <literal>Parsing.Parse_error</literal> exception.
</para>

<!--
<para>
The variable <literal>yynerrs</literal> contains the number of syntax errors
encountered so far.  Normally this variable is global; but if you
request a pure parser (@pxref{Pure Decl, ,A Pure (Reentrant) Parser}) then it is a local variable
which only the actions can access.
</para>
-->

</sect1>

<!-- ************************************************************** -->
<!--
<sect1 id="sec-special-features-for-use-in-actions">
<title>Special Features for Use in Actions</title>

<para>
Here is a table of Ocamlyacc constructs, variables and functions that
are useful in actions.
</para>

<itemizedlist>
<listitem>
  <simpara><literal>$n</literal></simpara>
  <simpara>
  Acts like a variable that contains the semantic value for the
  <emphasis>n</emphasis>th component of the current rule.
  See <link linkend="sec-actions">Actions</link>.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>val Parsing.symbol_start : unit -> int</literal></simpara>
  <simpara>
symbol_start and Parsing.symbol_end are to be called in the action part of a grammar rule only. They return the offset of the string that matches the left-hand side of the rule: symbol_start() returns the offset of the first character; symbol_end() returns the offset after the last character. The first character in a file is at offset 0.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>val Parsing.symbol_end : unit -> int</literal></simpara>
  <simpara>
See Parsing.symbol_start.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>val Parsing.rhs_start : int -> int</literal></simpara>
  <simpara>
Same as Parsing.symbol_start and Parsing.symbol_end, but return the offset of the string matching the nth item on the right-hand side of the rule, where n is the integer parameter to rhs_start and rhs_end. n is 1 for the leftmost item.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>val Parsing.rhs_end : int -> int</literal></simpara>
  <simpara>
See Parsing.rhs_start.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>val Parsing.symbol_start_pos : unit -> Lexing.position</literal></simpara>
  <simpara>
Same as symbol_start, but return a position instead of an offset.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>val Parsing.symbol_end_pos : unit -> Lexing.position</literal></simpara>
  <simpara>
Same as symbol_end, but return a position instead of an offset.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>val Parsing.rhs_start_pos : int -> Lexing.position</literal></simpara>
  <simpara>
Same as rhs_start, but return a position instead of an offset.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>val Parsing.rhs_end_pos : int -> Lexing.position</literal></simpara>
  <simpara>
Same as rhs_end, but return a position instead of an offset.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>val Parsing.clear_parser : unit -> unit</literal></simpara>
  <simpara>
Empty the parser stack. Call it just after a parsing function has returned, to remove all pointers from the parser stack to structures that were built by semantic actions during parsing. This is optional, but lowers the memory requirements of the programs.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>exception Parsing.Parse_error</literal></simpara>
  <simpara>
Raised when a parser encounters a syntax error. Can also be raised from the action part of a grammar rule, to initiate error recovery.
  </simpara>
</listitem>

</itemizedlist>

</sect1>
-->

</chapter>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-parser-algorithm">
<title>The Ocamlyacc Parser Algorithm</title>

<para>
As Ocamlyacc reads tokens, it pushes them onto a stack along with their
semantic values.  The stack is called the <literal>parser stack</literal>.  Pushing a
token is traditionally called <literal>shifting</literal>.
</para>

<para>
For example, suppose the infix calculator has read <literal>1 + 5 *</literal>, with a
<literal>3</literal> to come.  The stack will have four elements, one for each token
that was shifted.
</para>

<para>
But the stack does not always have an element for each token read.  When
the last <emphasis>n</emphasis> tokens and groupings shifted match the components of a
grammar rule, they can be combined according to that rule.  This is called
<literal>reduction</literal>.  Those tokens and groupings are replaced on the stack by a
single grouping whose symbol is the result (left hand side) of that rule.
Running the rule's action is part of the process of reduction, because this
is what computes the semantic value of the resulting grouping.
</para>

<para>
For example, if the infix calculator's parser stack contains this:
</para>

<programlisting role="C">
1 + 5 * 3
</programlisting>

<para>
and the next input token is a newline character, then the last three
elements can be reduced to 15 via the rule:
</para>

<programlisting role="C">
expr: expr MULTIPLY expr;
</programlisting>

<para>
Then the stack contains just these three elements:
</para>

<programlisting role="C">
1 + 15
</programlisting>

<para>
At this point, another reduction can be made, resulting in the single value
16.  Then the newline token can be shifted.
</para>

<para>
The parser tries, by shifts and reductions, to reduce the entire input down
to a single grouping whose symbol is the grammar's start-symbol
(see <link linkend="sec-language-and-grammar">Languages and Context-Free Grammars</link>).
</para>

<para>
This kind of parser is known in the literature as a bottom-up parser.


</para>

<!-- ************************************************************** -->
<sect1 id="sec-look-ahead-tokens">
<title>Look-Ahead Tokens</title>

<para>
The Ocamlyacc parser does <emphasis>not</emphasis> always reduce immediately as soon as the
last <emphasis>n</emphasis> tokens and groupings match a rule.  This is because such a
simple strategy is inadequate to handle most languages.  Instead, when a
reduction is possible, the parser sometimes ``looks ahead'' at the next
token in order to decide what to do.
</para>

<para>
When a token is read, it is not immediately shifted; first it becomes the
<literal>look-ahead token</literal>, which is not on the stack.  Now the parser can
perform one or more reductions of tokens and groupings on the stack, while
the look-ahead token remains off to the side.  When no more reductions
should take place, the look-ahead token is shifted onto the stack.  This
does not mean that all possible reductions have been done; depending on the
token type of the look-ahead token, some rules may choose to delay their
application.
</para>

<para>
Here is a simple case where look-ahead is needed.  These three rules define
expressions which contain binary addition operators and postfix unary
factorial operators (<literal>FACTORIAL</literal> for '!'),
and allow parentheses for grouping.
</para>

<programlisting role="C">
expr:     term PLUS expr
        | term
        ;

term:     LPAREN expr RPAREN
        | term FACTORIAL 
        | NUMBER
        ;
</programlisting>

<para>
Suppose that the tokens <literal>1 + 2</literal> have been read and shifted;
what should be done?  If the following token is <literal>RPAREN</literal>,
then the first three tokens must be reduced to form an <literal>expr</literal>.
This is the only valid
course, because shifting
the <literal>RPAREN</literal> would produce a sequence of symbols
<literal>term RPAREN</literal>, and no rule allows this.
</para>

<para>
If the following token is <literal>FACTORIAL</literal>, that is '!',
then it must be shifted immediately so
that <literal>2 !</literal> can be reduced to make a
<literal>term</literal>.
If instead the
parser were to reduce before shifting,
<literal>1 + 2</literal> would become an
<literal>expr</literal>.
It would then be impossible to shift the <literal>!</literal> because
doing so would produce on the stack the sequence of symbols
<literal>expr FACTORIAL</literal>.
No rule allows that sequence.
</para>

<!--
<para>
The current look-ahead token is stored in the variable <literal>yychar</literal>.
See <link linkend="sec-special-features-for-use-in-actions">Special Features for Use in Actions</link>.
</para>
-->

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-shift-reduce-conflicts">
<title>Shift/Reduce Conflicts</title>

<para>
Suppose we are parsing a language which has if-then and if-then-else
statements, with a pair of rules like this:
</para>

<programlisting role="C">
if_stmt:
          IF expr THEN stmt
        | IF expr THEN stmt ELSE stmt
        ;
</programlisting>

<para>
Here we assume that <literal>IF</literal>, <literal>THEN</literal> and <literal>ELSE</literal> are
terminal symbols for specific keyword tokens.
</para>

<para>
When the <literal>ELSE</literal> token is read and becomes the look-ahead token, the
contents of the stack (assuming the input is valid) are just right for
reduction by the first rule.  But it is also legitimate to shift the
<literal>ELSE</literal>, because that would lead to eventual reduction by the second
rule.
</para>

<para>
This situation, where either a shift or a reduction would be valid, is
called a <literal>shift/reduce conflict</literal>.  Ocamlyacc is designed to resolve
these conflicts by choosing to shift, unless otherwise directed by
operator precedence declarations.  To see the reason for this, let's
contrast it with the other alternative.
</para>

<para>
Since the parser prefers to shift the <literal>ELSE</literal>, the result is to attach
the else-clause to the innermost if-statement, making these two inputs
equivalent:
</para>

<programlisting role="C">
if x then if y then win (); else lose;

if x then do; if y then win (); else lose; end;
</programlisting>

<para>
But if the parser chose to reduce when possible rather than shift, the
result would be to attach the else-clause to the outermost if-statement,
making these two inputs equivalent:
</para>

<programlisting role="C">
if x then if y then win (); else lose;

if x then do; if y then win (); end; else lose;
</programlisting>

<para>
The conflict exists because the grammar as written is ambiguous: either
parsing of the simple nested if-statement is legitimate.  The established
convention is that these ambiguities are resolved by attaching the
else-clause to the innermost if-statement; this is what Ocamlyacc accomplishes
by choosing to shift rather than reduce.  (It would ideally be cleaner to
write an unambiguous grammar, but that is very hard to do in this case.)
This particular ambiguity was first encountered in the specifications of
Algol 60 and is called the ``dangling <literal>else</literal>'' ambiguity.
</para>

<!--
<para>
To avoid warnings from Ocamlyacc about predictable, legitimate shift/reduce
conflicts, use the <literal>%expect n</literal> declaration.  There will be no
warning as long as the number of shift/reduce conflicts is exactly <emphasis>n</emphasis>.
@xref{Expect Decl, ,Suppressing Conflict Warnings}.
</para>
-->

<para>
The definition of <literal>if_stmt</literal> above is solely to blame for the
conflict, but the conflict does not actually appear without additional
rules.  Here is a complete Ocamlyacc input file that actually manifests the
conflict:
</para>

<programlisting role="C">
%token IF THEN ELSE variable
%%
stmt:     expr
        | if_stmt
        ;

if_stmt:
          IF expr THEN stmt
        | IF expr THEN stmt ELSE stmt
        ;

expr:     variable
        ;
</programlisting>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-operator-precedence">
<title>Operator Precedence</title>

<para>
Another situation where shift/reduce conflicts appear is in arithmetic
expressions.  Here shifting is not always the preferred resolution; the
Ocamlyacc declarations for operator precedence allow you to specify when to
shift and when to reduce.

</para>

<!-- ************************************************************** -->
<sect2 id="sec-when-precedence-is-needed">
<title>When Precedence is Needed</title>

<para>
Consider the following ambiguous grammar fragment (ambiguous because the
input <literal>1 - 2 * 3</literal> can be parsed in two different ways):
</para>

<programlisting role="C">
expr:     expr MINUS expr
        | expr MULTIPLY expr
        | expr LT expr
        | LPAREN expr RPAREN 
        ...
        ;
</programlisting>

<para>
Suppose the parser has seen the tokens <literal>1</literal>, <literal>-</literal> and <literal>2</literal>;
should it reduce them via the rule for the subtraction operator?  It
depends on the next token.  Of course, if the next token is <literal>)</literal>, we
must reduce; shifting is invalid because no single rule can reduce the
token sequence <literal>- 2 )</literal> or anything starting with that.  But if
the next token is <literal>*</literal> or <literal>**</literal>, we have a choice: either
shifting or reduction would allow the parse to complete, but with
different results.
</para>

<para>
To decide which one Ocamlyacc should do, we must consider the results.  If
the next operator token <emphasis>op</emphasis> is shifted, then it must be reduced
first in order to permit another opportunity to reduce the difference.
The result is (in effect) <literal>1 - (2 op 3)</literal>.  On the other
hand, if the subtraction is reduced before shifting <emphasis>op</emphasis>, the result
is <literal>(1 - 2) op 3</literal>.  Clearly, then, the choice of shift or
reduce should depend on the relative precedence of the operators
<literal>-</literal> and <emphasis>op</emphasis>: <literal>*</literal> should be shifted first, but not
<literal>**</literal>.
</para>

<para>
What about input such as <literal>1 - 2 - 5</literal>; should this be
<literal>(1 - 2) - 5</literal> or should it be <literal>1 - (2 - 5)</literal>?  For most
operators we prefer the former, which is called <literal>left association</literal>.
The latter alternative, <literal>right association</literal>, is desirable for
assignment operators.  The choice of left or right association is a
matter of whether the parser chooses to shift or reduce when the stack
contains <literal>1 - 2</literal> and the look-ahead token is <literal>-</literal>: shifting
makes right-associativity.
</para>
</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-specifying-operator-precedence">
<title>Specifying Operator Precedence</title>

<para>
Ocamlyacc allows you to specify these choices with the operator precedence
declarations <literal>%left</literal> and <literal>%right</literal>.  Each such declaration
contains a list of tokens, which are operators whose precedence and
associativity is being declared.  The <literal>%left</literal> declaration makes all
those operators left-associative and the <literal>%right</literal> declaration makes
them right-associative.  A third alternative is <literal>%nonassoc</literal>, which
declares that it is a syntax error to find the same operator twice ``in a
row''.
</para>

<para>
The relative precedence of different operators is controlled by the
order in which they are declared.  The first <literal>%left</literal> or
<literal>%right</literal> declaration in the file declares the operators whose
precedence is lowest, the next such declaration declares the operators
whose precedence is a little higher, and so on.
</para>
</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-precedence-examples">
<title>Precedence Examples</title>

<para>
In our example, we would want the following declarations:
</para>

<programlisting role="C">
%left LT
%left MINUS
%left MULTIPLY
</programlisting>

<para>
In a more complete example, which supports other operators as well, we
would declare them in groups of equal precedence.  For example, <literal>'+'</literal> is
declared with <literal>'-'</literal>:
</para>

<programlisting role="C">
%left LT GT EQ NE LE GE
%left PLUS MINUS
%left MULTIPLY DIVIDE
</programlisting>

<para>
(Here <literal>NE</literal> and so on stand for the operators for ``not equal''
and so on.  We assume that these tokens are more than one character long
and therefore are represented by names, not character literals.)
</para>
</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-how-precedence-works">
<title>How Precedence Works</title>

<para>
The first effect of the precedence declarations is to assign precedence
levels to the terminal symbols declared.  The second effect is to assign
precedence levels to certain rules: each rule gets its precedence from the
last terminal symbol mentioned in the components.  (You can also specify
explicitly the precedence of a rule.
See <link linkend="sec-context-dependent-precedence">Context-Dependent Precedence</link>.)
</para>

<para>
Finally, the resolution of conflicts works by comparing the
precedence of the rule being considered with that of the
look-ahead token.  If the token's precedence is higher, the
choice is to shift.  If the rule's precedence is higher, the
choice is to reduce.  If they have equal precedence, the choice
is made based on the associativity of that precedence level.  The
verbose output file made by <literal>-v</literal>
(see <link linkend="chap-invoking-ocamlyacc">Invoking Ocamlyacc</link>)
says
how each conflict was resolved.
</para>

<para>
Not all rules and not all tokens have precedence.  If either the rule or
the look-ahead token has no precedence, then the default is to shift.
</para>
</sect2>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-context-dependent-precedence">
<title>Context-Dependent Precedence</title>

<para>
Often the precedence of an operator depends on the context.  This sounds
outlandish at first, but it is really very common.  For example, a minus
sign typically has a very high precedence as a unary operator, and a
somewhat lower precedence (lower than multiplication) as a binary operator.
</para>

<para>
The Ocamlyacc precedence declarations, <literal>%left</literal>, <literal>%right</literal> and
<literal>%nonassoc</literal>, can only be used once for a given token; so a token has
only one precedence declared in this way.  For context-dependent
precedence, you need to use an additional mechanism: the <literal>%prec</literal>
modifier for rules.
</para>

<para>
The <literal>%prec</literal> modifier declares the precedence of a particular rule by
specifying a terminal symbol whose precedence should be used for that rule.
It's not necessary for that symbol to appear otherwise in the rule.  The
modifier's syntax is:
</para>

<programlisting role="C">
%prec <emphasis>terminal-symbol</emphasis>
</programlisting>

<para>
and it is written after the components of the rule.  Its effect is to
assign the rule the precedence of <emphasis>terminal-symbol</emphasis>, overriding
the precedence that would be deduced for it in the ordinary way.  The
altered rule precedence then affects how conflicts involving that rule
are resolved
(see <link linkend="sec-operator-precedence">Operator Precedence</link>).
</para>

<para>
Here is how <literal>%prec</literal> solves the problem of unary minus.  First, declare
a precedence for a fictitious terminal symbol named <literal>UMINUS</literal>.  There
are no tokens of this type, but the symbol serves to stand for its
precedence:
</para>

<programlisting role="C">
...
%left PLUS MINUS
%left MULTIPLY
%left UMINUS
</programlisting>

<para>
Now the precedence of <literal>UMINUS</literal> can be used in specific rules:
</para>

<programlisting role="C">
exp:    ...
        | exp MINUS exp
        ...
        | MINUS exp %prec UMINUS
</programlisting>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-parser-states">
<title>Parser States</title>

<para>
The function <literal>yyparse</literal> is implemented using a finite-state machine.
The values pushed on the parser stack are not simply token type codes; they
represent the entire sequence of terminal and nonterminal symbols at or
near the top of the stack.  The current state collects all the information
about previous input which is relevant to deciding what to do next.
</para>

<para>
Each time a look-ahead token is read, the current parser state together
with the type of look-ahead token are looked up in a table.  This table
entry can say, ``Shift the look-ahead token.''  In this case, it also
specifies the new parser state, which is pushed onto the top of the
parser stack.  Or it can say, ``Reduce using rule number <emphasis>n</emphasis>.''
This means that a certain number of tokens or groupings are taken off
the top of the stack, and replaced by one grouping.  In other words,
that number of states are popped from the stack, and one new state is
pushed.
</para>

<para>
There is one other alternative: the table can say that the look-ahead token
is erroneous in the current state.  This causes error processing to begin
(see <link linkend="chap-error-recovery">Error Recovery</link>).
</para>
</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-reduce-reduce-conflicts">
<title>Reduce/Reduce Conflicts</title>

<para>
A reduce/reduce conflict occurs if there are two or more rules that apply
to the same sequence of input.  This usually indicates a serious error
in the grammar.
</para>

<para>
For example, here is an erroneous attempt to define a sequence
of zero or more <literal>word</literal> groupings.
</para>

<programlisting role="C">
sequence: /* empty */	{ printf "empty sequence\n" }
        | maybeword	{}
        | sequence word	{ printf "added word %s\n" $2 }
        ;

maybeword: /* empty */	{ printf "empty maybeword\n" }
        | word		{ printf "single word %s\n" $1 }
        ;
</programlisting>

<para>
The error is an ambiguity: there is more than one way to parse a single
<literal>word</literal> into a <literal>sequence</literal>.  It could be reduced to a
<literal>maybeword</literal> and then into a <literal>sequence</literal> via the second rule.
Alternatively, nothing-at-all could be reduced into a <literal>sequence</literal>
via the first rule, and this could be combined with the <literal>word</literal>
using the third rule for <literal>sequence</literal>.
</para>

<para>
There is also more than one way to reduce nothing-at-all into a
<literal>sequence</literal>.  This can be done directly via the first rule,
or indirectly via <literal>maybeword</literal> and then the second rule.
</para>

<para>
You might think that this is a distinction without a difference, because it
does not change whether any particular input is valid or not.  But it does
affect which actions are run.  One parsing order runs the second rule's
action; the other runs the first rule's action and the third rule's action.
In this example, the output of the program changes.
</para>

<para>
Ocamlyacc resolves a reduce/reduce conflict by choosing to use the rule that
appears first in the grammar, but it is very risky to rely on this.  Every
reduce/reduce conflict must be studied and usually eliminated.  Here is the
proper way to define <literal>sequence</literal>:
</para>

<programlisting role="C">
sequence: /* empty */	{ printf "empty sequence\n" }
        | sequence word 	{ printf "added word %s\n" $2 }
        ;
</programlisting>

<para>
Here is another common error that yields a reduce/reduce conflict:
</para>

<programlisting role="C">
sequence: /* empty */
        | sequence words
        | sequence redirects
        ;

words:    /* empty */
        | words word
        ;

redirects:/* empty */
        | redirects redirect
        ;
</programlisting>

<para>
The intention here is to define a sequence which can contain either
<literal>word</literal> or <literal>redirect</literal> groupings.  The individual definitions of
<literal>sequence</literal>, <literal>words</literal> and <literal>redirects</literal> are error-free, but the
three together make a subtle ambiguity: even an empty input can be parsed
in infinitely many ways!
</para>

<para>
Consider: nothing-at-all could be a <literal>words</literal>.  Or it could be two
<literal>words</literal> in a row, or three, or any number.  It could equally well be a
<literal>redirects</literal>, or two, or any number.  Or it could be a <literal>words</literal>
followed by three <literal>redirects</literal> and another <literal>words</literal>.  And so on.
</para>

<para>
Here are two ways to correct these rules.  First, to make it a single level
of sequence:
</para>

<programlisting role="C">
sequence: /* empty */
        | sequence word
        | sequence redirect
        ;
</programlisting>

<para>
Second, to prevent either a <literal>words</literal> or a <literal>redirects</literal>
from being empty:
</para>

<programlisting role="C">
sequence: /* empty */
        | sequence words
        | sequence redirects
        ;

words:    word
        | words word
        ;

redirects:redirect
        | redirects redirect
        ;
</programlisting>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-mysterious-reduce-reduce-conflicts">
<title>Mysterious Reduce/Reduce Conflicts</title>

<para>
Sometimes reduce/reduce conflicts can occur that don't look warranted.
Here is an example:
</para>

<programlisting role="C">
%token ID COMMA COLON

%%
def:    param_spec return_spec COMMA
        ;
param_spec:
             type
        |    name_list COLON type
        ;
return_spec:
             type
        |    name COLON type
        ;
type:        ID
        ;
name:        ID
        ;
name_list:
             name
        |    name COMMA name_list
        ;
</programlisting>

<para>
It would seem that this grammar can be parsed with only a single token
of look-ahead: when a <literal>param_spec</literal> is being read, an <literal>ID</literal> is
a <literal>name</literal> if a comma or colon follows, or a <literal>type</literal> if another
<literal>ID</literal> follows.  In other words, this grammar is LR(1).
</para>

<para>
However, Ocamlyacc, like most parser generators, cannot actually handle all
LR(1) grammars.  In this grammar, two contexts, that after an <literal>ID</literal>
at the beginning of a <literal>param_spec</literal> and likewise at the beginning of
a <literal>return_spec</literal>, are similar enough that Ocamlyacc assumes they are the
same.  They appear similar because the same set of rules would be
active---the rule for reducing to a <literal>name</literal> and that for reducing to
a <literal>type</literal>.  Ocamlyacc is unable to determine at that stage of processing
that the rules would require different look-ahead tokens in the two
contexts, so it makes a single parser state for them both.  Combining
the two contexts causes a conflict later.  In parser terminology, this
occurrence means that the grammar is not LALR(1).
</para>

<para>
In general, it is better to fix deficiencies than to document them.  But
this particular deficiency is intrinsically hard to fix; parser
generators that can handle LR(1) grammars are hard to write and tend to
produce parsers that are very large.  In practice, Ocamlyacc is more useful
as it is now.
</para>

<para>
When the problem arises, you can often fix it by identifying the two
parser states that are being confused, and adding something to make them
look distinct.  In the above example, adding one rule to
<literal>return_spec</literal> as follows makes the problem go away:
</para>

<programlisting role="C">
%token BOGUS
...
%%
...
return_spec:
             type
        |    name COMMA type
        /* This rule is never used.  */
        |    ID BOGUS
        ;
</programlisting>

<para>
This corrects the problem because it introduces the possibility of an
additional active rule in the context after the <literal>ID</literal> at the beginning of
<literal>return_spec</literal>.  This rule is not active in the corresponding context
in a <literal>param_spec</literal>, so the two contexts receive distinct parser states.
As long as the token <literal>BOGUS</literal> is never generated by <literal>yylex</literal>,
the added rule cannot alter the way actual input is parsed.
</para>

<para>
In this particular example, there is another way to solve the problem:
rewrite the rule for <literal>return_spec</literal> to use <literal>ID</literal> directly
instead of via <literal>name</literal>.  This also causes the two confusing
contexts to have different sets of active rules, because the one for
<literal>return_spec</literal> activates the altered rule for <literal>return_spec</literal>
rather than the one for <literal>name</literal>.
</para>

<programlisting role="C">
param_spec:
             type
        |    name_list COMMA type
        ;
return_spec:
             type
        |    ID COMMA type
        ;
</programlisting>

</sect1>

<!-- ************************************************************** -->
<!--
<sect1 id="sec-stack-overflow">
<title>Stack Overflow, and How to Avoid It</title>

<para>
</para>
</sect1>
-->

</chapter>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-error-recovery">
<title>Error Recovery</title>

<para>
It is not usually acceptable to have a program terminate on a parse
error.  For example, a compiler should recover sufficiently to parse the
rest of the input file and check it for errors; a calculator should accept
another expression.
</para>

<para>
In a simple interactive command parser where each input is one line, it may
be sufficient to have the caller catch the exception and ignore the rest of the input line when that happens (and then call
<emphasis>parse function</emphasis> again).
But this is inadequate for a compiler, because it
forgets all the syntactic context leading up to the error.  A syntax error
deep within a function in the compiler input should not cause the compiler
to treat the following line like the beginning of a source file.
</para>

<para>
You can define how to recover from a syntax error by writing rules to
recognize the special token <literal>error</literal>.
This is a terminal symbol that
is reserved for error
handling.
The Ocamlyacc parser generates an <literal>error</literal> token whenever a
syntax error happens; if you have provided a rule to recognize this token
in the current context, the parse can continue.
</para>

<para>
For example:
</para>

<programlisting role="C">
stmnts:  /* empty string */		{}
        | stmnts NEWLINE		{}
        | stmnts exp NEWLINE	{}
        | stmnts error NEWLINE	{}
</programlisting>

<para>
The fourth rule in this example says that an error followed by a newline
makes a valid addition to any <literal>stmnts</literal>.
</para>

<para>
What happens if a syntax error occurs in the middle of an <literal>exp</literal>?
The error recovery rule, interpreted strictly, applies to the precise sequence
of a <literal>stmnts</literal>, an <literal>error</literal> and a newline.
If an error occurs in the middle of an <literal>exp</literal>,
there will probably be some additional tokens
and subexpressions on the stack after the last <literal>stmnts</literal>,
and there
will be tokens to read before the next newline.  So the rule is not
applicable in the ordinary way.
</para>

<para>
But Ocamlyacc can force the situation to fit the rule, by discarding part of
the semantic context and part of the input.  First it discards states and
objects from the stack until it gets back to a state in which the
<literal>error</literal> token is acceptable.
(This means that the subexpressions
already parsed are discarded, back to the last complete
<literal>stmnts</literal>.)  At
this point the <literal>error</literal> token can be shifted.  Then, if the old
look-ahead token is not acceptable to be shifted next, the parser reads
tokens and discards them until it finds a token which is acceptable.  In
this example, Ocamlyacc reads and discards input until the next newline
so that the fourth rule can apply.
</para>

<para>
The choice of error rules in the grammar is a choice of strategies for
error recovery.  A simple and useful strategy is simply to skip the rest of
the current input line or current statement if an error is detected:
</para>

<programlisting role="C">
stmnt: error SEMICOLON	{}	/* on error, skip until SEMICOLON is read */
</programlisting>

<para>
It is also useful to recover to the matching close-delimiter of an
opening-delimiter that has already been parsed.  Otherwise the
close-delimiter will probably appear to be unmatched, and generate another,
spurious error message:
</para>

<programlisting role="C">
primary:  LPAREN expr RPAREN	{}
        | LPAREN error RPAREN	{}
        ...
        ;
</programlisting>

<para>
Error recovery strategies are necessarily guesses.  When they guess wrong,
one syntax error often leads to another.  In the above example, the error
recovery rule guesses that an error is due to bad input within one
<literal>stmnt</literal>. 
Suppose that instead a spurious semicolon is inserted in the
middle of a valid <literal>stmnt</literal>. 
After the error recovery rule recovers
from the first error, another syntax error will be found straightaway,
since the text following the spurious semicolon is also an invalid
<literal>stmnt</literal>.
</para>

<para>
To prevent an outpouring of error messages, the parser will output no error
message for another syntax error that happens shortly after the first; only
after three consecutive input tokens have been successfully shifted will
error messages resume.
</para>

</chapter>


<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-debuging-your-parser">
<title>Debugging Your Parser</title>

<para>
To debug the parser generated by <emphasis>ocamlyacc</emphasis>:
</para>

<itemizedlist>
<listitem>
  <simpara>
  Generate parsing infomation
  in the file <emphasis>grammar</emphasis><literal>.output</literal>
  using <emphasis>-v</emphasis> option
  (like "<emphasis>ocamlyacc -v filneme.mly</emphasis>"):
  the information consists of the parsing table and a report on conflicts.
  </simpara>
</listitem>

<listitem>
  <simpara>
  Set <emphasis>p</emphasis> option of the OCAMLRUNPARAM environment variable:
  for example, execute "<emphasis>export OCAMLRUNPARAM='p'</emphasis> "
  on bash shell.
  </simpara>
</listitem>

</itemizedlist>

<para>
The parser prints messages about its actions such as shifting a token,
reducing a rule.
</para>

<para>
You can find rule numbers and state numbers mentioned in the messages
at the file <emphasis>grammar</emphasis><literal>.output</literal>.
</para>

</chapter>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-invoking-ocamlyacc">
<title>Invoking Ocamlyacc</title>

<para>
The usual way to invoke Bison is as follows:
</para>

<programlisting role="C">
	ocamlyacc <emphasis>filename</emphasis>.mly
</programlisting>

<para>
Here <emphasis>filename</emphasis><literal>.mly</literal> is the grammar file name.
The parser file's name is made by replacing the <literal>.mly</literal>
with <literal>.ml</literal>.  Thus, the "<literal>ocamlyacc foo.mly</literal>"
yields <literal>foo.ml</literal>.
</para>

<!-- ************************************************************** -->
<sect1 id="sec-ocamlyacc-options">
<title>Ocamlyacc Options</title>

<para>
Here is a list of options that can be used with Ocamlyacc:
</para>

<itemizedlist>
<listitem>
  <simpara>-v</simpara>
  <simpara>
  By default, this option generates
  a file <emphasis>grammar</emphasis><literal>.output</literal>.
  It contains parsing infomation such as
  a description of the parsing tables and a report
  on ambiguities in the grammar.
  </simpara>
</listitem>

<listitem>
  <simpara>-b<emphasis>fname</emphasis></simpara>
  <simpara>
  Change the name of the output files
  to <emphasis>fname</emphasis><literal>.ml</literal>,
  <emphasis>fname</emphasis><literal>.mli</literal> and
  <emphasis>fname</emphasis><literal>.output</literal>.
  </simpara>
</listitem>

</itemizedlist>

</sect1>

</chapter>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-license">
<title>License of This Document</title>

<remark>
All license term in this document is NOT
related with ocamlyacc; it is ONLY for this document.
</remark>

<!-- ************************************************************** -->
<sect1 id="sec-bison-license">
<title>Bison License</title>

<para>
The <ulink url="http://www.gnu.org/software/bison/manual/">bison manual</ulink>
requires "GNU General Public License" and "GNU Free Documentation License".
</para>


<!-- ************************************************************** -->
<sect2 id="sec-license-bison-manual">
<title>License of bison manual</title>

<para>
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1995, 1998, 1999,
2000, 2001 Free Software Foundation, Inc.
</para>

<para>
   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
</para>

<para>
   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License" and "Conditions
for Using Bison" are included exactly as in the original, and provided
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.
</para>

<para>
   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License", "Conditions for Using Bison" and this permission notice may be
included in translations approved by the Free Software Foundation
instead of in the original English.
</para>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-condition-for-using-bison">
<title>Conditions for Using Bison</title>

<para>
As of Bison version 1.24, we have changed the distribution terms for yyparse to permit using Bison's output in nonfree programs. Formerly, Bison parsers could be used only in programs that were free software. 
</para>

<para>
The other GNU programming tools, such as the GNU C compiler, have never had such a requirement. They could always be used for nonfree software. The reason Bison was different was not due to a special policy decision; it resulted from applying the usual General Public License to all of the Bison source code. 
</para>

<para>
The output of the Bison utility--the Bison parser file--contains a verbatim copy of a sizable piece of Bison, which is the code for the yyparse function. (The actions from your grammar are inserted into this function at one point, but the rest of the function is not changed.) When we applied the GPL terms to the code for yyparse, the effect was to restrict the use of Bison output to free software. 
</para>

<para>
We didn't change the terms because of sympathy for people who want to make software proprietary. Software should be free. But we concluded that limiting Bison's use to free software was doing little to encourage people to make other software free. So we decided to make the practical conditions for using Bison match the practical conditions for using the other GNU tools. 
</para>

</sect2>

<!-- ************************************************************** -->
<sect2 id="sec-copying-this-manual">
<title>Copying This Manual</title>

<para>
<link linkend="gfdl">GNU Free Documentation License</link>: License for copying bison manual.
</para>

<sect3 id="gfdl">
<title>GNU Free Documentation License</title>

<para>
Copyright  2000 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
</para>

<para>
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</para>

<simplesect id="gfdl-0"><title>PREAMBLE</title>

<para>The purpose of this License is to make a manual, textbook, or
other functional and useful document "free" in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it, with
or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible for
modifications made by others.</para>

<para>This License is a kind of "copyleft", which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft license
designed for free software.</para>

<para>We have designed this License in order to use it for manuals for
free software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals; it
can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.</para>

</simplesect>

<simplesect id="gfdl-1"><title>APPLICABILITY AND DEFINITIONS</title>

<para id="gfdl-doc">This License applies to any manual or other work, in
any medium, that contains a notice placed by the copyright holder saying
it can be distributed under the terms of this License.  Such a notice
grants a world-wide, royalty-free license, unlimited in duration, to use
that work under the conditions stated herein.  The "Document", below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as "you".  You accept the license if you
copy, modify or distribute the work in a way requiring permission under
copyright law.</para>

<para id="gfdl-mod-ver">A "Modified Version" of the Document means any
work containing the Document or a portion of it, either copied verbatim,
or with modifications and/or translated into another language.</para>

<para id="gfdl-secnd-sect">A "Secondary Section" is a named appendix or
a front-matter section of the Document that deals exclusively with the
relationship of the publishers or authors of the Document to the
Document's overall subject (or to related matters) and contains nothing
that could fall directly within that overall subject.  (Thus, if the
Document is in part a textbook of mathematics, a Secondary Section may
not explain any mathematics.)  The relationship could be a matter of
historical connection with the subject or with related matters, or of
legal, commercial, philosophical, ethical or political position
regarding them.</para>

<para id="gfdl-inv-sect">The "Invariant Sections" are certain Secondary
Sections whose titles are designated, as being those of Invariant
Sections, in the notice that says that the Document is released under
this License.  If a section does not fit the above definition of
Secondary then it is not allowed to be designated as Invariant.  The
Document may contain zero Invariant Sections.  If the Document does not
identify any Invariant Sections then there are none.</para>

<para id="gfdl-cov-text">The "Cover Texts" are certain short passages of
text that are listed, as Front-Cover Texts or Back-Cover Texts, in the
notice that says that the Document is released under this License.  A
Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at
most 25 words.</para>

<para id="gfdl-transparent">A "Transparent" copy of the Document means a
machine-readable copy, represented in a format whose specification is
available to the general public, that is suitable for revising the
document straightforwardly with generic text editors or (for images
composed of pixels) generic paint programs or (for drawings) some widely
available drawing editor, and that is suitable for input to text
formatters or for automatic translation to a variety of formats suitable
for input to text formatters.  A copy made in an otherwise Transparent
file format whose markup, or absence of markup, has been arranged to
thwart or discourage subsequent modification by readers is not
Transparent.  An image format is not Transparent if used for any
substantial amount of text.  A copy that is not "Transparent" is called
"Opaque".</para>

<para>Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input format, SGML or
XML using a publicly available DTD, and standard-conforming simple HTML,
PostScript or PDF designed for human modification.  Examples of
transparent image formats include PNG, XCF and JPG.  Opaque formats
include proprietary formats that can be read and edited only by
proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the machine-generated
HTML, PostScript or PDF produced by some word processors for output
purposes only.</para>

<para id="gfdl-title-page">The "Title Page" means, for a printed book,
the title page itself, plus such following pages as are needed to hold,
legibly, the material this License requires to appear in the title page.
For works in formats which do not have any title page as such, "Title
Page" means the text near the most prominent appearance of the work's
title, preceding the beginning of the body of the text.</para>

<para id="gfdl-entitled">A section "Entitled XYZ" means a named subunit
of the Document whose title either is precisely XYZ or contains XYZ in
parentheses following text that translates XYZ in another language.
(Here XYZ stands for a specific section name mentioned below, such as
"Acknowledgements", "Dedications", "Endorsements", or "History".)  To
"Preserve the Title" of such a section when you modify the Document
means that it remains a section "Entitled XYZ" according to this
definition.</para>

<para>The Document may include Warranty Disclaimers next to the notice
which states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this License,
but only as regards disclaiming warranties: any other implication that
these Warranty Disclaimers may have is void and has no effect on the
meaning of this License.</para>
</simplesect>

<simplesect id="gfdl-2"><title>VERBATIM COPYING</title>

<para>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies to
the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further copying
of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.
</para>

<para>You may also lend copies, under the same conditions stated above,
and you may publicly display copies.</para>
</simplesect>

<simplesect id="gfdl-3"><title>COPYING IN QUANTITY</title>

<para>If you publish printed copies (or copies in media that commonly
have printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover Texts:
Front-Cover Texts on the front cover, and Back-Cover Texts on the back
cover.  Both covers must also clearly and legibly identify you as the
publisher of these copies.  The front cover must present the full title
with all words of the title equally prominent and visible.  You may add
other material on the covers in addition.  Copying with changes limited
to the covers, as long as they preserve the title of the Document and
satisfy these conditions, can be treated as verbatim copying in other
respects.</para>

<para>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.</para>

<para>If you publish or distribute Opaque copies of the Document
numbering more than 100, you must either include a machine-readable
Transparent copy along with each Opaque copy, or state in or with each
Opaque copy a computer-network location from which the general
network-using public has access to download using public-standard
network protocols a complete Transparent copy of the Document, free of
added material.  If you use the latter option, you must take reasonably
prudent steps, when you begin distribution of Opaque copies in quantity,
to ensure that this Transparent copy will remain thus accessible at the
stated location until at least one year after the last time you
distribute an Opaque copy (directly or through your agents or retailers)
of that edition to the public.</para>

<para>It is requested, but not required, that you contact the authors of
the Document well before redistributing any large number of copies, to
give them a chance to provide you with an updated version of the
Document.</para>
</simplesect>

<simplesect id="gfdl-4"><title>MODIFICATIONS</title>

<para>You may copy and distribute a Modified Version of the Document
under the conditions of sections 2 and 3 above, provided that you
release the Modified Version under precisely this License, with the
Modified Version filling the role of the Document, thus licensing
distribution and modification of the Modified Version to whoever
possesses a copy of it.  In addition, you must do these things in the
Modified Version:</para>

<orderedlist id="gfdl-modif-cond" numeration="upperalpha">
  <title>GNU FDL Modification Conditions</title>
<listitem><simpara>Use in the Title Page (and on the covers, if any) a
  title distinct from that of the Document, and from those of previous
  versions (which should, if there were any, be listed in the History
  section of the Document).  You may use the same title as a previous
  version if the original publisher of that version gives permission.
</simpara></listitem>
<listitem><simpara>List on the Title Page, as authors, one or more
  persons or entities responsible for authorship of the modifications in
  the Modified Version, together with at least five of the principal
  authors of the Document (all of its principal authors, if it has fewer
  than five), unless they release you from this requirement.
</simpara></listitem>
<listitem><simpara>State on the Title page the name of the publisher of
  the Modified Version, as the publisher.</simpara></listitem>
<listitem><simpara>Preserve all the copyright notices of the Document.
</simpara></listitem>
<listitem><simpara>Add an appropriate copyright notice for your
  modifications adjacent to the other copyright notices.
</simpara></listitem>
<listitem><simpara>Include, immediately after the copyright notices, a
  license notice giving the public permission to use the Modified
  Version under the terms of this License, in the form shown in the
  <link linkend="gfdl-addendum">Addendum</link> below.
</simpara></listitem>
<listitem><simpara>Preserve in that license notice the full lists of
  Invariant Sections and required Cover Texts given in the Document's
  license notice.</simpara></listitem>
<listitem><simpara>Include an unaltered copy of this License.
</simpara></listitem>
<listitem><simpara>Preserve the section Entitled "History", Preserve its
  Title, and add to it an item stating at least the title, year, new
  authors, and publisher of the Modified Version as given on the Title
  Page.  If there is no section Entitled "History" in the Document,
  create one stating the title, year, authors, and publisher of the
  Document as given on its Title Page, then add an item describing the
  Modified Version as stated in the previous sentence.
</simpara></listitem>
<listitem><simpara>Preserve the network location, if any, given in the
  Document for public access to a Transparent copy of the Document, and
  likewise the network locations given in the Document for previous
  versions it was based on.  These may be placed in the "History"
  section.  You may omit a network location for a work that was
  published at least four years before the Document itself, or if the
  original publisher of the version it refers to gives permission.
</simpara></listitem>
<listitem><simpara>For any section Entitled "Acknowledgements" or
  "Dedications", Preserve the Title of the section, and preserve in the
  section all the substance and tone of each of the contributor
  acknowledgements and/or dedications given therein.
</simpara></listitem>
<listitem><simpara>Preserve all the Invariant Sections of the Document,
  unaltered in their text and in their titles.  Section numbers or the
  equivalent are not considered part of the section titles.
</simpara></listitem>
<listitem><simpara>Delete any section Entitled "Endorsements".
  Such a section may not be included in the Modified Version.
</simpara></listitem>
<listitem><simpara>Do not retitle any existing section to be Entitled
  "Endorsements" or to conflict in title with any Invariant Section.
</simpara></listitem>
<listitem><simpara>Preserve any Warranty Disclaimers.
</simpara></listitem>
</orderedlist>

<para>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.</para>

<para>You may add a section Entitled "Endorsements", provided it
contains nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.</para>

<para>You may add a passage of up to five words as a Front-Cover Text,
and a passage of up to 25 words as a Back-Cover Text, to the end of the
list of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or through
arrangements made by) any one entity.  If the Document already includes
a cover text for the same cover, previously added by you or by
arrangement made by the same entity you are acting on behalf of, you may
not add another; but you may replace the old one, on explicit permission
from the previous publisher that added the old one.</para>

<para>The author(s) and publisher(s) of the Document do not by this
License give permission to use their names for publicity for or to
assert or imply endorsement of any Modified Version.</para>
</simplesect>

<simplesect id="gfdl-5"><title>COMBINING DOCUMENTS</title>

<para>You may combine the Document with other documents released under
this License, under the terms defined in <link linkend="gfdl-4">section
4</link> above for modified versions, provided that you include in the
combination all of the Invariant Sections of all of the original
documents, unmodified, and list them all as Invariant Sections of your
combined work in its license notice, and that you preserve all their
Warranty Disclaimers.</para>

<para>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by adding
at the end of it, in parentheses, the name of the original author or
publisher of that section if known, or else a unique number.  Make the
same adjustment to the section titles in the list of Invariant Sections
in the license notice of the combined work.</para>

<para>In the combination, you must combine any sections Entitled
"History" in the various original documents, forming one section
Entitled "History"; likewise combine any sections Entitled
"Acknowledgements", and any sections Entitled "Dedications".  You must
delete all sections Entitled "Endorsements".</para>
</simplesect>

<simplesect id="gfdl-6"><title>COLLECTIONS OF DOCUMENTS</title>

<para>You may make a collection consisting of the Document and other
documents released under this License, and replace the individual copies
of this License in the various documents with a single copy that is
included in the collection, provided that you follow the rules of this
License for verbatim copying of each of the documents in all other
respects.</para>

<para>You may extract a single document from such a collection, and
distribute it individually under this License, provided you insert a
copy of this License into the extracted document, and follow this
License in all other respects regarding verbatim copying of that
document.</para>
</simplesect>

<simplesect id="gfdl-7"><title>AGGREGATION WITH INDEPENDENT WORKS</title>

<para>A compilation of the Document or its derivatives with other
separate and independent documents or works, in or on a volume of a
storage or distribution medium, is called an "aggregate" if the
copyright resulting from the compilation is not used to limit the legal
rights of the compilation's users beyond what the individual works
permit.  When the Document is included in an aggregate, this License does
not apply to the other works in the aggregate which are not themselves
derivative works of the Document.</para>

<para>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on covers
that bracket the Document within the aggregate, or the electronic
equivalent of covers if the Document is in electronic form.  Otherwise
they must appear on printed covers that bracket the whole
aggregate.</para>
</simplesect>

<simplesect id="gfdl-8"><title>TRANSLATION</title>

<para>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between the
translation and the original version of this License or a notice or
disclaimer, the original version will prevail.</para>

<para>If a section in the Document is Entitled "Acknowledgements",
"Dedications", or "History", the requirement (section 4) to Preserve its
Title (section 1) will typically require changing the actual
title.</para>
</simplesect>

<simplesect id="gfdl-9"><title>TERMINATION</title>

<para>You may not copy, modify, sublicense, or distribute the Document
except as expressly provided for under this License.  Any other attempt
to copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this License
will not have their licenses terminated so long as such parties remain
in full compliance.</para>
</simplesect>

<simplesect id="gfdl-10"><title>FUTURE REVISIONS OF THIS LICENSE</title>

<para>The Free Software Foundation may publish new, revised versions of
the GNU Free Documentation License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in
detail to address new problems or concerns.  See
http://www.gnu.org/copyleft/.</para>

<para>Each version of the License is given a distinguishing version
number.  If the Document specifies that a particular numbered version of
this License "or any later version" applies to it, you have the option
of following the terms and conditions either of that specified version
or of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.</para>
</simplesect>

<simplesect id="gfdl-addendum"><title>ADDENDUM: How to use this License for
  your documents</title>

<para>To use this License in a document you have written, include a copy
of the License in the document and put the following copyright and
license notices just after the title page:</para>

<blockquote id="copyright-sample">
  <title>Sample Invariant Sections list</title><para>
    Copyright (c)  YEAR  YOUR NAME.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.2
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
</para></blockquote>

<para>If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:</para>

<blockquote id="inv-cover-sample">
  <title>Sample Invariant Sections list</title>
<para>
    with the Invariant Sections being LIST THEIR TITLES, with the
    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
</para></blockquote>

<para>If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.</para>

<para>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.</para>
</simplesect>
</sect3>
</sect2>

<sect2>
  <title>GNU General Public License</title>
  <para>
  Version 2, June 1991
  </para>

  <para>
  Copyright  1989, 1991 Free Software Foundation, Inc.
  59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
  </para>

  <para>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
  </para>

  <sect3 id="gpl-1">
    <title>Preamble</title>
    <para>      The licenses for most software are designed to take away your 
      freedom to share and change it. By contrast, the GNU General Public License is 
      intended to guarantee your freedom to share and change 
      free software - to make sure the software is free for all its users. 
      This General Public License applies to most of the Free Software 
      Foundation's software and to any other program whose authors commit 
      to using it. (Some other Free Software Foundation software is covered 
      by the GNU Library General Public License instead.) You can apply it 
      to your programs, too.
    </para>
    <para>      When we speak of free software, we are referring to freedom, not price. 
      Our General Public Licenses are designed to make sure that you have the 
      freedom to distribute copies of free software (and charge for this 
      service if you wish), that you receive source code or can get it if you 
      want it, that you can change the software or use pieces of it in new free 
      programs; and that you know you can do these things.
    </para>
    <para>      To protect your rights, we need to make restrictions that forbid anyone 
      to deny you these rights or to ask you to surrender the rights. These 
      restrictions translate to certain responsibilities for you if you distribute 
      copies of the software, or if you modify it.
    </para>
    <para>      For example, if you distribute copies of such a program, whether gratis or 
      for a fee, you must give the recipients all the rights that you have. You 
      must make sure that they, too, receive or can get the source code. And you 
      must show them these terms so they know their rights.
    </para>
    <para>      We protect your rights with two steps:
      <orderedlist>
	<listitem>
	  <para>	    copyright the software, and
	  </para>
	</listitem>
	<listitem>
	  <para>	    offer you this license which gives you legal permission to copy, 
	    distribute and/or modify the software.
	  </para>
	</listitem>
      </orderedlist>
    </para>
    <para>      Also, for each author's protection and ours, we want to make certain that 
      everyone understands that there is no warranty for this free software. If 
      the software is modified by someone else and passed on, we want its 
      recipients to know that what they have is not the original, so that any 
      problems introduced by others will not reflect on the original authors' 
      reputations.
    </para>
    <para>      Finally, any free program is threatened constantly by software patents. 
      We wish to avoid the danger that redistributors of a free program will 
      individually obtain patent licenses, in effect making the program 
      proprietary. To prevent this, we have made it clear that any patent must be 
      licensed for everyone's free use or not licensed at all.
    </para>
    <para>      The precise terms and conditions for copying, distribution and modification 
      follow.
    </para>
  </sect3>

  <sect3 id="gpl-2">
    <title>TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</title>
    <simplesect id="gpl-2-0">
      <title>Section 0</title>
      <para>	This License applies to any program or other work which contains a notice 
	placed by the copyright holder saying it may be distributed under the terms 
	of this General Public License. The "Program", below, refers to any such 
	program or work, and a 
	<quote>work based on the Program
	</quote> means either 
	the Program or any derivative work under copyright law: that is to say, a 
	work containing the Program or a portion of it, either verbatim or with 
	modifications and/or translated into another language. (Hereinafter, translation 
	is included without limitation in the term 
	<quote>modification
	</quote>.) Each licensee is addressed as <quote>you</quote>.
      </para>
      <para>	Activities other than copying, distribution and modification are not covered by 
	this License; they are outside its scope. The act of running the Program is not 
	restricted, and the output from the Program is covered only if its contents 
	constitute a work based on the Program (independent of having been made by running 
	the Program). Whether that is true depends on what the Program does.
      </para>

    </simplesect>
    <simplesect id="gpl-2-1">
      <title>Section 1</title>
      <para>	You may copy and distribute verbatim copies of the Program's source code as you 
	receive it, in any medium, provided that you conspicuously and appropriately 
	publish on each copy an appropriate copyright notice and disclaimer of warranty; 
	keep intact all the notices that refer to this License and to the absence of any 
	warranty; and give any other recipients of the Program a copy of this License 
	along with the Program.
      </para>
      <para>	You may charge a fee for the physical act of transferring a copy, and you may at 
	your option offer warranty protection in exchange for a fee.
      </para>
      </simplesect>
    <simplesect id="gpl-2-2">
      <title>Section 2</title>
      <para>	You may modify your copy or copies of the Program or any portion of it, thus 
	forming a work based on the Program, and copy and distribute such modifications 
	or work under the terms of 
	<link linkend="gpl-2-1">Section 1
	</link> above, provided 
	that you also meet all of these conditions:
	<orderedlist>
	  <listitem>
	    <para>	      You must cause the modified files to carry prominent notices stating that 
	      you changed the files and the date of any change.
	    </para>
	  </listitem>
	  <listitem>
	    <para>	      You must cause any work that you distribute or publish, that in whole or 
	      in part contains or is derived from the Program or any part thereof, to be 
	      licensed as a whole at no charge to all third parties under the terms of 
	      this License.
	    </para>
	  </listitem>
	  <listitem>
	    <para>	      If the modified program normally reads commands interactively when run, you 
	      must cause it, when started running for such interactive use in the most 
	      ordinary way, to print or display an announcement including an appropriate 
	      copyright notice and a notice that there is no warranty (or else, saying 
	      that you provide a warranty) and that users may redistribute the program 
	      under these conditions, and telling the user how to view a copy of this 
	      License. 
	      <note>
		<title>Exception:
		</title>
		<para>		  If the Program itself is interactive but does not normally print such an 
		  announcement, your work based on the Program is not required to print an 
		  announcement.) 
		</para>
	      </note>
	    </para>
	  </listitem>
	</orderedlist>
      </para>
      <para>	These requirements apply to the modified work as a whole. If identifiable sections 
	of that work are not derived from the Program, and can be reasonably considered 
	independent and separate works in themselves, then this License, and its terms, 
	do not apply to those sections when you distribute them as separate works. But when 
	you distribute the same sections as part of a whole which is a work based on the 
	Program, the distribution of the whole must be on the terms of this License, whose 
	permissions for other licensees extend to the entire whole, and thus to each and 
	every part regardless of who wrote it.
      </para>
      <para>	Thus, it is not the intent of this section to claim rights or contest your rights 
	to work written entirely by you; rather, the intent is to exercise the right to control 
	the distribution of derivative or collective works based on the Program.
      </para>
      <para>	In addition, mere aggregation of another work not based on the Program with the Program 
	(or with a work based on the Program) on a volume of a storage or distribution medium 
	does not bring the other work under the scope of this License.
      </para>
    </simplesect>
    <simplesect id="gpl-2-3">
      <title>Section 3
      </title>
      <para>	You may copy and distribute the Program (or a work based on it, under 
	<link linkend="gpl-2-2">Section 2
	</link> in object code or executable form under the terms of 
	<link linkend="gpl-2-1">Sections 1
	</link> and 
	<link linkend="gpl-2-2">2
	</link> above provided that you also do one of the following:
	<orderedlist>
	  <listitem>
	    <para>	Accompany it with the complete corresponding machine-readable source code, which 
	      must be distributed under the terms of Sections 1 and 2 above on a medium 
	      customarily used for software interchange; or,
	    </para>
	  </listitem>
	  <listitem>
	    <para>	      Accompany it with a written offer, valid for at least three years, to give any 
	      third party, for a charge no more than your cost of physically performing source 
	      distribution, a complete machine-readable copy of the corresponding source code, 
	      to be distributed under the terms of Sections 1 and 2 above on a medium customarily 
	      used for software interchange; or,
	    </para>
	  </listitem>
	  <listitem>
	    <para>	      Accompany it with the information you received as to the offer to distribute 
	      corresponding source code. (This alternative is allowed only for noncommercial 
	      distribution and only if you received the program in object code or executable form 
	      with such an offer, in accord with Subsection b above.)
	    </para>
	  </listitem>
	</orderedlist>
      </para>
      <para>	The source code for a work means the preferred form of the work for making modifications 
	to it. For an executable work, complete source code means all the source code for all modules 
	it contains, plus any associated interface definition files, plus the scripts used to control 
	compilation and installation of the executable. However, as a special exception, the source 
	code distributed need not include anything that is normally distributed (in either source or 
	binary form) with the major components (compiler, kernel, and so on) of the operating system 
	on which the executable runs, unless that component itself accompanies the executable.
      </para>
      <para>	If distribution of executable or object code is made by offering access to copy from a 
	designated place, then offering equivalent access to copy the source code from the same place 
	counts as distribution of the source code, even though third parties are not compelled to 
	copy the source along with the object code.
      </para>
    </simplesect>
    <simplesect id="gpl-2-4">
      <title>Section 4
      </title>
      <para>	You may not copy, modify, sublicense, or distribute the Program except as expressly provided 
	under this License. Any attempt otherwise to copy, modify, sublicense or distribute the 
	Program is void, and will automatically terminate your rights under this License. However, 
	parties who have received copies, or rights, from you under this License will not have their 
	licenses terminated so long as such parties remain in full compliance.
      </para>
    </simplesect>
    <simplesect id="gpl-2-5">
      <title>Section 5
      </title>
      <para>	You are not required to accept this License, since you have not signed it. However, nothing 
	else grants you permission to modify or distribute the Program or its derivative works. 
	These actions are prohibited by law if you do not accept this License. Therefore, by modifying 
	or distributing the Program (or any work based on the Program), you indicate your acceptance 
	of this License to do so, and all its terms and conditions for copying, distributing or 
	modifying the Program or works based on it.
      </para>
    </simplesect>
    <simplesect id="gpl-2-6">
      <title>Section 6
      </title>
      <para>	Each time you redistribute the Program (or any work based on the Program), the recipient 
	automatically receives a license from the original licensor to copy, distribute or modify 
	the Program subject to these terms and conditions. You may not impose any further restrictions 
	on the recipients' exercise of the rights granted herein. You are not responsible for enforcing 
	compliance by third parties to this License.
      </para>
    </simplesect>
    <simplesect id="gpl-2-7">
      <title>Section 7
      </title>
      <para>	If, as a consequence of a court judgment or allegation of patent infringement or for any other 
	reason (not limited to patent issues), conditions are imposed on you (whether by court order, 
	agreement or otherwise) that contradict the conditions of this License, they do not excuse you 
	from the conditions of this License. If you cannot distribute so as to satisfy simultaneously 
	your obligations under this License and any other pertinent obligations, then as a consequence 
	you may not distribute the Program at all. For example, if a patent license would not permit 
	royalty-free redistribution of the Program by all those who receive copies directly or 
	indirectly through you, then the only way you could satisfy both it and this License would be 
	to refrain entirely from distribution of the Program.
      </para>
      <para>	If any portion of this section is held invalid or unenforceable under any particular circumstance, 
	the balance of the section is intended to apply and the section as a whole is intended to apply 
	in other circumstances.
      </para>
      <para>	It is not the purpose of this section to induce you to infringe any patents or other property 
	right claims or to contest validity of any such claims; this section has the sole purpose of 
	protecting the integrity of the free software distribution system, which is implemented by public 
	license practices. Many people have made generous contributions to the wide range of software 
	distributed through that system in reliance on consistent application of that system; it is up 
	to the author/donor to decide if he or she is willing to distribute software through any other 
	system and a licensee cannot impose that choice.
      </para>
      <para>	This section is intended to make thoroughly clear what is believed to be a consequence of the 
	rest of this License.
      </para>
    </simplesect>
    <simplesect id="gpl-2-8">
      <title>Section 8
      </title>
      <para>	If the distribution and/or use of the Program is restricted in certain countries either by patents 
	or by copyrighted interfaces, the original copyright holder who places the Program under this License 
	may add an explicit geographical distribution limitation excluding those countries, so that 
	distribution is permitted only in or among countries not thus excluded. In such case, this License 
	incorporates the limitation as if written in the body of this License.
      </para>
    </simplesect>
    <simplesect id="gpl-2-9">
      <title>Section 9
      </title>
      <para>	The Free Software Foundation may publish revised and/or new versions of the General Public License 
	from time to time. Such new versions will be similar in spirit to the present version, but may differ 
	in detail to address new problems or concerns.
      </para>
      <para>	Each version is given a distinguishing version number. If the Program specifies a version number of 
	this License which applies to it and "any later version", you have the option of following the terms 
	and conditions either of that version or of any later version published by the Free Software 
	Foundation. If the Program does not specify a version number of this License, you may choose any 
	version ever published by the Free Software Foundation.
      </para>
    </simplesect>
    <simplesect id="gpl-2-10">
      <title>Section 10
      </title>
      <para>	If you wish to incorporate parts of the Program into other free programs whose distribution 
	conditions are different, write to the author to ask for permission. For software which is copyrighted 
	by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions 
	for this. Our decision will be guided by the two goals of preserving the free status of all 
	derivatives of our free software and of promoting the sharing and reuse of software generally.
      </para>
    </simplesect>
    <simplesect id="gpl-2-11">
<title>NO WARRANTY Section 11
      </title>
      <para>	BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT 
	PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR 
	OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
	PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE 
	PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
      </para>
    </simplesect>
    <simplesect id="gpl-2-12">
      <title>Section 12
      </title>
      <para>	IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR 
	ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU 
	FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 
	USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED 
	INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH 
	ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH 
	DAMAGES.
      </para>
      <para>END OF TERMS AND CONDITIONS
      </para>
    </simplesect>
  </sect3>

  <sect3 id="gpl-3">
    <title>How to Apply These Terms to Your New Programs
    </title>
    <para>
      If you develop a new program, and you want it to be of the greatest
      possible use to the public, the best way to achieve this is to make it
      free software which everyone can redistribute and change under these terms.
    </para>
    <para>
      To do so, attach the following notices to the program.  It is safest
      to attach them to the start of each source file to most effectively
      convey the exclusion of warranty; and each file should have at least
      the "copyright" line and a pointer to where the full notice is found.
    </para>
    <para>
      &lt;one line to give the program's name and a brief idea of what it does.&gt;
      Copyright (C) &lt;year&gt;    &lt;name of author&gt;
    </para>
    <para>
      This program is free software; you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation; either version 2 of the License, or
      (at your option) any later version.
    </para>
    <para>
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
    </para>
    <para>
      You should have received a copy of the GNU General Public License
      along with this program; if not, write to the Free Software
      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    </para>
    <para>
      Also add information on how to contact you by electronic and paper mail.
    </para>
    <para>
      If the program is interactive, make it output a short notice like this
      when it starts in an interactive mode:
    </para>
    <para>
      Gnomovision version 69, Copyright (C) year name of author
      Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
      This is free software, and you are welcome to redistribute it
      under certain conditions; type `show c' for details.
    </para>
    <para>
      The hypothetical commands `show w' and `show c' should show the appropriate
      parts of the General Public License.  Of course, the commands you use may
      be called something other than `show w' and `show c'; they could even be
      mouse-clicks or menu items--whatever suits your program.
    </para>
    <para>
      You should also get your employer (if you work as a programmer) or your
      school, if any, to sign a "copyright disclaimer" for the program, if
      necessary.  Here is a sample; alter the names:
    </para>
    <para>
      Yoyodyne, Inc., hereby disclaims all copyright interest in the program
      `Gnomovision' (which makes passes at compilers) written by James Hacker.
    </para>
    <para>
      &lt;signature of Ty Coon&gt;, 1 April 1989
      Ty Coon, President of Vice
    </para>
    <para>
      This General Public License does not permit incorporating your program into
      proprietary programs.  If your program is a subroutine library, you may
      consider it more useful to permit linking proprietary applications with the
      library.  If this is what you want to do, use the GNU Library General
      Public License instead of this License.
    </para>
  </sect3>
</sect2>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-Copyright-ocamlyacc">
<title>Ocamlyacc Adaptation Copyright and Permissions Notice</title>

<para>Copyright (C) 2004-2019 SooHyoung Oh.</para>

<para>Permission is granted to make and distribute verbatim copies of this 
manual provided the copyright notice and this permission notice are 
preserved on all copies.</para>

<para>Permission is granted to copy and distribute modified versions of 
this document under the conditions for verbatim copying, provided that 
this copyright notice is included exactly as in the original,
and that the entire resulting derived work is distributed under 
the terms of a permission notice identical to this one.</para>

<para>Permission is granted to copy and distribute translations of this 
document into another language, under the above conditions for modified 
versions.</para>

<para>If you are intending to incorporate this document into a published 
work, please contact the maintainer, and we will make an effort 
to ensure that you have the most up to date information available.</para>

<para>There is no guarantee that this document lives up to its intended
purpose.  This is simply provided as a free resource.  As such,
the authors and maintainers of the information provided within can
not make any guarantee that the information is even accurate.</para>

</sect1>

</chapter>

</book>
