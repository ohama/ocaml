<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ocamllex on Documentation for Hugo Learn Theme</title>
    <link>https://ohama.github.io/ocaml/ocamllex/</link>
    <description>Recent content in Ocamllex on Documentation for Hugo Learn Theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    
	<atom:link href="https://ohama.github.io/ocaml/ocamllex/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction</title>
      <link>https://ohama.github.io/ocaml/ocamllex/01.intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex/01.intro/</guid>
      <description>ocamllex is a tool for generating scanners: programs which recognized lexical patterns in text. ocamllex reads the given input files, for a description of a scanner to generate. The description is in the form of pairs of regular expressions and Ocaml code, called rules. ocamllex generates as output a Ocaml source file which defines lexical analyzer functions. This file is compiled and linked to produce an executable. When the executable is run, it analyzes its input for occurrences of the regular expressions.</description>
    </item>
    
    <item>
      <title>Some simple examples</title>
      <link>https://ohama.github.io/ocaml/ocamllex/02.simpleexample/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex/02.simpleexample/</guid>
      <description>First some simple examples to get the flavor of how one uses ocamllex. The following ocamllex input specifies a scanner which whenever it encounters the string &amp;ldquo;current_directory&amp;rdquo; will replace it with the current directory:
{ } rule translate = parse | &amp;quot;current_directory&amp;quot;	{ print_string (Sys.getcwd ()); translate lexbuf } | _ as c	{ print_char c; translate lexbuf } | eof	{ exit 0 }  In the first rule, &amp;ldquo;current_directory&amp;rdquo; is the pattern and the expression between braces is the action.</description>
    </item>
    
    <item>
      <title>Format of the input file</title>
      <link>https://ohama.github.io/ocaml/ocamllex/03.formatofinputfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex/03.formatofinputfile/</guid>
      <description>The ocamllex input file consists of four sections; header, definitions, rules and trailer section:
(* header section *) { &amp;lt;header&amp;gt; } (* definitions section *) let &amp;lt;ident&amp;gt; = &amp;lt;regexp&amp;gt; let ...	(* rules section *) rule &amp;lt;entrypoint_1&amp;gt; [arg1... argn] = parse | &amp;lt;pattern&amp;gt; { &amp;lt;action&amp;gt; } | ... | &amp;lt;pattern&amp;gt; { &amp;lt;action&amp;gt; } and &amp;lt;entrypoint_2&amp;gt; [arg1... argn] = parse ... and ... (* trailer section *) { &amp;lt;trailer&amp;gt; }  Comments are delimited by (* and *), as in Caml.</description>
    </item>
    
    <item>
      <title>Patterns</title>
      <link>https://ohama.github.io/ocaml/ocamllex/04.patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex/04.patterns/</guid>
      <description>The patterns in the input are written using regular expressions in the style of lex, with a more Caml-like syntax. These are:
 &amp;lsquo;c&amp;rsquo;: match the character &amp;lsquo;c&amp;rsquo;. The character constant is the same syntax as Objective Caml character. &amp;gt;_: (underscore) match any character. eof: match an end-of-file . &amp;ldquo;foo&amp;rdquo;: the literal string &amp;ldquo;foo&amp;rdquo;. The syntax is the same syntax as Objective Caml string constants. [&amp;lsquo;x&amp;rsquo; &amp;lsquo;y&amp;rsquo; &amp;lsquo;z&amp;rsquo;]: character set; in this case, the pattern matches either an &amp;lsquo;x&amp;rsquo;, a &amp;lsquo;y&amp;rsquo;, or a &amp;lsquo;z&amp;rsquo; .</description>
    </item>
    
    <item>
      <title>How the input is matched</title>
      <link>https://ohama.github.io/ocaml/ocamllex/05.howmatched/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex/05.howmatched/</guid>
      <description>When the generated scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, it takes the one matching the most text (the &amp;ldquo;longest match&amp;rdquo; principle). If it finds two or more matches of the same length, the rule listed first in the ocamllex input file is chosen (the &amp;ldquo;first match&amp;rdquo; principle).
Once the match is determined, the text corresponding to the match (called the token) is made available in the form of a string.</description>
    </item>
    
    <item>
      <title>The generted scanner</title>
      <link>https://ohama.github.io/ocaml/ocamllex/07.generatedscanner/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex/07.generatedscanner/</guid>
      <description>The output of ocamllex is the file lex.ml when it is invoked as ocamllex lex.mll. The generated file contains the scanning functions, a number of tables used by it for matching tokens, and a number of auxiliary routines. The scanning functions are declared as followings:
let &amp;lt;entrypoint&amp;gt; [arg1... argn] lexbuf = ... and ...  where the fuction entrypoint has n + 1 arguments. n arguments come from the definition of the rules secton.</description>
    </item>
    
    <item>
      <title>8. Start conditions</title>
      <link>https://ohama.github.io/ocaml/ocamllex/08.startcondition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex/08.startcondition/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>9. Interfacing with ocamlyacc</title>
      <link>https://ohama.github.io/ocaml/ocamllex/09.interfacewithocamlyacc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex/09.interfacewithocamlyacc/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
    <item>
      <title>10. Options</title>
      <link>https://ohama.github.io/ocaml/ocamllex/10.options/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ohama.github.io/ocaml/ocamllex/10.options/</guid>
      <description>Introduction Ocamlyacc is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a Ocaml program to parse that grammar. Once you are proficient with Ocamlyacc, you may use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.
Ocamlyacc is very close to the well-known yacc (or bison) commands that can be found in most C programming environments.</description>
    </item>
    
  </channel>
</rss>