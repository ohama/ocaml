<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
    "/usr/share/sgml/docbook/xml-dtd-4.2-1.0-22.1/docbookx.dtd" [
]>

<book id="ocamllex-tutorial">

<bookinfo>
    <date>2019-05-05</date>
    <title>Ocamllex Tutorial</title>
    <authorgroup>
      <author>
        <firstname>Ocamllex Adaptation: SooHyoung</firstname>
        <surname>Oh</surname>
      </author>
    </authorgroup>
    <abstract>
      <para>
      This is a tutorial on how to use <literal>ocamllex</literal>
      which is distributed with
      <ulink url="http://ocaml.org">Ocaml language</ulink>
      </para>
      <para>
      This document borrowed lots of part from
      <ulink url="https://github.com/westes/flex">flex</ulink> manual.
      </para>

      <para>
            Please mail all comments and suggestions to <email>ohama100@gmail.com</email>
      </para>
      <para>
            The latest version can
            be found at <ulink url="https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamllex-tutorial/index.html">
            https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamllex-tutorial/index.html</ulink>.
      </para>

      <para>
      The companion tutorial for <literal>ocamlyacc</literal> is available
      at <ulink url="http://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/index.html">
      https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/index.html</ulink>.
      </para>

      <para>
	    You can find the source of this document in
            <ulink url="https://ohama.github.io/ocaml/ocamllex-ocamlyacc/tutorial">tutorial</ulink> directory.
	    For printing,
            <ulink url="https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamllex-tutorial.pdf">pdf</ulink> is presented.
      </para>

      <para>
	    For the source of examples used in this document, see
            <ulink url="https://ohama.github.io/ocaml/ocamllex-ocamlyacc/ocamllex-examples">ocamllex-examples</ulink> directory.
      </para>

      <para>
<emphasis>
This document is just a re-formatting of the old one.
There have been many improvements since then in Ocaml
programming language but those are not reflected in this document.
</emphasis>
      </para>

      <para>
            First release: 2004-11-16
      </para>
      <para>
            Last updated: 2019-05-05
      </para>
    </abstract>
  </bookinfo>

<toc></toc>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-ocamllex">
<title>Introduction</title>

<para>
<literal>ocamllex</literal> is a tool for generating <emphasis>scanners</emphasis>:
programs which recognized lexical
patterns in text. <literal>ocamllex</literal> reads the given input files, for a description of
a scanner to generate. The description is in the form of pairs of regular
expressions and Ocaml code, called <emphasis>rules</emphasis>.
<literal>ocamllex</literal> generates as output a Ocaml
source file which defines lexical analyzer functions.
This file is compiled and linked to produce an executable.
When the executable is run, it analyzes its input for occurrences
of the regular expressions. Whenever it finds one, it executes
the corresponding Ocaml code. 
</para>

<para>
If you execute the following command with the input file named
<emphasis>lexer</emphasis><literal>.mll</literal>
</para>

<programlisting role="C">
        ocamllex <emphasis>lexer</emphasis>.mll
</programlisting>

<para>
you will get Caml code for a lexical analyzer in file
<emphasis>lexer</emphasis><literal>.ml</literal>.
</para>

</chapter>

<!-- ************************************************************** -->
<chapter id="sec-ocamllex-some-simple-examples">
<title>Some simple examples</title>

<para>
   First some simple examples to get the flavor of how one uses <literal>ocamllex</literal>.
The following <literal>ocamllex</literal> input specifies a scanner which whenever it
encounters the string "current_directory" will replace it with the current 
directory:
</para>

<programlisting role="C">
{ }
rule translate = parse
  | "current_directory"	{ print_string (Sys.getcwd ()); translate lexbuf }
  | _ as c		{ print_char c; translate lexbuf }
  | eof			{ exit 0 }
</programlisting>

<para>
In the first rule, "current_directory" is the <emphasis>pattern</emphasis>
and the expression between braces is the <emphasis>action</emphasis>.
By this rule, when the scanner matches the string "current_directory",
it executes the corresponding action which prints the current directory name
and call the scanner again.
Recursive calling itself is necessary to do the other job.
</para>

<para>
Any text not matched by a <emphasis>ocamllex</emphasis> scanner
generates exception <literal>Failure "lexing: empty token"</literal>,
so you have to supply the last two rules.
The second rule copies any character to its output
which is not matched by the first rule, and it calls itself again.
By the third rule, the program exits when it meets
<literal>end of file</literal>.
So the net effect of this scanner is to copy its input file
to its output with each occurrence of "current_directory" expanded.
The "{ }" in the first line delimits the <literal>header</literal> section from the rest.
</para>

<para>
   Here's another simple example:
</para>

<programlisting role="C">
{
  let num_lines = ref 0
  let num_chars = ref 0
}

rule count = parse
  | '\n'        { incr num_lines; incr num_chars; count lexbuf }
  | _           { incr num_chars; count lexbuf }
  | eof         { () }

{
  let main () =
    let lexbuf = Lexing.from_channel stdin in
    count lexbuf;
    Printf.printf "# of lines = %d, # of chars = %d\n" !num_lines !num_chars

  let _ = Printexc.print main ()
}
</programlisting>

<para>
   This scanner counts the number of characters and the number of lines
in its input (it produces no output other than the final report on the
counts).
The first <literal>header</literal> section declares two globals,
"num_lines" and "num_chars", which are accessible both inside scanner function
<literal>count</literal> and in the <literal>trailer</literal> section
which is the last part enclosed by braces.
There are three rules,
one which matches a newline ("\n") and increments both the line count
and the character count, and one which matches any character other than
a newline (indicated by the "_"  regular expression).
At the end of file, the scanner function <literal>count</literal> returns
<literal>unit</literal>.
</para>

<para>
   A somewhat more complicated example:
</para>

<programlisting role="C">
(* scanner for a toy language *)

{
  open Printf
}

let digit = ['0'-'9']
let id = ['a'-'z'] ['a'-'z' '0'-'9']*

rule toy_lang = parse
  | digit+ as inum
  	{ printf "integer: %s (%d)\n" inum (int_of_string inum);
	  toy_lang lexbuf
	}
  | digit+ '.' digit* as fnum
  	{ printf "float: %s (%f)\n" fnum (float_of_string fnum);
	  toy_lang lexbuf
	}
  | "if"
  | "then"
  | "begin"
  | "end"
  | "let"
  | "in"
  | "function" as word
  	{ printf "keyword: %s\n" word;
	  toy_lang lexbuf
	}
  | id as text
  	{ printf "identifier: %s\n" text;
	  toy_lang lexbuf
	}
  | '+'
  | '-'
  | '*'
  | '/' as op
  	{ printf "operator: %c\n" op;
	  toy_lang lexbuf
	}
  | '{' [^ '\n']* '}'	{ toy_lang lexbuf }	(* eat up one-line comments *)
  | [' ' '\t' '\n']	{ toy_lang lexbuf }	(* eat up whitespace *)
  | _ as c
  	{ printf "Unrecognized character: %c\n" c;
	  toy_lang lexbuf
	}
  | eof		{ }

{
  let main () =
    let cin =
      if Array.length Sys.argv > 1
      then open_in Sys.argv.(1)
      else stdin
    in
    let lexbuf = Lexing.from_channel cin in
    toy_lang lexbuf

  let _ = Printexc.print main ()
}
</programlisting>

<para>
   This is the beginnings of a simple scanner for a language.
It identifies different types of <emphasis>tokens</emphasis>
and reports on what it has seen.
</para>

<para>
   The details of this example will be explained in the following
sections.
</para>

</chapter>

<!-- ************************************************************** -->
<chapter id="sec-ocamllex-format-of-the-input-file">
<title>Format of the input file</title>

<para>
The <emphasis>ocamllex</emphasis> input file consists of four sections;
<emphasis>header</emphasis>, <emphasis>definitions</emphasis>,
<emphasis>rules</emphasis>
and <emphasis>trailer</emphasis> section:
</para>

<programlisting role="C">
	(* header section *)
	{ <emphasis>header</emphasis> }

	(* definitions section *)
	let <emphasis>ident</emphasis> = <emphasis>regexp</emphasis>
	let ...	

	(* rules section *)
	rule <emphasis>entrypoint [arg1... argn]</emphasis> = parse
	  | <emphasis>pattern</emphasis> { <emphasis>action</emphasis> }
 	  | ...
 	  | <emphasis>pattern</emphasis> { <emphasis>action</emphasis> }
	and <emphasis>entrypoint [arg1... argn]</emphasis> = parse
  	  ...
	and ...

	(* trailer section *)
	{ <emphasis>trailer</emphasis> }
</programlisting>

<para>
Comments are delimited by (* and *), as in Caml.
</para>

<para>
The <emphasis>header</emphasis> and <emphasis>rules</emphasis> sections
are necessary
while <emphasis>definitions</emphasis> and <emphasis>trailer</emphasis>
sections are optional.
</para>

<para>
The <emphasis>header</emphasis> and <emphasis>trailer</emphasis> sections are
enclosed in curly braces and they contain arbitrary Caml code.
At the beginning of the output file, the header text is copied as is
while the trailer text is copied at the end of the output file.
For example, you can code open directives and some auxiliary funtions
in the header section.
</para>

<para>
The <emphasis>definitions</emphasis> section contains declarations of
simple <emphasis>ident</emphasis>
definitions to simplify the scanner specification.
Ident definitions have the form:
</para>

<programlisting role="C">
	let <emphasis>ident</emphasis> = <emphasis>regexp</emphasis>
	let ...	
</programlisting>

<para>
The "ident" must be valid identifiers for Caml values
(starting with a lowercase letter). 
For example,
</para>

<programlisting role="C">
	let <emphasis>digit</emphasis> = ['0'-'9']
	let <emphasis>id</emphasis> = ['a'-'z']['a'-'z' '0'-'9']*
</programlisting>

<para>
defines "digit" to be a regular expression which matches a single
digit, and "id" to be a regular expression which matches a letter
followed by zero-or-more letters-or-digits.  A subsequent reference to
</para>

<programlisting role="C">
	digit+ "." digit*
</programlisting>

<para>
is identical to
</para>

<programlisting role="C">
	['0'-'9']+ "." ['0'-'9']*
</programlisting>

<para>
and matches one-or-more digits followed by a '.' followed by
zero-or-more digits.
</para>

<para>
The <emphasis>rules</emphasis> section of the <literal>ocamllex</literal> input contains a series of entrypoints of the form:
</para>

<programlisting role="C">
	rule <emphasis>entrypoint [arg1... argn]</emphasis> = parse
	  | <emphasis>pattern</emphasis> { <emphasis>action</emphasis> }
 	  | ...
 	  | <emphasis>pattern</emphasis> { <emphasis>action</emphasis> }
	and ...
</programlisting>

<para>
The first <literal>|</literal> (bar) after <literal>parse</literal> is
optional.
</para>

<para>
Each entrypoint consists of a series of pattern-action:
</para>

<programlisting role="C">
	  | <emphasis>pattern</emphasis> { <emphasis>action</emphasis> }
</programlisting>

<para>
where the action must be enclosed in curly braces.
</para>

<para>
   See below for a further description of patterns and actions.
</para>

</chapter>

<!-- ************************************************************** -->
<chapter id="sec-ocamllex-patterns">
<title>Patterns</title>

<para>
The patterns in the input are written using regular expressions
in the style of lex, with a more Caml-like syntax. These are:
</para>

<itemizedlist>
<listitem>
  <simpara><literal>'c'</literal></simpara>
  <simpara>
  match the character 'c'. The character constant is the same syntax as Objective Caml character.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>_</literal></simpara>
  <simpara>(underscore) match any character.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>eof</literal></simpara>
  <simpara>
  match an end-of-file .
  </simpara>
</listitem>

<listitem>
  <simpara><literal>"foo"</literal></simpara>
  <simpara>
  the literal string "foo". The syntax is the same syntax as Objective Caml string constants.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>['x' 'y' 'z']</literal></simpara>
  <simpara>
  character set; in this case, the pattern matches either an 'x', a 'y', or a 'z' .
  </simpara>
</listitem>

<listitem>
  <simpara><literal>['a' 'b' 'j'-'o' 'Z']</literal></simpara>
  <simpara>
  character set with a range in it; ranges of characters 'c1' - 'c2' (all characters between c1 and c2, inclusive);
  in this case, the pattern matches an `a', a `b', any letter from `j' through `o', or a `Z'.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>[^ 'A'-'Z']</literal></simpara>
  <simpara>
  a "negated character set", i.e., any character but those in the class. In this case, any character EXCEPT an uppercase letter. 
  </simpara>
</listitem>

<listitem>
  <simpara><literal>[^ 'A'-'Z' '\n']</literal></simpara>
  <simpara>
  any character EXCEPT an uppercase letter or a newline 
  </simpara>
</listitem>

<listitem>
  <simpara><literal>r*</literal></simpara>
  <simpara>
  zero or more r's, where r is any regular expression 
  </simpara>
</listitem>

<listitem>
  <simpara><literal>r+</literal></simpara>
  <simpara>
  one or more r's, where r is any regular expression 
  </simpara>
</listitem>

<listitem>
  <simpara><literal>r?</literal></simpara>
  <simpara>
  zero or one r's, where r is any regular expression (that is, "an optional r") 
  </simpara>
</listitem>

<listitem>
  <simpara><literal>ident</literal></simpara>
  <simpara>
  the expansion of the "ident"
  defined by an earlier <literal>let ident =  regexp</literal> definition.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>(r)</literal></simpara>
  <simpara>
  match an r; parentheses are used to override precedence (see below) 
  </simpara>
</listitem>

<listitem>
  <simpara><literal>rs</literal></simpara>
  <simpara>
  the regular expression r followed by the regular expression s; called "concatenation" 
  </simpara>
</listitem>

<listitem>
  <simpara><literal>r|s</literal></simpara>
  <simpara>
  either an r or an s 
  </simpara>
</listitem>

<listitem>
  <simpara><literal>r#s</literal></simpara>
  <simpara>
  match the difference of the two specified character sets.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>r as ident</literal></simpara>
  <simpara>
  bind the string matched by <literal>r</literal> to identifier <literal>ident</literal>. 
  </simpara>
</listitem>

</itemizedlist>

<para>
</para>

<para>
The regular expressions listed above are grouped according to precedence, from highest precedence at the top to lowest at the bottom;
'*' and '+' have highest precedence, followed by '?', 'concatenation', '|', and then <literal>'as'</literal>.
For example,
</para>

<programlisting role="C">
	"foo" | "bar"*
</programlisting>

<para>
is the same as
</para>

<programlisting role="C">
	("foo")|("bar"*)
</programlisting>

<para>
since the '*' operator has higher precedence than
than alternation ('|').  This pattern therefore
matches <emphasis>either</emphasis> the string "foo" <emphasis>or</emphasis>
zero-or-more of the string "bar".
</para>

<para>
To match zero-or-more "foo"'s-or-"bar"'s:
</para>

<programlisting role="C">
	("foo"|"bar")*
</programlisting>

<para>
A negated character set such as the example "[^ 'A'-'Z']" above
<emphasis>will match a newline</emphasis>
unless "\n" (or an equivalent escape sequence) is
one of the characters explicitly present in the negated character
set (e.g., "[^ 'A'-'Z' '\n']").  This is unlike how many other regular
expression tools treat negated character set, but
unfortunately the inconsistency is historically entrenched.
Matching newlines means that a pattern like [^"]* can match the
entire input unless there's another quote in the input.
</para>
</chapter>

<!-- ************************************************************** -->
<chapter id="sec-ocamllex-how-the-input-is-matched">
<title>How the input is matched</title>

<para>
   When the generated scanner is run, it analyzes its input looking for
strings which match any of its patterns.  If it finds more than one
match, it takes the one matching the most text (the "longest match" principle).
If it finds two or more matches
of the same length, the rule listed first in the <literal>ocamllex</literal>
input file is chosen (the "first match" principle).
</para>

<para>
   Once the match is determined, the text corresponding to the match
(called the <emphasis>token</emphasis>) is made available in
the form of a string.
The <emphasis>action</emphasis>
corresponding to the matched pattern is then executed (a more detailed
description of actions follows), and then the remaining input is
scanned for another match.
</para>

<para>
If no match is found, the scanner raises 
the <literal>Failure "lexing: empty token"</literal> exception.
</para>

<para>
Now, let's see the examples which shows how the patterns are applied.
</para>

<programlisting role="C">
rule token = parse
  | "ding"	{ print_endline "Ding" }		(* "ding" pattern *)
  | ['a'-'z']+ as word				(* "word" pattern *)
  		{ print_endline ("Word: " ^ word) }
  ...
</programlisting>

<para>
When "ding" is given as an input, the <literal>ding</literal> and
<literal>word</literal> pattern can be matched. <literal>ding</literal>
pattern is selected because it comes before <literal>word</literal> pattern.
So if you code like this:
</para>

<programlisting role="C">
rule token = parse
  | ['a'-'z']+ as word				(* "word" pattern *)
  		{ print_endline ("Word: " ^ word) }
  | "ding"	{ print_endline "Ding" }		(* "ding" pattern *)
  | ...
</programlisting>

<para>
<literal>ding</literal> pattern will be useless.
</para>

<para>
In the following example, there are three patterns: <literal>ding</literal>, <literal>dong</literal> and <literal>dingdong</literal>.
</para>

<programlisting role="C">
rule token = parse
  | "ding"	{ print_endline "Ding" }		(* "ding" pattern *)
  | "dong"	{ print_endline "Dong" }		(* "dong" pattern *)
  | "dingdong"	{ print_endline "Ding-Dong" }	(* "dingdong" pattern *)
  ...
</programlisting>

<para>
When "dingdong" is given as an input, there are two choices:
<literal>ding</literal> + <literal>dong</literal> pattern or
<literal>dingdong</literal> pattern.
But by the "longest match" principle,
<literal>dingdong</literal> pattern will be selected.
</para>

<para>
Though the "shortest match" principle is not used so frequently, 
<literal>ocamllex</literal> supports it.
If you want to select the shortest prefix of the input,
use <literal>shortest</literal> keyword
instead of the <literal>parse</literal> keyword.
The "first match" principle holds still with the "shortest match" principle.
</para>

</chapter>

<!-- ************************************************************** -->
<chapter id="sec-ocamllex-actions">
<title>Actions</title>

<para>
   Each pattern in a rule has a corresponding action, which can be any
arbitrary Ocaml expression.
For example, here is the specification for a program
which deletes all occurrences of "zap me" from its input:
</para>

<programlisting role="C">
{}
rule token = parse
  | "zap me"	{ token lexbuf }	(* ignore this token: no processing and continue *)
  | _ as c	{ print_char c; token lexbuf }
</programlisting>

<para>
   Here is a program which compresses multiple blanks and tabs down to
a single blank, and throws away whitespace found at the end of a line:
</para>

<programlisting role="C">
{}
rule token = parse
  | [' ' '\t']+		{ print_char ' '; token lexbuf }
  | [' ' '\t']+ '\n'	{ token lexbuf }      (* ignore this token *)
</programlisting>

<para>
Actions can include arbitrary Ocaml code which returns a value.
Each time the lexical analyzer function is called
it continues processing tokens from where it last
left off until it either reaches the end of the file.
</para>

<para>
Actions are evaluated
after the <literal>lexbuf</literal> is bound to the current lexer buffer and
the identifer following the keyword <literal>as</literal> to the matched string.
The usage of <literal>lexbuf</literal> is provided by the Lexing standard library module; 
</para>

<itemizedlist>
<listitem>
  <simpara><literal>Lexing.lexeme lexbuf</literal></simpara>
  <simpara>
Return the matched string.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>Lexing.lexeme_char lexbuf</literal> <emphasis>n</emphasis></simpara>
  <simpara>
Return the <emphasis>n</emphasis>th character in the matched string.
The index number of the first character starts from 0.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>Lexing.lexeme_start lexbuf</literal></simpara>
  <simpara><literal>Lexing.lexeme_end lexbuf</literal></simpara>
  <simpara>
Return the absolute position in the input text of the beginning/end of the matched string. The position of the first character is 0.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>Lexing.lexeme_start_p lexbuf</literal></simpara>
  <simpara><literal>Lexing.lexeme_end_p lexbuf</literal></simpara>
  <simpara>
  (Since Ocaml 3.08) Return the position of type <literal>position</literal>
  (See <link linkend="sec-position">Position</link>).
  </simpara>
</listitem>

<listitem>
  <simpara><emphasis>entrypoint [exp1... expn]</emphasis> <literal>lexbuf</literal></simpara>
  <simpara>
Call the other lexer on the given entry point.
Notice that <literal>lexbuf</literal> is the last argument.
  </simpara>
</listitem>

</itemizedlist>

<!-- ************************************************************** -->
<sect1 id="sec-position">
<title>Position</title>

<remark>
Since Ocaml 3.08
</remark>

<para>
The position information on scanning the input text is recorded
in the <literal>lexbuf</literal>
which has a field <literal>lex_curr_p</literal> of the type <literal>position</literal>:
</para>

<programlisting role="C">
  type position = {
     pos_fname : string;		(* file name *)
     pos_lnum : int;		(* line number *)
     pos_bol : int;		(* the offset of the beginning of the line *)
     pos_cnum : int;		(* the offset of the position *)
  } 
</programlisting>

<para>
The value of <literal>pos_bol</literal> field is the number of characters between the beginning of the file and the beginning of the line
while the value of <literal>pos_cnum</literal> field is the number of characters between the beginning of the file and the position.
</para>

<para>
The lexing engine manages only the <literal>pos_cnum</literal> field of
<literal>lexbuf.lex_curr_p</literal> with the number of characters read
from the start of <literal>lexbuf</literal>. So you are reponsible for the other fields to be accurate.
Typically, whenever the lexer meets a newline character,
the action contains a call to the following function:
</para>

<programlisting role="C">
  let incr_linenum lexbuf =
    let pos = lexbuf.Lexing.lex_curr_p in
    lexbuf.Lexing.lex_curr_p &lt;- { pos with
      Lexing.pos_lnum = pos.Lexing.pos_lnum + 1;
      Lexing.pos_bol = pos.Lexing.pos_cnum;
    }
  ;;
</programlisting>

</sect1>

</chapter>

<!-- ************************************************************** -->
<chapter id="sec-ocamllex-generated-scanner">
<title>The generated scanner</title>

<para>
The output of <literal>ocamllex</literal> is the file
<emphasis>lex</emphasis>.ml when it is invoked as
<literal>ocamllex</literal> <emphasis>lex</emphasis><literal>.mll</literal>.
The generated file contains the
<emphasis>scanning functions</emphasis>,
a number of tables used by it for matching
tokens, and a number of auxiliary routines.
The <emphasis>scanning functions</emphasis> are declared as followings:
</para>

<programlisting role="C">
let <emphasis>entrypoint [arg1... argn]</emphasis> lexbuf =
  ...
and ...
</programlisting>

<para>
where the fuction <emphasis>entrypoint</emphasis> has <literal>n + 1</literal>
arguments.
<literal>n</literal> arguments come from the definition of the <emphasis>rules</emphasis> secton.
And the resulting scanning function has one more argument named <literal>lexbuf</literal> of <literal>Lexing.lexbuf</literal> type as the last one.
</para>

<para>
Whenever <emphasis>entrypoint</emphasis> is called, it scans tokens from the <literal>lexbuf</literal> argument.
When it finds a match in patterns, it executes the corresponding action and returns.
If you want to continue the lexical analyze
after evaluating of the action,
you must call the <emphasis>scanning function</emphasis> recursively.
</para>

</chapter>

<!-- ************************************************************** -->
<chapter id="sec-ocamllex-start-conditions">
<title>Start conditions</title>

<para>
<literal>ocamllex</literal> provides a mechanism for conditionally activating rules.
When you want do activate the other rule, just call the other <emphasis>entrypoint</emphasis> function.
For example, the following has two rules, one for finding tokens and one for
skipping comments.
</para>

<programlisting role="C">
{}
rule token = parse
  | [' ' '\t' '\n']+
  	(* skip spaces *)
  	{ token lexbuf }
  | "(*"
	(* activate "comment" rule *)
  	{ comment lexbuf }
  ...
and comment = parse
  | "*)"
  	(* go to the "token" rule *)
  	{ token lexbuf }
  | _
	(* skip comments *)
  	{ comment lexbuf }
  ...
</programlisting>

<para>
When the generated scanner meets comment start token <literal>"(*"</literal>
at the <literal>token</literal> rule,
it activates the other rule <literal>comment</literal>.
When it meets the end of comment token <literal>"*)"</literal> at
the <literal>comment</literal> rule.
it returns to the scanning <literal>token</literal> rule.
</para>

</chapter>

<!-- ************************************************************** -->
<chapter id="sec-ocamllex-interfacing">
<title>Interfacing with <literal>ocamlyacc</literal></title>

<para>
   One of the main uses of <literal>ocamllex</literal> is as a companion to the <literal>ocamlyacc</literal>
parser-generator.
<literal>ocamlyacc</literal> parsers call
one of the <emphasis>scanning functions</emphasis>
to find the next input token. 
The routine is supposed to
return the type of the next token with an associated value.
To use <literal>ocamllex</literal> with <literal>ocamlyacc</literal>, scanner
functions should use parser module to refer token types,
which are defined in `%tokens' attributes appearing
in the <literal>ocamlyacc</literal> input.
For example, if input filename of <literal>ocamlyacc</literal> is
<emphasis>parse.mly</emphasis> and
one of the tokens is "NUMBER", part of the scanner might look
like:
</para>

<programlisting role="C">
{
  open Parse
}

rule token = parse
  ...
  | ['0'-'9']+ as num { NUMBER (int_of_string num) }
  ...
</programlisting>

</chapter>

<!-- ************************************************************** -->
<chapter id="sec-ocamllex-options">
<title>Options</title>

<para>
<literal>ocamllex</literal> has the following options:
</para>

<itemizedlist>
<listitem>
  <simpara><literal>-o</literal> <emphasis>output-file</emphasis>
  </simpara>
  <simpara>
  By default, <literal>ocamllex</literal> produces
  <emphasis>lexer</emphasis><literal>.ml</literal>,
  when <literal>ocamllex</literal> is invoked as
  "<literal>ocamllex</literal> <emphasis>lexer</emphasis><literal>.mll</literal>".
  You can change the name of the output file using <literal>-o</literal> option.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>-ml</literal>
  </simpara>
  <simpara>
  By default, <literal>ocamllex</literal> produces
  code that uses the Caml built-in automata interpreter.
  Using this option, the automaton is coded as Caml functions.
  This option is useful for debugging <literal>ocamllex</literal>,
  but it's not recommended for production lexers.
  </simpara>
</listitem>

<listitem>
  <simpara><literal>-q</literal>
  </simpara>
  <simpara>
  By default, <literal>ocamllex</literal> outputs informational
  messages to standard output.
  If you use <literal>-q</literal> option, they are suppressed.
  </simpara>
</listitem>

</itemizedlist>

</chapter>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-usage-tips">
<title>Usage Tips</title>

<para>
</para>

<!-- ************************************************************** -->
<sect1 id="sec-hashtable">
<title>Keyword Hashtable</title>

<para>
The number of status transitions generated by <literal>ocamllex</literal> are
limited to at most 32767. If you use too many transitions,
for example, too many keywords,
<literal>ocamllex</literal> generates the following error message:
</para>

<programlisting role="C">
camllex: transition table overflow, automaton is too big
</programlisting>

<para>
It tells that your lexer definition is too complex.
To make the generated automata small,
you have to encode using keyword table:
</para>

<programlisting role="C">
{
  let keyword_table = Hashtbl.create 72
  let _ =
    List.iter (fun (kwd, tok) -> Hashtbl.add keyword_table kwd tok)
              [ ("keyword1", KEYWORD1);
                ("keyword2", KEYWORD2);
		...
              ]
}

rule token = parse
  | ...
  | ['A'-'Z' 'a'-'z'] ['A'-'Z' 'a'-'z' '0'-'9' '_']* as id
               { try
	       		Hashtbl.find keyword_table id
                 with
		 	Not_found -> IDENT id
		}
  | ...
</programlisting>

<para>
For a complete example, see <link linkend="sec-toy-language">Toy Language</link>
program.
</para>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-nested-comments">
<title>Nested Comments</title>

<para>
Some language such as Ocaml support nested comment.
It can be implemented like this:
</para>

<programlisting role="C">
{ }

rule token = parse
  | "(*"		{ print_endline "comments start"; comments 0 lexbuf }
  | [' ' '\t' '\n']	{ token lexbuf }
  | ['a'-'z']+ as word
  		{ Printf.printf "word: %s\n" word; token lexbuf }
  | _ as c	{ Printf.printf "char %c\n" c; token lexbuf }
  | eof		{ raise End_of_file }

and comments level = parse
  | "*)"	{ Printf.printf "comments (%d) end\n" level;
  		  if level = 0 then token lexbuf
		  else comments (level-1) lexbuf
		}
  | "(*"	{ Printf.printf "comments (%d) start\n" (level+1);
  		  comments (level+1) lexbuf
		}
  | _		{ comments level lexbuf }
  | eof		{ print_endline "comments are not closed";
  		  raise End_of_file
		}
</programlisting>

<para>
When the scanner function meets <emphasis>comments start</emphasis> token
<literal>"(*"</literal>
in evaluating <literal>token</literal> rule, it enters
<literal>comments</literal> rule with level of 0.
<literal>token</literal> rule is invoked again
when all comments are closed.
Comments nesting level is increased whenever there is
<emphasis>comment start</emphasis> token
<literal>"(*"</literal> in the input text.
</para>

<para>
If the scanner function meets <emphasis>end of comments</emphasis> token
<literal>"*)"</literal>, it tests the comments nesting level.
When the nesting level is not zero, it decrements the level by one and continues
to scan comments.
It returns to <literal>token</literal> rule
when all the comments are closed i.e., the nesting level is zero.
</para>

</sect1>

</chapter>
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-examples">
<title>Examples</title>

<para>
This chapter includes examples in complete form.
Some are revised from the code fragments of the previous chapters.
</para>

<!-- ************************************************************** -->
<sect1 id="sec-translate">
<title>Translate</title>

<para>
This example translates the text "current_directory" to the
<emphasis>current directory</emphasis>.
</para>

<programlisting role="C">
{ }

rule translate = parse
  | "current_directory"	{ print_string (Sys.getcwd ()) }
  | _ as c		{ print_char c }
  | eof			{ exit 0 }

{
  let main () =
    let lexbuf = Lexing.from_channel stdin in
    while true do
      translate lexbuf
    done

  let _ = Printexc.print main ()
}
</programlisting>
</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-word-count">
<title>Word Count</title>

<para>
This example shows the number of lines, words and characters of the
given file if the filename is given,
or of the standard input if no command arguments are given.
</para>

<programlisting role="C">
{ }

rule count lines words chars = parse
  | '\n'		{ count (lines+1) words (chars+1) lexbuf }
  | [^ ' ' '\t' '\n']+ as word
  		{ count lines (words+1) (chars+ String.length word) lexbuf }
  | _		{ count lines words (chars+1) lexbuf }
  | eof		{ (lines, words, chars) }

{
  let main () =
    let cin =
      if Array.length Sys.argv > 1
      then open_in Sys.argv.(1)
      else stdin
    in
    let lexbuf = Lexing.from_channel cin in
    let (lines, words, chars) = count 0 0 0 lexbuf in
    Printf.printf "%d lines, %d words, %d chars\n" lines words chars

  let _ = Printexc.print main ()
}
</programlisting>

</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-toy-language">
<title>Toy Language</title>

<para>
In this example, the scanner function <literal>toy_lang</literal>
returns a value of <literal>token</literal> type,
but the <literal>main</literal> function
does nothing with it.
</para>

<programlisting role="C">
{
  open Printf

  let create_hashtable size init =
    let tbl = Hashtbl.create size in
    List.iter (fun (key, data) -> Hashtbl.add tbl key data) init;
    tbl

  type token =
    | IF
    | THEN
    | ELSE
    | BEGIN
    | END
    | FUNCTION
    | ID of string
    | OP of char
    | INT of int
    | FLOAT of float
    | CHAR of char

  let keyword_table = 
    create_hashtable 8 [
      ("if", IF);
      ("then", THEN);
      ("else", ELSE);
      ("begin", BEGIN);
      ("end", END);
      ("function", FUNCTION)
    ]

}

let digit = ['0'-'9']
let id = ['a'-'z' 'A'-'Z']['a'-'z' '0'-'9']*

rule toy_lang = parse
  | digit+ as inum
  	{ let num = int_of_string inum in
	  printf "integer: %s (%d)\n" inum num;
	  INT num
	}
  | digit+ '.' digit* as fnum
  	{ let num = float_of_string fnum in
	  printf "float: %s (%f)\n" fnum num;
	  FLOAT num
	}
  | id as word
  	{ try
	    let token = Hashtbl.find keyword_table word in
	    printf "keyword: %s\n" word;
	    token
	  with Not_found ->
	    printf "identifier: %s\n" word;
	    ID word
	}
  | '+'
  | '-'
  | '*'
  | '/' as op
  	{ printf "operator: %c\n" op;
	  OP op
	}
  | '{' [^ '\n']* '}'	(* eat up one-line comments *)
  | [' ' '\t' '\n']	(* eat up whitespace *)
  	{ toy_lang lexbuf }
  | _ as c
  	{ printf "Unrecognized character: %c\n" c;
	  CHAR c
	}
  | eof
  	{ raise End_of_file }

{
  let rec parse lexbuf =
     let token = toy_lang lexbuf in
     (* do nothing in this example *)
     parse lexbuf

  let main () =
    let cin =
      if Array.length Sys.argv > 1
      then open_in Sys.argv.(1)
      else stdin
    in
    let lexbuf = Lexing.from_channel cin in
    try parse lexbuf
    with End_of_file -> ()

  let _ = Printexc.print main ()
}
</programlisting>

</sect1>

</chapter>

<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->
<!-- ************************************************************** -->

<chapter id="chap-license">
<title>License</title>

<para>
</para>

<!-- ************************************************************** -->
<sect1 id="sec-flex-license">
<title>License in flex manual</title>

<para>
Copyright (C) 1990 The Regents of the University of California.
All rights reserved.
</para>

<para>
This code is derived from software contributed to Berkeley by
Vern Paxson.
</para>

<para>
The United States Government has rights in this work pursuant
to contract no. DE-AC03-76SF00098 between the United States
Department of Energy and the University of California.
</para>

<para>
Redistribution and use in source and binary forms with or without
modification are permitted provided that: (1) source distributions
retain this entire copyright notice and comment, and (2)
distributions including binaries display the following
acknowledgement:  "This product includes software developed by the
University of California, Berkeley and its contributors" in the
documentation or other materials provided with the distribution and
in all advertising materials mentioning features or use of this
software.  Neither the name of the University nor the names of its
contributors may be used to endorse or promote products derived
from this software without specific prior written permission.
</para>

<para>
THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.
</para>
</sect1>

<!-- ************************************************************** -->
<sect1 id="sec-Copyright-ocamllex">
<title>Ocamllex Adaptation Copyright and Permissions Notice</title>

<para>Copyright (C) 2004-2019 SooHyoung Oh.</para>

<para>Permission is granted to make and distribute verbatim copies of this 
manual provided the copyright notice and this permission notice are 
preserved on all copies.</para>

<para>Permission is granted to copy and distribute modified versions of 
this document under the conditions for verbatim copying, provided that 
this copyright notice is included exactly as in the original,
and that the entire resulting derived work is distributed under 
the terms of a permission notice identical to this one.</para>

<para>Permission is granted to copy and distribute translations of this 
document into another language, under the above conditions for modified 
versions.</para>

<para>If you are intending to incorporate this document into a published 
work, please contact the maintainer, and we will make an effort 
to ensure that you have the most up to date information available.</para>

<para>There is no guarantee that this document lives up to its intended
purpose.  This is simply provided as a free resource.  As such,
the authors and maintainers of the information provided within can
not make any guarantee that the information is even accurate.</para>

</sect1>

</chapter>
</book>

